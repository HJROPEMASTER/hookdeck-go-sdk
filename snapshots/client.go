// This file was auto-generated by Fern from our API Definition.

package snapshots

import (
	bytes "bytes"
	context "context"
	fmt "fmt"
	hookdeckgosdk "github.com/hookdeck/hookdeck-go-sdk"
	core "github.com/hookdeck/hookdeck-go-sdk/core"
	io "io"
	multipart "mime/multipart"
	http "net/http"
	url "net/url"
)

type Client struct {
	baseURL string
	caller  *core.Caller
	header  http.Header
}

func NewClient(opts ...core.ClientOption) *Client {
	options := core.NewClientOptions()
	for _, opt := range opts {
		opt(options)
	}
	return &Client{
		baseURL: options.BaseURL,
		caller:  core.NewCaller(options.HTTPClient),
		header:  options.ToHeader(),
	}
}

// Recover local collection data from an uploaded snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
//
// Name of the collection
func (c *Client) RecoverFromUploadedSnapshot(ctx context.Context, collectionName string, snapshot io.Reader, request *hookdeckgosdk.RecoverFromUploadedSnapshotRequest) (*hookdeckgosdk.RecoverFromUploadedSnapshotResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/snapshots/upload", collectionName)

	queryParams := make(url.Values)
	if request.Wait != nil {
		queryParams.Add("wait", fmt.Sprintf("%v", *request.Wait))
	}
	if request.Priority != nil {
		queryParams.Add("priority", fmt.Sprintf("%v", *request.Priority))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *hookdeckgosdk.RecoverFromUploadedSnapshotResponse
	requestBuffer := bytes.NewBuffer(nil)
	writer := multipart.NewWriter(requestBuffer)
	snapshotFilename := "snapshot_filename"
	if named, ok := snapshot.(interface{ Name() string }); ok {
		snapshotFilename = named.Name()
	}
	snapshotPart, err := writer.CreateFormFile("snapshot", snapshotFilename)
	if err != nil {
		return nil, err
	}
	if _, err := io.Copy(snapshotPart, snapshot); err != nil {
		return nil, err
	}
	if err := writer.Close(); err != nil {
		return nil, err
	}
	c.header.Set("Content-Type", writer.FormDataContentType())

	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPost,
			Headers:  c.header,
			Request:  requestBuffer,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Recover local collection data from a snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
//
// Name of the collection
func (c *Client) RecoverFromSnapshot(ctx context.Context, collectionName string, request *hookdeckgosdk.SnapshotRecover) (*hookdeckgosdk.RecoverFromSnapshotResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/snapshots/recover", collectionName)

	queryParams := make(url.Values)
	if request.Wait != nil {
		queryParams.Add("wait", fmt.Sprintf("%v", *request.Wait))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *hookdeckgosdk.RecoverFromSnapshotResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPut,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Get list of snapshots for a collection
//
// Name of the collection
func (c *Client) ListSnapshots(ctx context.Context, collectionName string) (*hookdeckgosdk.ListSnapshotsResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/snapshots", collectionName)

	var response *hookdeckgosdk.ListSnapshotsResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodGet,
			Headers:  c.header,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Create new snapshot for a collection
//
// Name of the collection for which to create a snapshot
func (c *Client) CreateSnapshot(ctx context.Context, collectionName string, request *hookdeckgosdk.CreateSnapshotRequest) (*hookdeckgosdk.CreateSnapshotResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/snapshots", collectionName)

	queryParams := make(url.Values)
	if request.Wait != nil {
		queryParams.Add("wait", fmt.Sprintf("%v", *request.Wait))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *hookdeckgosdk.CreateSnapshotResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPost,
			Headers:  c.header,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Download specified snapshot from a collection as a file
//
// Name of the collection
// Name of the snapshot to download
func (c *Client) GetSnapshot(ctx context.Context, collectionName string, snapshotName string) (io.Reader, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/snapshots/%v", collectionName, snapshotName)

	response := bytes.NewBuffer(nil)
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodGet,
			Headers:  c.header,
			Response: response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Delete snapshot for a collection
//
// Name of the collection for which to delete a snapshot
// Name of the snapshot to delete
func (c *Client) DeleteSnapshot(ctx context.Context, collectionName string, snapshotName string, request *hookdeckgosdk.DeleteSnapshotRequest) (*hookdeckgosdk.DeleteSnapshotResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/snapshots/%v", collectionName, snapshotName)

	queryParams := make(url.Values)
	if request.Wait != nil {
		queryParams.Add("wait", fmt.Sprintf("%v", *request.Wait))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *hookdeckgosdk.DeleteSnapshotResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodDelete,
			Headers:  c.header,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Get list of snapshots of the whole storage
func (c *Client) ListFullSnapshots(ctx context.Context) (*hookdeckgosdk.ListFullSnapshotsResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := baseURL + "/" + "snapshots"

	var response *hookdeckgosdk.ListFullSnapshotsResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodGet,
			Headers:  c.header,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Create new snapshot of the whole storage
func (c *Client) CreateFullSnapshot(ctx context.Context, request *hookdeckgosdk.CreateFullSnapshotRequest) (*hookdeckgosdk.CreateFullSnapshotResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := baseURL + "/" + "snapshots"

	queryParams := make(url.Values)
	if request.Wait != nil {
		queryParams.Add("wait", fmt.Sprintf("%v", *request.Wait))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *hookdeckgosdk.CreateFullSnapshotResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPost,
			Headers:  c.header,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Download specified snapshot of the whole storage as a file
//
// Name of the snapshot to download
func (c *Client) GetFullSnapshot(ctx context.Context, snapshotName string) (io.Reader, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"snapshots/%v", snapshotName)

	response := bytes.NewBuffer(nil)
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodGet,
			Headers:  c.header,
			Response: response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Delete snapshot of the whole storage
//
// Name of the full snapshot to delete
func (c *Client) DeleteFullSnapshot(ctx context.Context, snapshotName string, request *hookdeckgosdk.DeleteFullSnapshotRequest) (*hookdeckgosdk.DeleteFullSnapshotResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"snapshots/%v", snapshotName)

	queryParams := make(url.Values)
	if request.Wait != nil {
		queryParams.Add("wait", fmt.Sprintf("%v", *request.Wait))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *hookdeckgosdk.DeleteFullSnapshotResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodDelete,
			Headers:  c.header,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Recover shard of a local collection from an uploaded snapshot. This will overwrite any data, stored on this node, for the collection shard.
//
// Name of the collection
// Id of the shard to recover
func (c *Client) RecoverShardFromUploadedSnapshot(ctx context.Context, collectionName string, shardId int, snapshot io.Reader, request *hookdeckgosdk.RecoverShardFromUploadedSnapshotRequest) (*hookdeckgosdk.RecoverShardFromUploadedSnapshotResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/shards/%v/snapshots/upload", collectionName, shardId)

	queryParams := make(url.Values)
	if request.Wait != nil {
		queryParams.Add("wait", fmt.Sprintf("%v", *request.Wait))
	}
	if request.Priority != nil {
		queryParams.Add("priority", fmt.Sprintf("%v", *request.Priority))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *hookdeckgosdk.RecoverShardFromUploadedSnapshotResponse
	requestBuffer := bytes.NewBuffer(nil)
	writer := multipart.NewWriter(requestBuffer)
	snapshotFilename := "snapshot_filename"
	if named, ok := snapshot.(interface{ Name() string }); ok {
		snapshotFilename = named.Name()
	}
	snapshotPart, err := writer.CreateFormFile("snapshot", snapshotFilename)
	if err != nil {
		return nil, err
	}
	if _, err := io.Copy(snapshotPart, snapshot); err != nil {
		return nil, err
	}
	if err := writer.Close(); err != nil {
		return nil, err
	}
	c.header.Set("Content-Type", writer.FormDataContentType())

	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPost,
			Headers:  c.header,
			Request:  requestBuffer,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Recover shard of a local collection data from a snapshot. This will overwrite any data, stored in this shard, for the collection.
//
// Name of the collection
// Id of the shard to recover
func (c *Client) RecoverShardFromSnapshot(ctx context.Context, collectionName string, shardId int, request *hookdeckgosdk.ShardSnapshotRecover) (*hookdeckgosdk.RecoverShardFromSnapshotResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/shards/%v/snapshots/recover", collectionName, shardId)

	queryParams := make(url.Values)
	if request.Wait != nil {
		queryParams.Add("wait", fmt.Sprintf("%v", *request.Wait))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *hookdeckgosdk.RecoverShardFromSnapshotResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPut,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Get list of snapshots for a shard of a collection
//
// Name of the collection
// Id of the shard
func (c *Client) ListShardSnapshots(ctx context.Context, collectionName string, shardId int) (*hookdeckgosdk.ListShardSnapshotsResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/shards/%v/snapshots", collectionName, shardId)

	var response *hookdeckgosdk.ListShardSnapshotsResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodGet,
			Headers:  c.header,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Create new snapshot of a shard for a collection
//
// Name of the collection for which to create a snapshot
// Id of the shard
func (c *Client) CreateShardSnapshot(ctx context.Context, collectionName string, shardId int, request *hookdeckgosdk.CreateShardSnapshotRequest) (*hookdeckgosdk.CreateShardSnapshotResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/shards/%v/snapshots", collectionName, shardId)

	queryParams := make(url.Values)
	if request.Wait != nil {
		queryParams.Add("wait", fmt.Sprintf("%v", *request.Wait))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *hookdeckgosdk.CreateShardSnapshotResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPost,
			Headers:  c.header,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Download specified snapshot of a shard from a collection as a file
//
// Name of the collection
// Id of the shard
// Name of the snapshot to download
func (c *Client) GetShardSnapshot(ctx context.Context, collectionName string, shardId int, snapshotName string) (io.Reader, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/shards/%v/snapshots/%v", collectionName, shardId, snapshotName)

	response := bytes.NewBuffer(nil)
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodGet,
			Headers:  c.header,
			Response: response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Delete snapshot of a shard for a collection
//
// Name of the collection for which to delete a snapshot
// Id of the shard
// Name of the snapshot to delete
func (c *Client) DeleteShardSnapshot(ctx context.Context, collectionName string, shardId int, snapshotName string, request *hookdeckgosdk.DeleteShardSnapshotRequest) (*hookdeckgosdk.DeleteShardSnapshotResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/shards/%v/snapshots/%v", collectionName, shardId, snapshotName)

	queryParams := make(url.Values)
	if request.Wait != nil {
		queryParams.Add("wait", fmt.Sprintf("%v", *request.Wait))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *hookdeckgosdk.DeleteShardSnapshotResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodDelete,
			Headers:  c.header,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}
