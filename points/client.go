// This file was auto-generated by Fern from our API Definition.

package points

import (
	context "context"
	fmt "fmt"
	hookdeckgosdk "github.com/hookdeck/hookdeck-go-sdk"
	core "github.com/hookdeck/hookdeck-go-sdk/core"
	http "net/http"
	url "net/url"
)

type Client struct {
	baseURL string
	caller  *core.Caller
	header  http.Header
}

func NewClient(opts ...core.ClientOption) *Client {
	options := core.NewClientOptions()
	for _, opt := range opts {
		opt(options)
	}
	return &Client{
		baseURL: options.BaseURL,
		caller:  core.NewCaller(options.HTTPClient),
		header:  options.ToHeader(),
	}
}

// Retrieve full information of single point by id
//
// Name of the collection to retrieve from
// Id of the point
func (c *Client) GetPoint(ctx context.Context, collectionName string, id *hookdeckgosdk.ExtendedPointId) (*hookdeckgosdk.GetPointResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/points/%v", collectionName, id)

	var response *hookdeckgosdk.GetPointResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodGet,
			Headers:  c.header,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Retrieve multiple points by specified IDs
//
// Name of the collection to retrieve from
func (c *Client) GetPoints(ctx context.Context, collectionName string, request *hookdeckgosdk.PointRequest) (*hookdeckgosdk.GetPointsResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/points", collectionName)

	var response *hookdeckgosdk.GetPointsResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPost,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Perform insert + updates on points. If point with given ID already exists - it will be overwritten.
//
// Name of the collection to update from
func (c *Client) UpsertPoints(ctx context.Context, collectionName string, request *hookdeckgosdk.UpsertPointsRequest) (*hookdeckgosdk.UpsertPointsResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/points", collectionName)

	queryParams := make(url.Values)
	if request.Wait != nil {
		queryParams.Add("wait", fmt.Sprintf("%v", *request.Wait))
	}
	if request.Ordering != nil {
		queryParams.Add("ordering", fmt.Sprintf("%v", *request.Ordering))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *hookdeckgosdk.UpsertPointsResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPut,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Delete points
//
// Name of the collection to delete from
func (c *Client) DeletePoints(ctx context.Context, collectionName string, request *hookdeckgosdk.DeletePointsRequest) (*hookdeckgosdk.DeletePointsResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/points/delete", collectionName)

	queryParams := make(url.Values)
	if request.Wait != nil {
		queryParams.Add("wait", fmt.Sprintf("%v", *request.Wait))
	}
	if request.Ordering != nil {
		queryParams.Add("ordering", fmt.Sprintf("%v", *request.Ordering))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *hookdeckgosdk.DeletePointsResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPost,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Update specified named vectors on points, keep unspecified vectors intact.
//
// Name of the collection to update from
func (c *Client) UpdateVectors(ctx context.Context, collectionName string, request *hookdeckgosdk.UpdateVectorsRequest) (*hookdeckgosdk.UpdateVectorsResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/points/vectors", collectionName)

	queryParams := make(url.Values)
	if request.Wait != nil {
		queryParams.Add("wait", fmt.Sprintf("%v", *request.Wait))
	}
	if request.Ordering != nil {
		queryParams.Add("ordering", fmt.Sprintf("%v", *request.Ordering))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *hookdeckgosdk.UpdateVectorsResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPut,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Delete named vectors from the given points.
//
// Name of the collection to delete from
func (c *Client) DeleteVectors(ctx context.Context, collectionName string, request *hookdeckgosdk.DeleteVectorsRequest) (*hookdeckgosdk.DeleteVectorsResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/points/vectors/delete", collectionName)

	queryParams := make(url.Values)
	if request.Wait != nil {
		queryParams.Add("wait", fmt.Sprintf("%v", *request.Wait))
	}
	if request.Ordering != nil {
		queryParams.Add("ordering", fmt.Sprintf("%v", *request.Ordering))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *hookdeckgosdk.DeleteVectorsResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPost,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Set payload values for points
//
// Name of the collection to set from
func (c *Client) SetPayload(ctx context.Context, collectionName string, request *hookdeckgosdk.SetPayloadRequest) (*hookdeckgosdk.SetPayloadResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/points/payload", collectionName)

	queryParams := make(url.Values)
	if request.Wait != nil {
		queryParams.Add("wait", fmt.Sprintf("%v", *request.Wait))
	}
	if request.Ordering != nil {
		queryParams.Add("ordering", fmt.Sprintf("%v", *request.Ordering))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *hookdeckgosdk.SetPayloadResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPost,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Replace full payload of points with new one
//
// Name of the collection to set from
func (c *Client) OverwritePayload(ctx context.Context, collectionName string, request *hookdeckgosdk.OverwritePayloadRequest) (*hookdeckgosdk.OverwritePayloadResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/points/payload", collectionName)

	queryParams := make(url.Values)
	if request.Wait != nil {
		queryParams.Add("wait", fmt.Sprintf("%v", *request.Wait))
	}
	if request.Ordering != nil {
		queryParams.Add("ordering", fmt.Sprintf("%v", *request.Ordering))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *hookdeckgosdk.OverwritePayloadResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPut,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Delete specified key payload for points
//
// Name of the collection to delete from
func (c *Client) DeletePayload(ctx context.Context, collectionName string, request *hookdeckgosdk.DeletePayloadRequest) (*hookdeckgosdk.DeletePayloadResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/points/payload/delete", collectionName)

	queryParams := make(url.Values)
	if request.Wait != nil {
		queryParams.Add("wait", fmt.Sprintf("%v", *request.Wait))
	}
	if request.Ordering != nil {
		queryParams.Add("ordering", fmt.Sprintf("%v", *request.Ordering))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *hookdeckgosdk.DeletePayloadResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPost,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Remove all payload for specified points
//
// Name of the collection to clear payload from
func (c *Client) ClearPayload(ctx context.Context, collectionName string, request *hookdeckgosdk.ClearPayloadRequest) (*hookdeckgosdk.ClearPayloadResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/points/payload/clear", collectionName)

	queryParams := make(url.Values)
	if request.Wait != nil {
		queryParams.Add("wait", fmt.Sprintf("%v", *request.Wait))
	}
	if request.Ordering != nil {
		queryParams.Add("ordering", fmt.Sprintf("%v", *request.Ordering))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *hookdeckgosdk.ClearPayloadResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPost,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Apply a series of update operations for points, vectors and payloads
//
// Name of the collection to apply operations on
func (c *Client) BatchUpdate(ctx context.Context, collectionName string, request *hookdeckgosdk.UpdateOperations) (*hookdeckgosdk.BatchUpdateResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/points/batch", collectionName)

	queryParams := make(url.Values)
	if request.Wait != nil {
		queryParams.Add("wait", fmt.Sprintf("%v", *request.Wait))
	}
	if request.Ordering != nil {
		queryParams.Add("ordering", fmt.Sprintf("%v", *request.Ordering))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *hookdeckgosdk.BatchUpdateResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPost,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Scroll request - paginate over all points which matches given filtering condition
//
// Name of the collection to retrieve from
func (c *Client) ScrollPoints(ctx context.Context, collectionName string, request *hookdeckgosdk.ScrollRequest) (*hookdeckgosdk.ScrollPointsResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/points/scroll", collectionName)

	var response *hookdeckgosdk.ScrollPointsResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPost,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Retrieve closest points based on vector similarity and given filtering conditions
//
// Name of the collection to search in
func (c *Client) SearchPoints(ctx context.Context, collectionName string, request *hookdeckgosdk.SearchPointsRequest) (*hookdeckgosdk.SearchPointsResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/points/search", collectionName)

	queryParams := make(url.Values)
	if request.Timeout != nil {
		queryParams.Add("timeout", fmt.Sprintf("%v", *request.Timeout))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *hookdeckgosdk.SearchPointsResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPost,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Retrieve by batch the closest points based on vector similarity and given filtering conditions
//
// Name of the collection to search in
func (c *Client) SearchBatchPoints(ctx context.Context, collectionName string, request *hookdeckgosdk.SearchRequestBatch) (*hookdeckgosdk.SearchBatchPointsResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/points/search/batch", collectionName)

	queryParams := make(url.Values)
	if request.Timeout != nil {
		queryParams.Add("timeout", fmt.Sprintf("%v", *request.Timeout))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *hookdeckgosdk.SearchBatchPointsResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPost,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Retrieve closest points based on vector similarity and given filtering conditions, grouped by a given payload field
//
// Name of the collection to search in
func (c *Client) SearchPointGroups(ctx context.Context, collectionName string, request *hookdeckgosdk.SearchGroupsRequest) (*hookdeckgosdk.SearchPointGroupsResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/points/search/groups", collectionName)

	queryParams := make(url.Values)
	if request.Timeout != nil {
		queryParams.Add("timeout", fmt.Sprintf("%v", *request.Timeout))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *hookdeckgosdk.SearchPointGroupsResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPost,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Look for the points which are closer to stored positive examples and at the same time further to negative examples.
//
// Name of the collection to search in
func (c *Client) RecommendPoints(ctx context.Context, collectionName string, request *hookdeckgosdk.RecommendPointsRequest) (*hookdeckgosdk.RecommendPointsResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/points/recommend", collectionName)

	queryParams := make(url.Values)
	if request.Timeout != nil {
		queryParams.Add("timeout", fmt.Sprintf("%v", *request.Timeout))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *hookdeckgosdk.RecommendPointsResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPost,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Look for the points which are closer to stored positive examples and at the same time further to negative examples.
//
// Name of the collection to search in
func (c *Client) RecommendBatchPoints(ctx context.Context, collectionName string, request *hookdeckgosdk.RecommendRequestBatch) (*hookdeckgosdk.RecommendBatchPointsResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/points/recommend/batch", collectionName)

	queryParams := make(url.Values)
	if request.Timeout != nil {
		queryParams.Add("timeout", fmt.Sprintf("%v", *request.Timeout))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *hookdeckgosdk.RecommendBatchPointsResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPost,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Look for the points which are closer to stored positive examples and at the same time further to negative examples, grouped by a given payload field.
//
// Name of the collection to search in
func (c *Client) RecommendPointGroups(ctx context.Context, collectionName string, request *hookdeckgosdk.RecommendGroupsRequest) (*hookdeckgosdk.RecommendPointGroupsResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/points/recommend/groups", collectionName)

	queryParams := make(url.Values)
	if request.Timeout != nil {
		queryParams.Add("timeout", fmt.Sprintf("%v", *request.Timeout))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *hookdeckgosdk.RecommendPointGroupsResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPost,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Use context and a target to find the most similar points to the target, constrained by the context.
// When using only the context (without a target), a special search - called context search - is performed where pairs of points are used to generate a loss that guides the search towards the zone where most positive examples overlap. This means that the score minimizes the scenario of finding a point closer to a negative than to a positive part of a pair.
// Since the score of a context relates to loss, the maximum score a point can get is 0.0, and it becomes normal that many points can have a score of 0.0.
// When using target (with or without context), the score behaves a little different: The integer part of the score represents the rank with respect to the context, while the decimal part of the score relates to the distance to the target. The context part of the score for each pair is calculated +1 if the point is closer to a positive than to a negative part of a pair, and -1 otherwise.
//
// Name of the collection to search in
func (c *Client) DiscoverPoints(ctx context.Context, collectionName string, request *hookdeckgosdk.DiscoverPointsRequest) (*hookdeckgosdk.DiscoverPointsResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/points/discover", collectionName)

	queryParams := make(url.Values)
	if request.Timeout != nil {
		queryParams.Add("timeout", fmt.Sprintf("%v", *request.Timeout))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *hookdeckgosdk.DiscoverPointsResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPost,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Look for points based on target and/or positive and negative example pairs, in batch.
//
// Name of the collection to search in
func (c *Client) DiscoverBatchPoints(ctx context.Context, collectionName string, request *hookdeckgosdk.DiscoverRequestBatch) (*hookdeckgosdk.DiscoverBatchPointsResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/points/discover/batch", collectionName)

	queryParams := make(url.Values)
	if request.Timeout != nil {
		queryParams.Add("timeout", fmt.Sprintf("%v", *request.Timeout))
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}

	var response *hookdeckgosdk.DiscoverBatchPointsResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPost,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Count points which matches given filtering condition
//
// Name of the collection to count in
func (c *Client) CountPoints(ctx context.Context, collectionName string, request *hookdeckgosdk.CountRequest) (*hookdeckgosdk.CountPointsResponse, error) {
	baseURL := "http://localhost:6333"
	if c.baseURL != "" {
		baseURL = c.baseURL
	}
	endpointURL := fmt.Sprintf(baseURL+"/"+"collections/%v/points/count", collectionName)

	var response *hookdeckgosdk.CountPointsResponse
	if err := c.caller.Call(
		ctx,
		&core.CallParams{
			URL:      endpointURL,
			Method:   http.MethodPost,
			Headers:  c.header,
			Request:  request,
			Response: &response,
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}
