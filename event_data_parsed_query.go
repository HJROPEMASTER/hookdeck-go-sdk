// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
)

type EventDataParsedQuery struct {
	typeName                                 string
	StringOptional                           *string
	EventDataParsedQueryEventDataParsedQuery *EventDataParsedQueryEventDataParsedQuery
}

func NewEventDataParsedQueryFromStringOptional(value *string) *EventDataParsedQuery {
	return &EventDataParsedQuery{typeName: "stringOptional", StringOptional: value}
}

func NewEventDataParsedQueryFromEventDataParsedQueryEventDataParsedQuery(value *EventDataParsedQueryEventDataParsedQuery) *EventDataParsedQuery {
	return &EventDataParsedQuery{typeName: "eventDataParsedQueryEventDataParsedQuery", EventDataParsedQueryEventDataParsedQuery: value}
}

func (e *EventDataParsedQuery) UnmarshalJSON(data []byte) error {
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		e.typeName = "stringOptional"
		e.StringOptional = valueStringOptional
		return nil
	}
	valueEventDataParsedQueryEventDataParsedQuery := new(EventDataParsedQueryEventDataParsedQuery)
	if err := json.Unmarshal(data, &valueEventDataParsedQueryEventDataParsedQuery); err == nil {
		e.typeName = "eventDataParsedQueryEventDataParsedQuery"
		e.EventDataParsedQueryEventDataParsedQuery = valueEventDataParsedQueryEventDataParsedQuery
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventDataParsedQuery) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "stringOptional":
		return json.Marshal(e.StringOptional)
	case "eventDataParsedQueryEventDataParsedQuery":
		return json.Marshal(e.EventDataParsedQueryEventDataParsedQuery)
	}
}

type EventDataParsedQueryVisitor interface {
	VisitStringOptional(*string) error
	VisitEventDataParsedQueryEventDataParsedQuery(*EventDataParsedQueryEventDataParsedQuery) error
}

func (e *EventDataParsedQuery) Accept(v EventDataParsedQueryVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "stringOptional":
		return v.VisitStringOptional(e.StringOptional)
	case "eventDataParsedQueryEventDataParsedQuery":
		return v.VisitEventDataParsedQueryEventDataParsedQuery(e.EventDataParsedQueryEventDataParsedQuery)
	}
}
