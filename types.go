// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	time "time"
)

type AddCustomHostname struct {
	// The custom hostname to attach to the workspace
	Hostname string `json:"hostname"`
}

// Error response model
type ApiErrorResponse struct {
	// Error code
	Code string `json:"code"`
	// Status code
	Status float64 `json:"status"`
	// Error description
	Message string                `json:"message"`
	Data    *ApiErrorResponseData `json:"data,omitempty"`
}

type ApiErrorResponseData struct {
}

type ApiKeyIntegrationConfigs struct {
	HeaderKey string `json:"header_key"`
	ApiKey    string `json:"api_key"`
}

type AttachedIntegrationToSource struct {
	Success bool `json:"success"`
}

// Error code of the delivery attempt
type AttemptErrorCodes string

const (
	AttemptErrorCodesCancelled                AttemptErrorCodes = "CANCELLED"
	AttemptErrorCodesTimeout                  AttemptErrorCodes = "TIMEOUT"
	AttemptErrorCodesNotFound                 AttemptErrorCodes = "NOT_FOUND"
	AttemptErrorCodesConnectionRefused        AttemptErrorCodes = "CONNECTION_REFUSED"
	AttemptErrorCodesConnectionReset          AttemptErrorCodes = "CONNECTION_RESET"
	AttemptErrorCodesMissingUrl               AttemptErrorCodes = "MISSING_URL"
	AttemptErrorCodesCli                      AttemptErrorCodes = "CLI"
	AttemptErrorCodesCliUnavailable           AttemptErrorCodes = "CLI_UNAVAILABLE"
	AttemptErrorCodesSelfSignedCert           AttemptErrorCodes = "SELF_SIGNED_CERT"
	AttemptErrorCodesErrTlsCertAltnameInvalid AttemptErrorCodes = "ERR_TLS_CERT_ALTNAME_INVALID"
	AttemptErrorCodesSslErrorCaUnknown        AttemptErrorCodes = "SSL_ERROR_CA_UNKNOWN"
	AttemptErrorCodesTtlExpired               AttemptErrorCodes = "TTL_EXPIRED"
	AttemptErrorCodesDataArchived             AttemptErrorCodes = "DATA_ARCHIVED"
	AttemptErrorCodesSslCertExpired           AttemptErrorCodes = "SSL_CERT_EXPIRED"
	AttemptErrorCodesBulkRetryCancelled       AttemptErrorCodes = "BULK_RETRY_CANCELLED"
	AttemptErrorCodesDnsLookupFailed          AttemptErrorCodes = "DNS_LOOKUP_FAILED"
	AttemptErrorCodesHostUnreachable          AttemptErrorCodes = "HOST_UNREACHABLE"
	AttemptErrorCodesProtocolError            AttemptErrorCodes = "PROTOCOL_ERROR"
	AttemptErrorCodesSocketClosed             AttemptErrorCodes = "SOCKET_CLOSED"
	AttemptErrorCodesUnknown                  AttemptErrorCodes = "UNKNOWN"
)

func NewAttemptErrorCodesFromString(s string) (AttemptErrorCodes, error) {
	switch s {
	case "CANCELLED":
		return AttemptErrorCodesCancelled, nil
	case "TIMEOUT":
		return AttemptErrorCodesTimeout, nil
	case "NOT_FOUND":
		return AttemptErrorCodesNotFound, nil
	case "CONNECTION_REFUSED":
		return AttemptErrorCodesConnectionRefused, nil
	case "CONNECTION_RESET":
		return AttemptErrorCodesConnectionReset, nil
	case "MISSING_URL":
		return AttemptErrorCodesMissingUrl, nil
	case "CLI":
		return AttemptErrorCodesCli, nil
	case "CLI_UNAVAILABLE":
		return AttemptErrorCodesCliUnavailable, nil
	case "SELF_SIGNED_CERT":
		return AttemptErrorCodesSelfSignedCert, nil
	case "ERR_TLS_CERT_ALTNAME_INVALID":
		return AttemptErrorCodesErrTlsCertAltnameInvalid, nil
	case "SSL_ERROR_CA_UNKNOWN":
		return AttemptErrorCodesSslErrorCaUnknown, nil
	case "TTL_EXPIRED":
		return AttemptErrorCodesTtlExpired, nil
	case "DATA_ARCHIVED":
		return AttemptErrorCodesDataArchived, nil
	case "SSL_CERT_EXPIRED":
		return AttemptErrorCodesSslCertExpired, nil
	case "BULK_RETRY_CANCELLED":
		return AttemptErrorCodesBulkRetryCancelled, nil
	case "DNS_LOOKUP_FAILED":
		return AttemptErrorCodesDnsLookupFailed, nil
	case "HOST_UNREACHABLE":
		return AttemptErrorCodesHostUnreachable, nil
	case "PROTOCOL_ERROR":
		return AttemptErrorCodesProtocolError, nil
	case "SOCKET_CLOSED":
		return AttemptErrorCodesSocketClosed, nil
	case "UNKNOWN":
		return AttemptErrorCodesUnknown, nil
	}
	var t AttemptErrorCodes
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AttemptErrorCodes) Ptr() *AttemptErrorCodes {
	return &a
}

type AttemptListRequestDir string

const (
	AttemptListRequestDirAsc  AttemptListRequestDir = "asc"
	AttemptListRequestDirDesc AttemptListRequestDir = "desc"
)

func NewAttemptListRequestDirFromString(s string) (AttemptListRequestDir, error) {
	switch s {
	case "asc":
		return AttemptListRequestDirAsc, nil
	case "desc":
		return AttemptListRequestDirDesc, nil
	}
	var t AttemptListRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AttemptListRequestDir) Ptr() *AttemptListRequestDir {
	return &a
}

type AttemptState string

const (
	AttemptStateDelivering AttemptState = "DELIVERING"
	AttemptStateQueued     AttemptState = "QUEUED"
	AttemptStatePending    AttemptState = "PENDING"
	AttemptStateCompleted  AttemptState = "COMPLETED"
	AttemptStateHold       AttemptState = "HOLD"
)

func NewAttemptStateFromString(s string) (AttemptState, error) {
	switch s {
	case "DELIVERING":
		return AttemptStateDelivering, nil
	case "QUEUED":
		return AttemptStateQueued, nil
	case "PENDING":
		return AttemptStatePending, nil
	case "COMPLETED":
		return AttemptStateCompleted, nil
	case "HOLD":
		return AttemptStateHold, nil
	}
	var t AttemptState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AttemptState) Ptr() *AttemptState {
	return &a
}

// Attempt status
type AttemptStatus string

const (
	AttemptStatusQueued     AttemptStatus = "QUEUED"
	AttemptStatusFailed     AttemptStatus = "FAILED"
	AttemptStatusSuccessful AttemptStatus = "SUCCESSFUL"
	AttemptStatusHold       AttemptStatus = "HOLD"
)

func NewAttemptStatusFromString(s string) (AttemptStatus, error) {
	switch s {
	case "QUEUED":
		return AttemptStatusQueued, nil
	case "FAILED":
		return AttemptStatusFailed, nil
	case "SUCCESSFUL":
		return AttemptStatusSuccessful, nil
	case "HOLD":
		return AttemptStatusHold, nil
	}
	var t AttemptStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AttemptStatus) Ptr() *AttemptStatus {
	return &a
}

// How the attempt was triggered
type AttemptTrigger string

const (
	AttemptTriggerInitial   AttemptTrigger = "INITIAL"
	AttemptTriggerManual    AttemptTrigger = "MANUAL"
	AttemptTriggerBulkRetry AttemptTrigger = "BULK_RETRY"
	AttemptTriggerUnpause   AttemptTrigger = "UNPAUSE"
	AttemptTriggerAutomatic AttemptTrigger = "AUTOMATIC"
)

func NewAttemptTriggerFromString(s string) (AttemptTrigger, error) {
	switch s {
	case "INITIAL":
		return AttemptTriggerInitial, nil
	case "MANUAL":
		return AttemptTriggerManual, nil
	case "BULK_RETRY":
		return AttemptTriggerBulkRetry, nil
	case "UNPAUSE":
		return AttemptTriggerUnpause, nil
	case "AUTOMATIC":
		return AttemptTriggerAutomatic, nil
	}
	var t AttemptTrigger
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AttemptTrigger) Ptr() *AttemptTrigger {
	return &a
}

// API Key
type AuthApiKey struct {
	Config *DestinationAuthMethodApiKeyConfig `json:"config,omitempty"`
	type_  string
}

func (a *AuthApiKey) Type() string {
	return a.type_
}

func (a *AuthApiKey) UnmarshalJSON(data []byte) error {
	type unmarshaler AuthApiKey
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AuthApiKey(value)
	a.type_ = "API_KEY"
	return nil
}

func (a *AuthApiKey) MarshalJSON() ([]byte, error) {
	type embed AuthApiKey
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
		Type:  "API_KEY",
	}
	return json.Marshal(marshaler)
}

// Basic Auth
type AuthBasicAuth struct {
	Config *DestinationAuthMethodBasicAuthConfig `json:"config,omitempty"`
	type_  string
}

func (a *AuthBasicAuth) Type() string {
	return a.type_
}

func (a *AuthBasicAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler AuthBasicAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AuthBasicAuth(value)
	a.type_ = "BASIC_AUTH"
	return nil
}

func (a *AuthBasicAuth) MarshalJSON() ([]byte, error) {
	type embed AuthBasicAuth
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
		Type:  "BASIC_AUTH",
	}
	return json.Marshal(marshaler)
}

// Bearer Token
type AuthBearerToken struct {
	Config *DestinationAuthMethodBearerTokenConfig `json:"config,omitempty"`
	type_  string
}

func (a *AuthBearerToken) Type() string {
	return a.type_
}

func (a *AuthBearerToken) UnmarshalJSON(data []byte) error {
	type unmarshaler AuthBearerToken
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AuthBearerToken(value)
	a.type_ = "BEARER_TOKEN"
	return nil
}

func (a *AuthBearerToken) MarshalJSON() ([]byte, error) {
	type embed AuthBearerToken
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
		Type:  "BEARER_TOKEN",
	}
	return json.Marshal(marshaler)
}

// Custom Signature
type AuthCustomSignature struct {
	Config *DestinationAuthMethodCustomSignatureConfig `json:"config,omitempty"`
	type_  string
}

func (a *AuthCustomSignature) Type() string {
	return a.type_
}

func (a *AuthCustomSignature) UnmarshalJSON(data []byte) error {
	type unmarshaler AuthCustomSignature
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AuthCustomSignature(value)
	a.type_ = "CUSTOM_SIGNATURE"
	return nil
}

func (a *AuthCustomSignature) MarshalJSON() ([]byte, error) {
	type embed AuthCustomSignature
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
		Type:  "CUSTOM_SIGNATURE",
	}
	return json.Marshal(marshaler)
}

// Hookdeck Signature
type AuthHookdeckSignature struct {
	Config *DestinationAuthMethodSignatureConfig `json:"config,omitempty"`
	type_  string
}

func (a *AuthHookdeckSignature) Type() string {
	return a.type_
}

func (a *AuthHookdeckSignature) UnmarshalJSON(data []byte) error {
	type unmarshaler AuthHookdeckSignature
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AuthHookdeckSignature(value)
	a.type_ = "HOOKDECK_SIGNATURE"
	return nil
}

func (a *AuthHookdeckSignature) MarshalJSON() ([]byte, error) {
	type embed AuthHookdeckSignature
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
		Type:  "HOOKDECK_SIGNATURE",
	}
	return json.Marshal(marshaler)
}

type BasicAuthIntegrationConfigs struct {
	Name     string `json:"name"`
	Password string `json:"password"`
}

type BatchOperation struct {
	// ID of the bulk retry
	Id string `json:"id"`
	// ID of the workspace
	TeamId string `json:"team_id"`
	// Query object to filter records
	Query *BatchOperationQuery `json:"query,omitempty"`
	// Date the bulk retry was created
	CreatedAt time.Time `json:"created_at"`
	// Last time the bulk retry was updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the bulk retry was cancelled
	CancelledAt *time.Time `json:"cancelled_at,omitempty"`
	// Date the bulk retry was completed
	CompletedAt *time.Time `json:"completed_at,omitempty"`
	// Number of batches required to complete the bulk retry
	EstimatedBatch *int `json:"estimated_batch,omitempty"`
	// Number of estimated events to be retried
	EstimatedCount *int `json:"estimated_count,omitempty"`
	// Number of batches currently processed
	ProcessedBatch *int `json:"processed_batch,omitempty"`
	// Number of events that were successfully delivered
	CompletedCount *int `json:"completed_count,omitempty"`
	// Indicates if the bulk retry is currently in progress
	InProgress bool `json:"in_progress"`
	// Progression of the batch operations, values 0 - 1
	Progress *float64 `json:"progress,omitempty"`
	// Number of events that failed to be delivered
	FailedCount *int     `json:"failed_count,omitempty"`
	Number      *float64 `json:"number,omitempty"`
}

type BatchOperationPaginatedResult struct {
	Pagination *SeekPagination   `json:"pagination,omitempty"`
	Count      *int              `json:"count,omitempty"`
	Models     []*BatchOperation `json:"models,omitempty"`
}

// Query object to filter records
type BatchOperationQuery struct {
	typeName         string
	StringUnknownMap map[string]interface{}
	StringOptional   *string
}

func NewBatchOperationQueryFromStringUnknownMap(value map[string]interface{}) *BatchOperationQuery {
	return &BatchOperationQuery{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func NewBatchOperationQueryFromStringOptional(value *string) *BatchOperationQuery {
	return &BatchOperationQuery{typeName: "stringOptional", StringOptional: value}
}

func (b *BatchOperationQuery) UnmarshalJSON(data []byte) error {
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		b.typeName = "stringUnknownMap"
		b.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		b.typeName = "stringOptional"
		b.StringOptional = valueStringOptional
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BatchOperationQuery) MarshalJSON() ([]byte, error) {
	switch b.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "stringUnknownMap":
		return json.Marshal(b.StringUnknownMap)
	case "stringOptional":
		return json.Marshal(b.StringOptional)
	}
}

type BatchOperationQueryVisitor interface {
	VisitStringUnknownMap(map[string]interface{}) error
	VisitStringOptional(*string) error
}

func (b *BatchOperationQuery) Accept(visitor BatchOperationQueryVisitor) error {
	switch b.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(b.StringUnknownMap)
	case "stringOptional":
		return visitor.VisitStringOptional(b.StringOptional)
	}
}

type Bookmark struct {
	// ID of the bookmark
	Id string `json:"id"`
	// ID of the workspace
	TeamId string `json:"team_id"`
	// ID of the associated connection
	WebhookId string `json:"webhook_id"`
	// ID of the bookmarked event data
	EventDataId string `json:"event_data_id"`
	// Descriptive name of the bookmark
	Label string `json:"label"`
	// Alternate alias for the bookmark
	Alias *string         `json:"alias,omitempty"`
	Data  *ShortEventData `json:"data,omitempty"`
	// Date the bookmark was last manually triggered
	LastUsedAt *time.Time `json:"last_used_at,omitempty"`
	// Date the bookmark was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the bookmark was created
	CreatedAt time.Time `json:"created_at"`
}

type BookmarkListRequestDir string

const (
	BookmarkListRequestDirAsc  BookmarkListRequestDir = "asc"
	BookmarkListRequestDirDesc BookmarkListRequestDir = "desc"
)

func NewBookmarkListRequestDirFromString(s string) (BookmarkListRequestDir, error) {
	switch s {
	case "asc":
		return BookmarkListRequestDirAsc, nil
	case "desc":
		return BookmarkListRequestDirDesc, nil
	}
	var t BookmarkListRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BookmarkListRequestDir) Ptr() *BookmarkListRequestDir {
	return &b
}

type BookmarkPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Bookmark     `json:"models,omitempty"`
}

// Bookmark target
type BookmarkTriggerRequestTarget string

const (
	BookmarkTriggerRequestTargetHttp BookmarkTriggerRequestTarget = "http"
	BookmarkTriggerRequestTargetCli  BookmarkTriggerRequestTarget = "cli"
)

func NewBookmarkTriggerRequestTargetFromString(s string) (BookmarkTriggerRequestTarget, error) {
	switch s {
	case "http":
		return BookmarkTriggerRequestTargetHttp, nil
	case "cli":
		return BookmarkTriggerRequestTargetCli, nil
	}
	var t BookmarkTriggerRequestTarget
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BookmarkTriggerRequestTarget) Ptr() *BookmarkTriggerRequestTarget {
	return &b
}

type Connection struct {
	// ID of the connection
	Id string `json:"id"`
	// Unique name of the connection for this source
	Name *string `json:"name,omitempty"`
	// Full name of the connection concatenated from source, connection and desitnation name
	FullName *string `json:"full_name,omitempty"`
	// Description of the connection
	Description *string `json:"description,omitempty"`
	// ID of the workspace
	TeamId      string       `json:"team_id"`
	Destination *Destination `json:"destination,omitempty"`
	Source      *Source      `json:"source,omitempty"`
	// Array of rules configured on the connection
	Rules []*Rule `json:"rules,omitempty"`
	// Date the connection was archived
	ArchivedAt *time.Time `json:"archived_at,omitempty"`
	// Date the connection was paused
	PausedAt *time.Time `json:"paused_at,omitempty"`
	// Date the connection was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the connection was created
	CreatedAt time.Time `json:"created_at"`
}

// Destination input object
type ConnectionCreateRequestDestination struct {
	// Name for the destination <span style="white-space: nowrap">`<= 155 characters`</span>
	Name string `json:"name"`
	// Description for the destination
	Description *string `json:"description,omitempty"`
	// Endpoint of the destination
	Url *string `json:"url,omitempty"`
	// Path for the CLI destination
	CliPath *string `json:"cli_path,omitempty"`
	// Period to rate limit attempts
	RateLimitPeriod *ConnectionCreateRequestDestinationRateLimitPeriod `json:"rate_limit_period,omitempty"`
	// Limit event attempts to receive per period
	RateLimit              *int                         `json:"rate_limit,omitempty"`
	HttpMethod             *DestinationHttpMethod       `json:"http_method,omitempty"`
	AuthMethod             *DestinationAuthMethodConfig `json:"auth_method,omitempty"`
	PathForwardingDisabled *bool                        `json:"path_forwarding_disabled,omitempty"`
}

// Period to rate limit attempts
type ConnectionCreateRequestDestinationRateLimitPeriod string

const (
	ConnectionCreateRequestDestinationRateLimitPeriodSecond ConnectionCreateRequestDestinationRateLimitPeriod = "second"
	ConnectionCreateRequestDestinationRateLimitPeriodMinute ConnectionCreateRequestDestinationRateLimitPeriod = "minute"
	ConnectionCreateRequestDestinationRateLimitPeriodHour   ConnectionCreateRequestDestinationRateLimitPeriod = "hour"
)

func NewConnectionCreateRequestDestinationRateLimitPeriodFromString(s string) (ConnectionCreateRequestDestinationRateLimitPeriod, error) {
	switch s {
	case "second":
		return ConnectionCreateRequestDestinationRateLimitPeriodSecond, nil
	case "minute":
		return ConnectionCreateRequestDestinationRateLimitPeriodMinute, nil
	case "hour":
		return ConnectionCreateRequestDestinationRateLimitPeriodHour, nil
	}
	var t ConnectionCreateRequestDestinationRateLimitPeriod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConnectionCreateRequestDestinationRateLimitPeriod) Ptr() *ConnectionCreateRequestDestinationRateLimitPeriod {
	return &c
}

// Source input object
type ConnectionCreateRequestSource struct {
	// A unique name for the source <span style="white-space: nowrap">`<= 155 characters`</span>
	Name string `json:"name"`
	// Description for the source
	Description        *string                  `json:"description,omitempty"`
	AllowedHttpMethods *SourceAllowedHttpMethod `json:"allowed_http_methods,omitempty"`
	CustomResponse     *SourceCustomResponse    `json:"custom_response,omitempty"`
	Verification       *VerificationConfig      `json:"verification,omitempty"`
}

type ConnectionDeleteResponse struct {
	// ID of the connection
	Id string `json:"id"`
}

type ConnectionListRequestDir string

const (
	ConnectionListRequestDirAsc  ConnectionListRequestDir = "asc"
	ConnectionListRequestDirDesc ConnectionListRequestDir = "desc"
)

func NewConnectionListRequestDirFromString(s string) (ConnectionListRequestDir, error) {
	switch s {
	case "asc":
		return ConnectionListRequestDirAsc, nil
	case "desc":
		return ConnectionListRequestDirDesc, nil
	}
	var t ConnectionListRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConnectionListRequestDir) Ptr() *ConnectionListRequestDir {
	return &c
}

type ConnectionListRequestOrderBy string

const (
	ConnectionListRequestOrderByCreatedAt             ConnectionListRequestOrderBy = "created_at"
	ConnectionListRequestOrderByUpdatedAt             ConnectionListRequestOrderBy = "updated_at"
	ConnectionListRequestOrderBySourcesUpdatedAt      ConnectionListRequestOrderBy = "sources.updated_at"
	ConnectionListRequestOrderBySourcesCreatedAt      ConnectionListRequestOrderBy = "sources.created_at"
	ConnectionListRequestOrderByDestinationsUpdatedAt ConnectionListRequestOrderBy = "destinations.updated_at"
	ConnectionListRequestOrderByDestinationsCreatedAt ConnectionListRequestOrderBy = "destinations.created_at"
)

func NewConnectionListRequestOrderByFromString(s string) (ConnectionListRequestOrderBy, error) {
	switch s {
	case "created_at":
		return ConnectionListRequestOrderByCreatedAt, nil
	case "updated_at":
		return ConnectionListRequestOrderByUpdatedAt, nil
	case "sources.updated_at":
		return ConnectionListRequestOrderBySourcesUpdatedAt, nil
	case "sources.created_at":
		return ConnectionListRequestOrderBySourcesCreatedAt, nil
	case "destinations.updated_at":
		return ConnectionListRequestOrderByDestinationsUpdatedAt, nil
	case "destinations.created_at":
		return ConnectionListRequestOrderByDestinationsCreatedAt, nil
	}
	var t ConnectionListRequestOrderBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConnectionListRequestOrderBy) Ptr() *ConnectionListRequestOrderBy {
	return &c
}

type ConnectionPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Connection   `json:"models,omitempty"`
}

// Destination input object
type ConnectionUpsertRequestDestination struct {
	// Name for the destination <span style="white-space: nowrap">`<= 155 characters`</span>
	Name string `json:"name"`
	// Description for the destination
	Description *string `json:"description,omitempty"`
	// Endpoint of the destination
	Url *string `json:"url,omitempty"`
	// Path for the CLI destination
	CliPath *string `json:"cli_path,omitempty"`
	// Period to rate limit attempts
	RateLimitPeriod *ConnectionUpsertRequestDestinationRateLimitPeriod `json:"rate_limit_period,omitempty"`
	// Limit event attempts to receive per period
	RateLimit              *int                         `json:"rate_limit,omitempty"`
	HttpMethod             *DestinationHttpMethod       `json:"http_method,omitempty"`
	AuthMethod             *DestinationAuthMethodConfig `json:"auth_method,omitempty"`
	PathForwardingDisabled *bool                        `json:"path_forwarding_disabled,omitempty"`
}

// Period to rate limit attempts
type ConnectionUpsertRequestDestinationRateLimitPeriod string

const (
	ConnectionUpsertRequestDestinationRateLimitPeriodSecond ConnectionUpsertRequestDestinationRateLimitPeriod = "second"
	ConnectionUpsertRequestDestinationRateLimitPeriodMinute ConnectionUpsertRequestDestinationRateLimitPeriod = "minute"
	ConnectionUpsertRequestDestinationRateLimitPeriodHour   ConnectionUpsertRequestDestinationRateLimitPeriod = "hour"
)

func NewConnectionUpsertRequestDestinationRateLimitPeriodFromString(s string) (ConnectionUpsertRequestDestinationRateLimitPeriod, error) {
	switch s {
	case "second":
		return ConnectionUpsertRequestDestinationRateLimitPeriodSecond, nil
	case "minute":
		return ConnectionUpsertRequestDestinationRateLimitPeriodMinute, nil
	case "hour":
		return ConnectionUpsertRequestDestinationRateLimitPeriodHour, nil
	}
	var t ConnectionUpsertRequestDestinationRateLimitPeriod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConnectionUpsertRequestDestinationRateLimitPeriod) Ptr() *ConnectionUpsertRequestDestinationRateLimitPeriod {
	return &c
}

// Source input object
type ConnectionUpsertRequestSource struct {
	// A unique name for the source <span style="white-space: nowrap">`<= 155 characters`</span>
	Name string `json:"name"`
	// Description for the source
	Description        *string                  `json:"description,omitempty"`
	AllowedHttpMethods *SourceAllowedHttpMethod `json:"allowed_http_methods,omitempty"`
	CustomResponse     *SourceCustomResponse    `json:"custom_response,omitempty"`
	Verification       *VerificationConfig      `json:"verification,omitempty"`
}

type ConsoleLine struct {
	Type    ConsoleLineType `json:"type,omitempty"`
	Message string          `json:"message"`
}

type ConsoleLineType string

const (
	ConsoleLineTypeError ConsoleLineType = "error"
	ConsoleLineTypeLog   ConsoleLineType = "log"
	ConsoleLineTypeWarn  ConsoleLineType = "warn"
	ConsoleLineTypeInfo  ConsoleLineType = "info"
	ConsoleLineTypeDebug ConsoleLineType = "debug"
)

func NewConsoleLineTypeFromString(s string) (ConsoleLineType, error) {
	switch s {
	case "error":
		return ConsoleLineTypeError, nil
	case "log":
		return ConsoleLineTypeLog, nil
	case "warn":
		return ConsoleLineTypeWarn, nil
	case "info":
		return ConsoleLineTypeInfo, nil
	case "debug":
		return ConsoleLineTypeDebug, nil
	}
	var t ConsoleLineType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConsoleLineType) Ptr() *ConsoleLineType {
	return &c
}

type DelayRule struct {
	// Delay to introduce in MS
	Delay int `json:"delay"`
	type_ string
}

func (d *DelayRule) Type() string {
	return d.type_
}

func (d *DelayRule) UnmarshalJSON(data []byte) error {
	type unmarshaler DelayRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DelayRule(value)
	d.type_ = "delay"
	return nil
}

func (d *DelayRule) MarshalJSON() ([]byte, error) {
	type embed DelayRule
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*d),
		Type:  "delay",
	}
	return json.Marshal(marshaler)
}

type DeleteCustomDomainSchema struct {
	// The custom hostname ID
	Id string `json:"id"`
}

type DeletedBookmarkResponse struct {
	// Bookmark ID
	Id string `json:"id"`
}

type DeletedIntegration struct {
	Id string `json:"id"`
}

type DeletedIssueTriggerResponse struct {
	Id string `json:"id"`
}

// Delivery issue
type DeliveryIssue struct {
	// Issue ID
	Id string `json:"id"`
	// ID of the workspace
	TeamId string      `json:"team_id"`
	Status IssueStatus `json:"status,omitempty"`
	// ISO timestamp for when the issue was last opened
	OpenedAt time.Time `json:"opened_at"`
	// ISO timestamp for when the issue was first opened
	FirstSeenAt time.Time `json:"first_seen_at"`
	// ISO timestamp for when the issue last occured
	LastSeenAt time.Time `json:"last_seen_at"`
	// ID of the team member who last updated the issue status
	LastUpdatedBy *string `json:"last_updated_by,omitempty"`
	// ISO timestamp for when the issue was dismissed
	DismissedAt    *time.Time `json:"dismissed_at,omitempty"`
	AutoResolvedAt *time.Time `json:"auto_resolved_at,omitempty"`
	MergedWith     *string    `json:"merged_with,omitempty"`
	// ISO timestamp for when the issue was last updated
	UpdatedAt string `json:"updated_at"`
	// ISO timestamp for when the issue was created
	CreatedAt       string                        `json:"created_at"`
	AggregationKeys *DeliveryIssueAggregationKeys `json:"aggregation_keys,omitempty"`
	Reference       *DeliveryIssueReference       `json:"reference,omitempty"`
	type_           string
}

func (d *DeliveryIssue) Type() string {
	return d.type_
}

func (d *DeliveryIssue) UnmarshalJSON(data []byte) error {
	type unmarshaler DeliveryIssue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeliveryIssue(value)
	d.type_ = "delivery"
	return nil
}

func (d *DeliveryIssue) MarshalJSON() ([]byte, error) {
	type embed DeliveryIssue
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*d),
		Type:  "delivery",
	}
	return json.Marshal(marshaler)
}

// Keys used as the aggregation keys a 'delivery' type issue
type DeliveryIssueAggregationKeys struct {
	WebhookId      []string            `json:"webhook_id,omitempty"`
	ResponseStatus []float64           `json:"response_status,omitempty"`
	ErrorCode      []AttemptErrorCodes `json:"error_code,omitempty"`
}

// Delivery issue data
type DeliveryIssueData struct {
	TriggerEvent   *Event        `json:"trigger_event,omitempty"`
	TriggerAttempt *EventAttempt `json:"trigger_attempt,omitempty"`
}

// Reference to the event and attempt an issue is being created for.
type DeliveryIssueReference struct {
	EventId   string `json:"event_id"`
	AttemptId string `json:"attempt_id"`
}

// Delivery issue
type DeliveryIssueWithData struct {
	// Issue ID
	Id string `json:"id"`
	// ID of the workspace
	TeamId string      `json:"team_id"`
	Status IssueStatus `json:"status,omitempty"`
	// ISO timestamp for when the issue was last opened
	OpenedAt time.Time `json:"opened_at"`
	// ISO timestamp for when the issue was first opened
	FirstSeenAt time.Time `json:"first_seen_at"`
	// ISO timestamp for when the issue last occured
	LastSeenAt time.Time `json:"last_seen_at"`
	// ID of the team member who last updated the issue status
	LastUpdatedBy *string `json:"last_updated_by,omitempty"`
	// ISO timestamp for when the issue was dismissed
	DismissedAt    *time.Time `json:"dismissed_at,omitempty"`
	AutoResolvedAt *time.Time `json:"auto_resolved_at,omitempty"`
	MergedWith     *string    `json:"merged_with,omitempty"`
	// ISO timestamp for when the issue was last updated
	UpdatedAt string `json:"updated_at"`
	// ISO timestamp for when the issue was created
	CreatedAt       string                        `json:"created_at"`
	AggregationKeys *DeliveryIssueAggregationKeys `json:"aggregation_keys,omitempty"`
	Reference       *DeliveryIssueReference       `json:"reference,omitempty"`
	Data            *DeliveryIssueData            `json:"data,omitempty"`
	type_           string
}

func (d *DeliveryIssueWithData) Type() string {
	return d.type_
}

func (d *DeliveryIssueWithData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeliveryIssueWithData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeliveryIssueWithData(value)
	d.type_ = "delivery"
	return nil
}

func (d *DeliveryIssueWithData) MarshalJSON() ([]byte, error) {
	type embed DeliveryIssueWithData
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*d),
		Type:  "delivery",
	}
	return json.Marshal(marshaler)
}

// Associated [Destination](#destination-object) object
type Destination struct {
	// ID of the destination
	Id string `json:"id"`
	// A unique, human-friendly name for the destination
	Name string `json:"name"`
	// Description of the destination
	Description *string `json:"description,omitempty"`
	// ID of the workspace
	TeamId                 string `json:"team_id"`
	PathForwardingDisabled *bool  `json:"path_forwarding_disabled,omitempty"`
	// HTTP endpoint of the destination
	Url *string `json:"url,omitempty"`
	// Path for the CLI destination
	CliPath *string `json:"cli_path,omitempty"`
	// Limit event attempts to receive per period. Max value is workspace plan's max attempts thoughput.
	RateLimit       *int                         `json:"rate_limit,omitempty"`
	RateLimitPeriod *DestinationRateLimitPeriod  `json:"rate_limit_period,omitempty"`
	HttpMethod      *DestinationHttpMethod       `json:"http_method,omitempty"`
	AuthMethod      *DestinationAuthMethodConfig `json:"auth_method,omitempty"`
	// Date the destination was archived
	ArchivedAt *time.Time `json:"archived_at,omitempty"`
	// Date the destination was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the destination was created
	CreatedAt time.Time `json:"created_at"`
}

// API key config for the destination's auth method
type DestinationAuthMethodApiKeyConfig struct {
	// Key for the API key auth
	Key string `json:"key"`
	// API key for the API key auth
	ApiKey string `json:"api_key"`
	// Whether the API key should be sent as a header or a query parameter
	To *DestinationAuthMethodApiKeyConfigTo `json:"to,omitempty"`
}

// Whether the API key should be sent as a header or a query parameter
type DestinationAuthMethodApiKeyConfigTo string

const (
	DestinationAuthMethodApiKeyConfigToHeader DestinationAuthMethodApiKeyConfigTo = "header"
	DestinationAuthMethodApiKeyConfigToQuery  DestinationAuthMethodApiKeyConfigTo = "query"
)

func NewDestinationAuthMethodApiKeyConfigToFromString(s string) (DestinationAuthMethodApiKeyConfigTo, error) {
	switch s {
	case "header":
		return DestinationAuthMethodApiKeyConfigToHeader, nil
	case "query":
		return DestinationAuthMethodApiKeyConfigToQuery, nil
	}
	var t DestinationAuthMethodApiKeyConfigTo
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DestinationAuthMethodApiKeyConfigTo) Ptr() *DestinationAuthMethodApiKeyConfigTo {
	return &d
}

// Basic auth config for the destination's auth method
type DestinationAuthMethodBasicAuthConfig struct {
	// Username for basic auth
	Username string `json:"username"`
	// Password for basic auth
	Password string `json:"password"`
}

// Bearer token config for the destination's auth method
type DestinationAuthMethodBearerTokenConfig struct {
	// Token for the bearer token auth
	Token string `json:"token"`
}

// Config for the destination's auth method
type DestinationAuthMethodConfig struct {
	typeName              string
	AuthHookdeckSignature *AuthHookdeckSignature
	AuthBasicAuth         *AuthBasicAuth
	AuthApiKey            *AuthApiKey
	AuthBearerToken       *AuthBearerToken
	AuthCustomSignature   *AuthCustomSignature
}

func NewDestinationAuthMethodConfigFromAuthHookdeckSignature(value *AuthHookdeckSignature) *DestinationAuthMethodConfig {
	return &DestinationAuthMethodConfig{typeName: "authHookdeckSignature", AuthHookdeckSignature: value}
}

func NewDestinationAuthMethodConfigFromAuthBasicAuth(value *AuthBasicAuth) *DestinationAuthMethodConfig {
	return &DestinationAuthMethodConfig{typeName: "authBasicAuth", AuthBasicAuth: value}
}

func NewDestinationAuthMethodConfigFromAuthApiKey(value *AuthApiKey) *DestinationAuthMethodConfig {
	return &DestinationAuthMethodConfig{typeName: "authApiKey", AuthApiKey: value}
}

func NewDestinationAuthMethodConfigFromAuthBearerToken(value *AuthBearerToken) *DestinationAuthMethodConfig {
	return &DestinationAuthMethodConfig{typeName: "authBearerToken", AuthBearerToken: value}
}

func NewDestinationAuthMethodConfigFromAuthCustomSignature(value *AuthCustomSignature) *DestinationAuthMethodConfig {
	return &DestinationAuthMethodConfig{typeName: "authCustomSignature", AuthCustomSignature: value}
}

func (d *DestinationAuthMethodConfig) UnmarshalJSON(data []byte) error {
	valueAuthHookdeckSignature := new(AuthHookdeckSignature)
	if err := json.Unmarshal(data, &valueAuthHookdeckSignature); err == nil {
		d.typeName = "authHookdeckSignature"
		d.AuthHookdeckSignature = valueAuthHookdeckSignature
		return nil
	}
	valueAuthBasicAuth := new(AuthBasicAuth)
	if err := json.Unmarshal(data, &valueAuthBasicAuth); err == nil {
		d.typeName = "authBasicAuth"
		d.AuthBasicAuth = valueAuthBasicAuth
		return nil
	}
	valueAuthApiKey := new(AuthApiKey)
	if err := json.Unmarshal(data, &valueAuthApiKey); err == nil {
		d.typeName = "authApiKey"
		d.AuthApiKey = valueAuthApiKey
		return nil
	}
	valueAuthBearerToken := new(AuthBearerToken)
	if err := json.Unmarshal(data, &valueAuthBearerToken); err == nil {
		d.typeName = "authBearerToken"
		d.AuthBearerToken = valueAuthBearerToken
		return nil
	}
	valueAuthCustomSignature := new(AuthCustomSignature)
	if err := json.Unmarshal(data, &valueAuthCustomSignature); err == nil {
		d.typeName = "authCustomSignature"
		d.AuthCustomSignature = valueAuthCustomSignature
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DestinationAuthMethodConfig) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "authHookdeckSignature":
		return json.Marshal(d.AuthHookdeckSignature)
	case "authBasicAuth":
		return json.Marshal(d.AuthBasicAuth)
	case "authApiKey":
		return json.Marshal(d.AuthApiKey)
	case "authBearerToken":
		return json.Marshal(d.AuthBearerToken)
	case "authCustomSignature":
		return json.Marshal(d.AuthCustomSignature)
	}
}

type DestinationAuthMethodConfigVisitor interface {
	VisitAuthHookdeckSignature(*AuthHookdeckSignature) error
	VisitAuthBasicAuth(*AuthBasicAuth) error
	VisitAuthApiKey(*AuthApiKey) error
	VisitAuthBearerToken(*AuthBearerToken) error
	VisitAuthCustomSignature(*AuthCustomSignature) error
}

func (d *DestinationAuthMethodConfig) Accept(visitor DestinationAuthMethodConfigVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "authHookdeckSignature":
		return visitor.VisitAuthHookdeckSignature(d.AuthHookdeckSignature)
	case "authBasicAuth":
		return visitor.VisitAuthBasicAuth(d.AuthBasicAuth)
	case "authApiKey":
		return visitor.VisitAuthApiKey(d.AuthApiKey)
	case "authBearerToken":
		return visitor.VisitAuthBearerToken(d.AuthBearerToken)
	case "authCustomSignature":
		return visitor.VisitAuthCustomSignature(d.AuthCustomSignature)
	}
}

// Custom signature config for the destination's auth method
type DestinationAuthMethodCustomSignatureConfig struct {
	// Key for the custom signature auth
	Key string `json:"key"`
	// Signing secret for the custom signature auth. If left empty a secret will be generated for you.
	SigningSecret *string `json:"signing_secret,omitempty"`
}

// Empty config for the destination's auth method
type DestinationAuthMethodSignatureConfig struct {
}

// Period to rate limit attempts
type DestinationCreateRequestRateLimitPeriod string

const (
	DestinationCreateRequestRateLimitPeriodSecond DestinationCreateRequestRateLimitPeriod = "second"
	DestinationCreateRequestRateLimitPeriodMinute DestinationCreateRequestRateLimitPeriod = "minute"
	DestinationCreateRequestRateLimitPeriodHour   DestinationCreateRequestRateLimitPeriod = "hour"
)

func NewDestinationCreateRequestRateLimitPeriodFromString(s string) (DestinationCreateRequestRateLimitPeriod, error) {
	switch s {
	case "second":
		return DestinationCreateRequestRateLimitPeriodSecond, nil
	case "minute":
		return DestinationCreateRequestRateLimitPeriodMinute, nil
	case "hour":
		return DestinationCreateRequestRateLimitPeriodHour, nil
	}
	var t DestinationCreateRequestRateLimitPeriod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DestinationCreateRequestRateLimitPeriod) Ptr() *DestinationCreateRequestRateLimitPeriod {
	return &d
}

type DestinationDeleteResponse struct {
	// ID of the destination
	Id string `json:"id"`
}

// HTTP method used on requests sent to the destination, overrides the method used on requests sent to the source.
type DestinationHttpMethod string

const (
	DestinationHttpMethodGet    DestinationHttpMethod = "GET"
	DestinationHttpMethodPost   DestinationHttpMethod = "POST"
	DestinationHttpMethodPut    DestinationHttpMethod = "PUT"
	DestinationHttpMethodPatch  DestinationHttpMethod = "PATCH"
	DestinationHttpMethodDelete DestinationHttpMethod = "DELETE"
)

func NewDestinationHttpMethodFromString(s string) (DestinationHttpMethod, error) {
	switch s {
	case "GET":
		return DestinationHttpMethodGet, nil
	case "POST":
		return DestinationHttpMethodPost, nil
	case "PUT":
		return DestinationHttpMethodPut, nil
	case "PATCH":
		return DestinationHttpMethodPatch, nil
	case "DELETE":
		return DestinationHttpMethodDelete, nil
	}
	var t DestinationHttpMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DestinationHttpMethod) Ptr() *DestinationHttpMethod {
	return &d
}

type DestinationListRequestDir string

const (
	DestinationListRequestDirAsc  DestinationListRequestDir = "asc"
	DestinationListRequestDirDesc DestinationListRequestDir = "desc"
)

func NewDestinationListRequestDirFromString(s string) (DestinationListRequestDir, error) {
	switch s {
	case "asc":
		return DestinationListRequestDirAsc, nil
	case "desc":
		return DestinationListRequestDirDesc, nil
	}
	var t DestinationListRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DestinationListRequestDir) Ptr() *DestinationListRequestDir {
	return &d
}

type DestinationPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Destination  `json:"models,omitempty"`
}

// Period to rate limit attempts
type DestinationRateLimitPeriod string

const (
	DestinationRateLimitPeriodSecond DestinationRateLimitPeriod = "second"
	DestinationRateLimitPeriodMinute DestinationRateLimitPeriod = "minute"
	DestinationRateLimitPeriodHour   DestinationRateLimitPeriod = "hour"
)

func NewDestinationRateLimitPeriodFromString(s string) (DestinationRateLimitPeriod, error) {
	switch s {
	case "second":
		return DestinationRateLimitPeriodSecond, nil
	case "minute":
		return DestinationRateLimitPeriodMinute, nil
	case "hour":
		return DestinationRateLimitPeriodHour, nil
	}
	var t DestinationRateLimitPeriod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DestinationRateLimitPeriod) Ptr() *DestinationRateLimitPeriod {
	return &d
}

// Period to rate limit attempts
type DestinationUpdateRequestRateLimitPeriod string

const (
	DestinationUpdateRequestRateLimitPeriodSecond DestinationUpdateRequestRateLimitPeriod = "second"
	DestinationUpdateRequestRateLimitPeriodMinute DestinationUpdateRequestRateLimitPeriod = "minute"
	DestinationUpdateRequestRateLimitPeriodHour   DestinationUpdateRequestRateLimitPeriod = "hour"
)

func NewDestinationUpdateRequestRateLimitPeriodFromString(s string) (DestinationUpdateRequestRateLimitPeriod, error) {
	switch s {
	case "second":
		return DestinationUpdateRequestRateLimitPeriodSecond, nil
	case "minute":
		return DestinationUpdateRequestRateLimitPeriodMinute, nil
	case "hour":
		return DestinationUpdateRequestRateLimitPeriodHour, nil
	}
	var t DestinationUpdateRequestRateLimitPeriod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DestinationUpdateRequestRateLimitPeriod) Ptr() *DestinationUpdateRequestRateLimitPeriod {
	return &d
}

// Period to rate limit attempts
type DestinationUpsertRequestRateLimitPeriod string

const (
	DestinationUpsertRequestRateLimitPeriodSecond DestinationUpsertRequestRateLimitPeriod = "second"
	DestinationUpsertRequestRateLimitPeriodMinute DestinationUpsertRequestRateLimitPeriod = "minute"
	DestinationUpsertRequestRateLimitPeriodHour   DestinationUpsertRequestRateLimitPeriod = "hour"
)

func NewDestinationUpsertRequestRateLimitPeriodFromString(s string) (DestinationUpsertRequestRateLimitPeriod, error) {
	switch s {
	case "second":
		return DestinationUpsertRequestRateLimitPeriodSecond, nil
	case "minute":
		return DestinationUpsertRequestRateLimitPeriodMinute, nil
	case "hour":
		return DestinationUpsertRequestRateLimitPeriodHour, nil
	}
	var t DestinationUpsertRequestRateLimitPeriod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DestinationUpsertRequestRateLimitPeriod) Ptr() *DestinationUpsertRequestRateLimitPeriod {
	return &d
}

type DetachedIntegrationFromSource struct {
}

type Event struct {
	// ID of the event
	Id string `json:"id"`
	// ID of the workspace
	TeamId string `json:"team_id"`
	// ID of the associated connection
	WebhookId string `json:"webhook_id"`
	// ID of the associated source
	SourceId string `json:"source_id"`
	// ID of the associated destination
	DestinationId string `json:"destination_id"`
	// ID of the event data
	EventDataId string `json:"event_data_id"`
	// ID of the request that created the event
	RequestId string `json:"request_id"`
	// Number of delivery attempts made
	Attempts int `json:"attempts"`
	// Date of the most recently attempted retry
	LastAttemptAt *time.Time `json:"last_attempt_at,omitempty"`
	// Date of the next scheduled retry
	NextAttemptAt *time.Time `json:"next_attempt_at,omitempty"`
	// Event status
	ResponseStatus *int               `json:"response_status,omitempty"`
	ErrorCode      *AttemptErrorCodes `json:"error_code,omitempty"`
	Status         EventStatus        `json:"status,omitempty"`
	// Date of the latest successful attempt
	SuccessfulAt *time.Time `json:"successful_at,omitempty"`
	// ID of the CLI the event is sent to
	CliId *string `json:"cli_id,omitempty"`
	// Date the event was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the event was created
	CreatedAt time.Time       `json:"created_at"`
	Data      *ShortEventData `json:"data,omitempty"`
}

type EventArray = []*Event

type EventAttempt struct {
	// Attempt ID
	Id string `json:"id"`
	// Team ID
	TeamId string `json:"team_id"`
	// Event ID
	EventId string `json:"event_id"`
	// Attempt's HTTP response code
	ResponseStatus *int `json:"response_status,omitempty"`
	// Sequential number of attempts (up to and including this one) made for the associated event
	AttemptNumber *int               `json:"attempt_number,omitempty"`
	Trigger       *AttemptTrigger    `json:"trigger,omitempty"`
	ErrorCode     *AttemptErrorCodes `json:"error_code,omitempty"`
	Body          *EventAttemptBody  `json:"body,omitempty"`
	// URL of the destination where delivery was attempted
	RequestedUrl *string `json:"requested_url,omitempty"`
	// HTTP method used to deliver the attempt
	HttpMethod *EventAttemptHttpMethod `json:"http_method,omitempty"`
	// ID of associated bulk retry
	BulkRetryId *string       `json:"bulk_retry_id,omitempty"`
	Status      AttemptStatus `json:"status,omitempty"`
	// Date the attempt was successful
	SuccessfulAt *time.Time `json:"successful_at,omitempty"`
	// Date the attempt was delivered
	DeliveredAt *time.Time `json:"delivered_at,omitempty"`
	// Date the destination responded to this attempt
	RespondedAt *time.Time `json:"responded_at,omitempty"`
	// Time elapsed between attempt initiation and final delivery (in ms)
	DeliveryLatency *int `json:"delivery_latency,omitempty"`
	// Time elapsed between attempt initiation and a response from the destination (in ms)
	ResponseLatency *int `json:"response_latency,omitempty"`
	// Date the attempt was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the attempt was created
	CreatedAt time.Time     `json:"created_at"`
	State     *AttemptState `json:"state,omitempty"`
	// Date the attempt was archived
	ArchivedAt    *string `json:"archived_at,omitempty"`
	DestinationId *string `json:"destination_id,omitempty"`
}

type EventAttemptBody struct {
	typeName string
	// Response body from the destination
	EventAttemptBodyZeroOptional *EventAttemptBodyZero
	// Response body from the destination
	StringOptional *string
}

func NewEventAttemptBodyFromEventAttemptBodyZeroOptional(value *EventAttemptBodyZero) *EventAttemptBody {
	return &EventAttemptBody{typeName: "eventAttemptBodyZeroOptional", EventAttemptBodyZeroOptional: value}
}

func NewEventAttemptBodyFromStringOptional(value *string) *EventAttemptBody {
	return &EventAttemptBody{typeName: "stringOptional", StringOptional: value}
}

func (e *EventAttemptBody) UnmarshalJSON(data []byte) error {
	var valueEventAttemptBodyZeroOptional *EventAttemptBodyZero
	if err := json.Unmarshal(data, &valueEventAttemptBodyZeroOptional); err == nil {
		e.typeName = "eventAttemptBodyZeroOptional"
		e.EventAttemptBodyZeroOptional = valueEventAttemptBodyZeroOptional
		return nil
	}
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		e.typeName = "stringOptional"
		e.StringOptional = valueStringOptional
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventAttemptBody) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "eventAttemptBodyZeroOptional":
		return json.Marshal(e.EventAttemptBodyZeroOptional)
	case "stringOptional":
		return json.Marshal(e.StringOptional)
	}
}

type EventAttemptBodyVisitor interface {
	VisitEventAttemptBodyZeroOptional(*EventAttemptBodyZero) error
	VisitStringOptional(*string) error
}

func (e *EventAttemptBody) Accept(visitor EventAttemptBodyVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "eventAttemptBodyZeroOptional":
		return visitor.VisitEventAttemptBodyZeroOptional(e.EventAttemptBodyZeroOptional)
	case "stringOptional":
		return visitor.VisitStringOptional(e.StringOptional)
	}
}

// Response body from the destination
type EventAttemptBodyZero struct {
}

// HTTP method used to deliver the attempt
type EventAttemptHttpMethod string

const (
	EventAttemptHttpMethodGet    EventAttemptHttpMethod = "GET"
	EventAttemptHttpMethodPost   EventAttemptHttpMethod = "POST"
	EventAttemptHttpMethodPut    EventAttemptHttpMethod = "PUT"
	EventAttemptHttpMethodPatch  EventAttemptHttpMethod = "PATCH"
	EventAttemptHttpMethodDelete EventAttemptHttpMethod = "DELETE"
)

func NewEventAttemptHttpMethodFromString(s string) (EventAttemptHttpMethod, error) {
	switch s {
	case "GET":
		return EventAttemptHttpMethodGet, nil
	case "POST":
		return EventAttemptHttpMethodPost, nil
	case "PUT":
		return EventAttemptHttpMethodPut, nil
	case "PATCH":
		return EventAttemptHttpMethodPatch, nil
	case "DELETE":
		return EventAttemptHttpMethodDelete, nil
	}
	var t EventAttemptHttpMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventAttemptHttpMethod) Ptr() *EventAttemptHttpMethod {
	return &e
}

type EventAttemptPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*EventAttempt `json:"models,omitempty"`
}

// Filter properties for the events to be included in the bulk retry
type EventBulkRetryCreateRequestQuery struct {
	// Filter by event IDs
	Id *EventBulkRetryCreateRequestQueryId `json:"id,omitempty"`
	// Lifecyle status of the event
	Status *EventBulkRetryCreateRequestQueryStatus `json:"status,omitempty"`
	// Filter by webhook connection IDs
	WebhookId *EventBulkRetryCreateRequestQueryWebhookId `json:"webhook_id,omitempty"`
	// Filter by destination IDs
	DestinationId *EventBulkRetryCreateRequestQueryDestinationId `json:"destination_id,omitempty"`
	// Filter by source IDs
	SourceId *EventBulkRetryCreateRequestQuerySourceId `json:"source_id,omitempty"`
	// Filter by number of attempts
	Attempts *EventBulkRetryCreateRequestQueryAttempts `json:"attempts,omitempty"`
	// Filter by HTTP response status code
	ResponseStatus *EventBulkRetryCreateRequestQueryResponseStatus `json:"response_status,omitempty"`
	// Filter by `successful_at` date using a date operator
	SuccessfulAt *EventBulkRetryCreateRequestQuerySuccessfulAt `json:"successful_at,omitempty"`
	// Filter by `created_at` date using a date operator
	CreatedAt *EventBulkRetryCreateRequestQueryCreatedAt `json:"created_at,omitempty"`
	// Filter by error code code
	ErrorCode *EventBulkRetryCreateRequestQueryErrorCode `json:"error_code,omitempty"`
	// Filter by CLI IDs. `?[any]=true` operator for any CLI.
	CliId *EventBulkRetryCreateRequestQueryCliId `json:"cli_id,omitempty"`
	// Filter by `last_attempt_at` date using a date operator
	LastAttemptAt *EventBulkRetryCreateRequestQueryLastAttemptAt `json:"last_attempt_at,omitempty"`
	// URL Encoded string of the value to match partially to the body, headers, parsed_query or path
	SearchTerm *string `json:"search_term,omitempty"`
	// URL Encoded string of the JSON to match to the data headers
	Headers *EventBulkRetryCreateRequestQueryHeaders `json:"headers,omitempty"`
	// URL Encoded string of the JSON to match to the data body
	Body *EventBulkRetryCreateRequestQueryBody `json:"body,omitempty"`
	// URL Encoded string of the JSON to match to the parsed query (JSON representation of the query)
	ParsedQuery *EventBulkRetryCreateRequestQueryParsedQuery `json:"parsed_query,omitempty"`
	// URL Encoded string of the value to match partially to the path
	Path        *string                                      `json:"path,omitempty"`
	CliUserId   *EventBulkRetryCreateRequestQueryCliUserId   `json:"cli_user_id,omitempty"`
	IssueId     *EventBulkRetryCreateRequestQueryIssueId     `json:"issue_id,omitempty"`
	EventDataId *EventBulkRetryCreateRequestQueryEventDataId `json:"event_data_id,omitempty"`
	BulkRetryId *EventBulkRetryCreateRequestQueryBulkRetryId `json:"bulk_retry_id,omitempty"`
}

// Filter by number of attempts
type EventBulkRetryCreateRequestQueryAttempts struct {
	typeName                                    string
	Integer                                     int
	EventBulkRetryCreateRequestQueryAttemptsAny *EventBulkRetryCreateRequestQueryAttemptsAny
}

func NewEventBulkRetryCreateRequestQueryAttemptsFromInteger(value int) *EventBulkRetryCreateRequestQueryAttempts {
	return &EventBulkRetryCreateRequestQueryAttempts{typeName: "integer", Integer: value}
}

func NewEventBulkRetryCreateRequestQueryAttemptsFromEventBulkRetryCreateRequestQueryAttemptsAny(value *EventBulkRetryCreateRequestQueryAttemptsAny) *EventBulkRetryCreateRequestQueryAttempts {
	return &EventBulkRetryCreateRequestQueryAttempts{typeName: "eventBulkRetryCreateRequestQueryAttemptsAny", EventBulkRetryCreateRequestQueryAttemptsAny: value}
}

func (e *EventBulkRetryCreateRequestQueryAttempts) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		e.typeName = "integer"
		e.Integer = valueInteger
		return nil
	}
	valueEventBulkRetryCreateRequestQueryAttemptsAny := new(EventBulkRetryCreateRequestQueryAttemptsAny)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQueryAttemptsAny); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQueryAttemptsAny"
		e.EventBulkRetryCreateRequestQueryAttemptsAny = valueEventBulkRetryCreateRequestQueryAttemptsAny
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryAttempts) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "integer":
		return json.Marshal(e.Integer)
	case "eventBulkRetryCreateRequestQueryAttemptsAny":
		return json.Marshal(e.EventBulkRetryCreateRequestQueryAttemptsAny)
	}
}

type EventBulkRetryCreateRequestQueryAttemptsVisitor interface {
	VisitInteger(int) error
	VisitEventBulkRetryCreateRequestQueryAttemptsAny(*EventBulkRetryCreateRequestQueryAttemptsAny) error
}

func (e *EventBulkRetryCreateRequestQueryAttempts) Accept(visitor EventBulkRetryCreateRequestQueryAttemptsVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "integer":
		return visitor.VisitInteger(e.Integer)
	case "eventBulkRetryCreateRequestQueryAttemptsAny":
		return visitor.VisitEventBulkRetryCreateRequestQueryAttemptsAny(e.EventBulkRetryCreateRequestQueryAttemptsAny)
	}
}

type EventBulkRetryCreateRequestQueryAttemptsAny struct {
	Gt       *int  `json:"gt,omitempty"`
	Gte      *int  `json:"gte,omitempty"`
	Le       *int  `json:"le,omitempty"`
	Lte      *int  `json:"lte,omitempty"`
	Any      *bool `json:"any,omitempty"`
	Contains *int  `json:"contains,omitempty"`
}

// URL Encoded string of the JSON to match to the data body
type EventBulkRetryCreateRequestQueryBody struct {
	typeName                                string
	String                                  string
	EventBulkRetryCreateRequestQueryBodyOne *EventBulkRetryCreateRequestQueryBodyOne
}

func NewEventBulkRetryCreateRequestQueryBodyFromString(value string) *EventBulkRetryCreateRequestQueryBody {
	return &EventBulkRetryCreateRequestQueryBody{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryBodyFromEventBulkRetryCreateRequestQueryBodyOne(value *EventBulkRetryCreateRequestQueryBodyOne) *EventBulkRetryCreateRequestQueryBody {
	return &EventBulkRetryCreateRequestQueryBody{typeName: "eventBulkRetryCreateRequestQueryBodyOne", EventBulkRetryCreateRequestQueryBodyOne: value}
}

func (e *EventBulkRetryCreateRequestQueryBody) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEventBulkRetryCreateRequestQueryBodyOne := new(EventBulkRetryCreateRequestQueryBodyOne)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQueryBodyOne); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQueryBodyOne"
		e.EventBulkRetryCreateRequestQueryBodyOne = valueEventBulkRetryCreateRequestQueryBodyOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryBody) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "eventBulkRetryCreateRequestQueryBodyOne":
		return json.Marshal(e.EventBulkRetryCreateRequestQueryBodyOne)
	}
}

type EventBulkRetryCreateRequestQueryBodyVisitor interface {
	VisitString(string) error
	VisitEventBulkRetryCreateRequestQueryBodyOne(*EventBulkRetryCreateRequestQueryBodyOne) error
}

func (e *EventBulkRetryCreateRequestQueryBody) Accept(visitor EventBulkRetryCreateRequestQueryBodyVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "eventBulkRetryCreateRequestQueryBodyOne":
		return visitor.VisitEventBulkRetryCreateRequestQueryBodyOne(e.EventBulkRetryCreateRequestQueryBodyOne)
	}
}

type EventBulkRetryCreateRequestQueryBodyOne struct {
}

type EventBulkRetryCreateRequestQueryBulkRetryId struct {
	typeName string
	// <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewEventBulkRetryCreateRequestQueryBulkRetryIdFromString(value string) *EventBulkRetryCreateRequestQueryBulkRetryId {
	return &EventBulkRetryCreateRequestQueryBulkRetryId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryBulkRetryIdFromStringList(value []string) *EventBulkRetryCreateRequestQueryBulkRetryId {
	return &EventBulkRetryCreateRequestQueryBulkRetryId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQueryBulkRetryId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryBulkRetryId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryBulkRetryIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQueryBulkRetryId) Accept(visitor EventBulkRetryCreateRequestQueryBulkRetryIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

// Filter by CLI IDs. `?[any]=true` operator for any CLI.
type EventBulkRetryCreateRequestQueryCliId struct {
	typeName                                 string
	String                                   string
	EventBulkRetryCreateRequestQueryCliIdAny *EventBulkRetryCreateRequestQueryCliIdAny
	StringList                               []string
}

func NewEventBulkRetryCreateRequestQueryCliIdFromString(value string) *EventBulkRetryCreateRequestQueryCliId {
	return &EventBulkRetryCreateRequestQueryCliId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryCliIdFromEventBulkRetryCreateRequestQueryCliIdAny(value *EventBulkRetryCreateRequestQueryCliIdAny) *EventBulkRetryCreateRequestQueryCliId {
	return &EventBulkRetryCreateRequestQueryCliId{typeName: "eventBulkRetryCreateRequestQueryCliIdAny", EventBulkRetryCreateRequestQueryCliIdAny: value}
}

func NewEventBulkRetryCreateRequestQueryCliIdFromStringList(value []string) *EventBulkRetryCreateRequestQueryCliId {
	return &EventBulkRetryCreateRequestQueryCliId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQueryCliId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEventBulkRetryCreateRequestQueryCliIdAny := new(EventBulkRetryCreateRequestQueryCliIdAny)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQueryCliIdAny); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQueryCliIdAny"
		e.EventBulkRetryCreateRequestQueryCliIdAny = valueEventBulkRetryCreateRequestQueryCliIdAny
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryCliId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "eventBulkRetryCreateRequestQueryCliIdAny":
		return json.Marshal(e.EventBulkRetryCreateRequestQueryCliIdAny)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryCliIdVisitor interface {
	VisitString(string) error
	VisitEventBulkRetryCreateRequestQueryCliIdAny(*EventBulkRetryCreateRequestQueryCliIdAny) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQueryCliId) Accept(visitor EventBulkRetryCreateRequestQueryCliIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "eventBulkRetryCreateRequestQueryCliIdAny":
		return visitor.VisitEventBulkRetryCreateRequestQueryCliIdAny(e.EventBulkRetryCreateRequestQueryCliIdAny)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryCliIdAny struct {
	Any *bool `json:"any,omitempty"`
}

type EventBulkRetryCreateRequestQueryCliUserId struct {
	typeName   string
	String     string
	StringList []string
}

func NewEventBulkRetryCreateRequestQueryCliUserIdFromString(value string) *EventBulkRetryCreateRequestQueryCliUserId {
	return &EventBulkRetryCreateRequestQueryCliUserId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryCliUserIdFromStringList(value []string) *EventBulkRetryCreateRequestQueryCliUserId {
	return &EventBulkRetryCreateRequestQueryCliUserId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQueryCliUserId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryCliUserId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryCliUserIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQueryCliUserId) Accept(visitor EventBulkRetryCreateRequestQueryCliUserIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

// Filter by `created_at` date using a date operator
type EventBulkRetryCreateRequestQueryCreatedAt struct {
	typeName                                     string
	DateTime                                     time.Time
	EventBulkRetryCreateRequestQueryCreatedAtAny *EventBulkRetryCreateRequestQueryCreatedAtAny
}

func NewEventBulkRetryCreateRequestQueryCreatedAtFromDateTime(value time.Time) *EventBulkRetryCreateRequestQueryCreatedAt {
	return &EventBulkRetryCreateRequestQueryCreatedAt{typeName: "dateTime", DateTime: value}
}

func NewEventBulkRetryCreateRequestQueryCreatedAtFromEventBulkRetryCreateRequestQueryCreatedAtAny(value *EventBulkRetryCreateRequestQueryCreatedAtAny) *EventBulkRetryCreateRequestQueryCreatedAt {
	return &EventBulkRetryCreateRequestQueryCreatedAt{typeName: "eventBulkRetryCreateRequestQueryCreatedAtAny", EventBulkRetryCreateRequestQueryCreatedAtAny: value}
}

func (e *EventBulkRetryCreateRequestQueryCreatedAt) UnmarshalJSON(data []byte) error {
	var valueDateTime time.Time
	if err := json.Unmarshal(data, &valueDateTime); err == nil {
		e.typeName = "dateTime"
		e.DateTime = valueDateTime
		return nil
	}
	valueEventBulkRetryCreateRequestQueryCreatedAtAny := new(EventBulkRetryCreateRequestQueryCreatedAtAny)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQueryCreatedAtAny); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQueryCreatedAtAny"
		e.EventBulkRetryCreateRequestQueryCreatedAtAny = valueEventBulkRetryCreateRequestQueryCreatedAtAny
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryCreatedAt) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "dateTime":
		return json.Marshal(e.DateTime)
	case "eventBulkRetryCreateRequestQueryCreatedAtAny":
		return json.Marshal(e.EventBulkRetryCreateRequestQueryCreatedAtAny)
	}
}

type EventBulkRetryCreateRequestQueryCreatedAtVisitor interface {
	VisitDateTime(time.Time) error
	VisitEventBulkRetryCreateRequestQueryCreatedAtAny(*EventBulkRetryCreateRequestQueryCreatedAtAny) error
}

func (e *EventBulkRetryCreateRequestQueryCreatedAt) Accept(visitor EventBulkRetryCreateRequestQueryCreatedAtVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "dateTime":
		return visitor.VisitDateTime(e.DateTime)
	case "eventBulkRetryCreateRequestQueryCreatedAtAny":
		return visitor.VisitEventBulkRetryCreateRequestQueryCreatedAtAny(e.EventBulkRetryCreateRequestQueryCreatedAtAny)
	}
}

type EventBulkRetryCreateRequestQueryCreatedAtAny struct {
	Gt  *time.Time `json:"gt,omitempty"`
	Gte *time.Time `json:"gte,omitempty"`
	Le  *time.Time `json:"le,omitempty"`
	Lte *time.Time `json:"lte,omitempty"`
	Any *bool      `json:"any,omitempty"`
}

// Filter by destination IDs
type EventBulkRetryCreateRequestQueryDestinationId struct {
	typeName string
	// Destination ID <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewEventBulkRetryCreateRequestQueryDestinationIdFromString(value string) *EventBulkRetryCreateRequestQueryDestinationId {
	return &EventBulkRetryCreateRequestQueryDestinationId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryDestinationIdFromStringList(value []string) *EventBulkRetryCreateRequestQueryDestinationId {
	return &EventBulkRetryCreateRequestQueryDestinationId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQueryDestinationId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryDestinationId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryDestinationIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQueryDestinationId) Accept(visitor EventBulkRetryCreateRequestQueryDestinationIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

// Filter by error code code
type EventBulkRetryCreateRequestQueryErrorCode struct {
	typeName              string
	AttemptErrorCodes     AttemptErrorCodes
	AttemptErrorCodesList []AttemptErrorCodes
}

func NewEventBulkRetryCreateRequestQueryErrorCodeFromAttemptErrorCodes(value AttemptErrorCodes) *EventBulkRetryCreateRequestQueryErrorCode {
	return &EventBulkRetryCreateRequestQueryErrorCode{typeName: "attemptErrorCodes", AttemptErrorCodes: value}
}

func NewEventBulkRetryCreateRequestQueryErrorCodeFromAttemptErrorCodesList(value []AttemptErrorCodes) *EventBulkRetryCreateRequestQueryErrorCode {
	return &EventBulkRetryCreateRequestQueryErrorCode{typeName: "attemptErrorCodesList", AttemptErrorCodesList: value}
}

func (e *EventBulkRetryCreateRequestQueryErrorCode) UnmarshalJSON(data []byte) error {
	var valueAttemptErrorCodes AttemptErrorCodes
	if err := json.Unmarshal(data, &valueAttemptErrorCodes); err == nil {
		e.typeName = "attemptErrorCodes"
		e.AttemptErrorCodes = valueAttemptErrorCodes
		return nil
	}
	var valueAttemptErrorCodesList []AttemptErrorCodes
	if err := json.Unmarshal(data, &valueAttemptErrorCodesList); err == nil {
		e.typeName = "attemptErrorCodesList"
		e.AttemptErrorCodesList = valueAttemptErrorCodesList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryErrorCode) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "attemptErrorCodes":
		return json.Marshal(e.AttemptErrorCodes)
	case "attemptErrorCodesList":
		return json.Marshal(e.AttemptErrorCodesList)
	}
}

type EventBulkRetryCreateRequestQueryErrorCodeVisitor interface {
	VisitAttemptErrorCodes(AttemptErrorCodes) error
	VisitAttemptErrorCodesList([]AttemptErrorCodes) error
}

func (e *EventBulkRetryCreateRequestQueryErrorCode) Accept(visitor EventBulkRetryCreateRequestQueryErrorCodeVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "attemptErrorCodes":
		return visitor.VisitAttemptErrorCodes(e.AttemptErrorCodes)
	case "attemptErrorCodesList":
		return visitor.VisitAttemptErrorCodesList(e.AttemptErrorCodesList)
	}
}

type EventBulkRetryCreateRequestQueryEventDataId struct {
	typeName string
	// <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewEventBulkRetryCreateRequestQueryEventDataIdFromString(value string) *EventBulkRetryCreateRequestQueryEventDataId {
	return &EventBulkRetryCreateRequestQueryEventDataId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryEventDataIdFromStringList(value []string) *EventBulkRetryCreateRequestQueryEventDataId {
	return &EventBulkRetryCreateRequestQueryEventDataId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQueryEventDataId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryEventDataId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryEventDataIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQueryEventDataId) Accept(visitor EventBulkRetryCreateRequestQueryEventDataIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

// URL Encoded string of the JSON to match to the data headers
type EventBulkRetryCreateRequestQueryHeaders struct {
	typeName                                   string
	String                                     string
	EventBulkRetryCreateRequestQueryHeadersOne *EventBulkRetryCreateRequestQueryHeadersOne
}

func NewEventBulkRetryCreateRequestQueryHeadersFromString(value string) *EventBulkRetryCreateRequestQueryHeaders {
	return &EventBulkRetryCreateRequestQueryHeaders{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryHeadersFromEventBulkRetryCreateRequestQueryHeadersOne(value *EventBulkRetryCreateRequestQueryHeadersOne) *EventBulkRetryCreateRequestQueryHeaders {
	return &EventBulkRetryCreateRequestQueryHeaders{typeName: "eventBulkRetryCreateRequestQueryHeadersOne", EventBulkRetryCreateRequestQueryHeadersOne: value}
}

func (e *EventBulkRetryCreateRequestQueryHeaders) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEventBulkRetryCreateRequestQueryHeadersOne := new(EventBulkRetryCreateRequestQueryHeadersOne)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQueryHeadersOne); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQueryHeadersOne"
		e.EventBulkRetryCreateRequestQueryHeadersOne = valueEventBulkRetryCreateRequestQueryHeadersOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryHeaders) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "eventBulkRetryCreateRequestQueryHeadersOne":
		return json.Marshal(e.EventBulkRetryCreateRequestQueryHeadersOne)
	}
}

type EventBulkRetryCreateRequestQueryHeadersVisitor interface {
	VisitString(string) error
	VisitEventBulkRetryCreateRequestQueryHeadersOne(*EventBulkRetryCreateRequestQueryHeadersOne) error
}

func (e *EventBulkRetryCreateRequestQueryHeaders) Accept(visitor EventBulkRetryCreateRequestQueryHeadersVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "eventBulkRetryCreateRequestQueryHeadersOne":
		return visitor.VisitEventBulkRetryCreateRequestQueryHeadersOne(e.EventBulkRetryCreateRequestQueryHeadersOne)
	}
}

type EventBulkRetryCreateRequestQueryHeadersOne struct {
}

// Filter by event IDs
type EventBulkRetryCreateRequestQueryId struct {
	typeName string
	// Event ID <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewEventBulkRetryCreateRequestQueryIdFromString(value string) *EventBulkRetryCreateRequestQueryId {
	return &EventBulkRetryCreateRequestQueryId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryIdFromStringList(value []string) *EventBulkRetryCreateRequestQueryId {
	return &EventBulkRetryCreateRequestQueryId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQueryId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQueryId) Accept(visitor EventBulkRetryCreateRequestQueryIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryIssueId struct {
	typeName string
	// <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewEventBulkRetryCreateRequestQueryIssueIdFromString(value string) *EventBulkRetryCreateRequestQueryIssueId {
	return &EventBulkRetryCreateRequestQueryIssueId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryIssueIdFromStringList(value []string) *EventBulkRetryCreateRequestQueryIssueId {
	return &EventBulkRetryCreateRequestQueryIssueId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQueryIssueId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryIssueId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryIssueIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQueryIssueId) Accept(visitor EventBulkRetryCreateRequestQueryIssueIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

// Filter by `last_attempt_at` date using a date operator
type EventBulkRetryCreateRequestQueryLastAttemptAt struct {
	typeName                                         string
	DateTime                                         time.Time
	EventBulkRetryCreateRequestQueryLastAttemptAtAny *EventBulkRetryCreateRequestQueryLastAttemptAtAny
}

func NewEventBulkRetryCreateRequestQueryLastAttemptAtFromDateTime(value time.Time) *EventBulkRetryCreateRequestQueryLastAttemptAt {
	return &EventBulkRetryCreateRequestQueryLastAttemptAt{typeName: "dateTime", DateTime: value}
}

func NewEventBulkRetryCreateRequestQueryLastAttemptAtFromEventBulkRetryCreateRequestQueryLastAttemptAtAny(value *EventBulkRetryCreateRequestQueryLastAttemptAtAny) *EventBulkRetryCreateRequestQueryLastAttemptAt {
	return &EventBulkRetryCreateRequestQueryLastAttemptAt{typeName: "eventBulkRetryCreateRequestQueryLastAttemptAtAny", EventBulkRetryCreateRequestQueryLastAttemptAtAny: value}
}

func (e *EventBulkRetryCreateRequestQueryLastAttemptAt) UnmarshalJSON(data []byte) error {
	var valueDateTime time.Time
	if err := json.Unmarshal(data, &valueDateTime); err == nil {
		e.typeName = "dateTime"
		e.DateTime = valueDateTime
		return nil
	}
	valueEventBulkRetryCreateRequestQueryLastAttemptAtAny := new(EventBulkRetryCreateRequestQueryLastAttemptAtAny)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQueryLastAttemptAtAny); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQueryLastAttemptAtAny"
		e.EventBulkRetryCreateRequestQueryLastAttemptAtAny = valueEventBulkRetryCreateRequestQueryLastAttemptAtAny
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryLastAttemptAt) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "dateTime":
		return json.Marshal(e.DateTime)
	case "eventBulkRetryCreateRequestQueryLastAttemptAtAny":
		return json.Marshal(e.EventBulkRetryCreateRequestQueryLastAttemptAtAny)
	}
}

type EventBulkRetryCreateRequestQueryLastAttemptAtVisitor interface {
	VisitDateTime(time.Time) error
	VisitEventBulkRetryCreateRequestQueryLastAttemptAtAny(*EventBulkRetryCreateRequestQueryLastAttemptAtAny) error
}

func (e *EventBulkRetryCreateRequestQueryLastAttemptAt) Accept(visitor EventBulkRetryCreateRequestQueryLastAttemptAtVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "dateTime":
		return visitor.VisitDateTime(e.DateTime)
	case "eventBulkRetryCreateRequestQueryLastAttemptAtAny":
		return visitor.VisitEventBulkRetryCreateRequestQueryLastAttemptAtAny(e.EventBulkRetryCreateRequestQueryLastAttemptAtAny)
	}
}

type EventBulkRetryCreateRequestQueryLastAttemptAtAny struct {
	Gt  *time.Time `json:"gt,omitempty"`
	Gte *time.Time `json:"gte,omitempty"`
	Le  *time.Time `json:"le,omitempty"`
	Lte *time.Time `json:"lte,omitempty"`
	Any *bool      `json:"any,omitempty"`
}

// URL Encoded string of the JSON to match to the parsed query (JSON representation of the query)
type EventBulkRetryCreateRequestQueryParsedQuery struct {
	typeName                                       string
	String                                         string
	EventBulkRetryCreateRequestQueryParsedQueryOne *EventBulkRetryCreateRequestQueryParsedQueryOne
}

func NewEventBulkRetryCreateRequestQueryParsedQueryFromString(value string) *EventBulkRetryCreateRequestQueryParsedQuery {
	return &EventBulkRetryCreateRequestQueryParsedQuery{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryParsedQueryFromEventBulkRetryCreateRequestQueryParsedQueryOne(value *EventBulkRetryCreateRequestQueryParsedQueryOne) *EventBulkRetryCreateRequestQueryParsedQuery {
	return &EventBulkRetryCreateRequestQueryParsedQuery{typeName: "eventBulkRetryCreateRequestQueryParsedQueryOne", EventBulkRetryCreateRequestQueryParsedQueryOne: value}
}

func (e *EventBulkRetryCreateRequestQueryParsedQuery) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEventBulkRetryCreateRequestQueryParsedQueryOne := new(EventBulkRetryCreateRequestQueryParsedQueryOne)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQueryParsedQueryOne); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQueryParsedQueryOne"
		e.EventBulkRetryCreateRequestQueryParsedQueryOne = valueEventBulkRetryCreateRequestQueryParsedQueryOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryParsedQuery) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "eventBulkRetryCreateRequestQueryParsedQueryOne":
		return json.Marshal(e.EventBulkRetryCreateRequestQueryParsedQueryOne)
	}
}

type EventBulkRetryCreateRequestQueryParsedQueryVisitor interface {
	VisitString(string) error
	VisitEventBulkRetryCreateRequestQueryParsedQueryOne(*EventBulkRetryCreateRequestQueryParsedQueryOne) error
}

func (e *EventBulkRetryCreateRequestQueryParsedQuery) Accept(visitor EventBulkRetryCreateRequestQueryParsedQueryVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "eventBulkRetryCreateRequestQueryParsedQueryOne":
		return visitor.VisitEventBulkRetryCreateRequestQueryParsedQueryOne(e.EventBulkRetryCreateRequestQueryParsedQueryOne)
	}
}

type EventBulkRetryCreateRequestQueryParsedQueryOne struct {
}

// Filter by HTTP response status code
type EventBulkRetryCreateRequestQueryResponseStatus struct {
	typeName                                          string
	Integer                                           int
	EventBulkRetryCreateRequestQueryResponseStatusAny *EventBulkRetryCreateRequestQueryResponseStatusAny
	IntegerList                                       []int
}

func NewEventBulkRetryCreateRequestQueryResponseStatusFromInteger(value int) *EventBulkRetryCreateRequestQueryResponseStatus {
	return &EventBulkRetryCreateRequestQueryResponseStatus{typeName: "integer", Integer: value}
}

func NewEventBulkRetryCreateRequestQueryResponseStatusFromEventBulkRetryCreateRequestQueryResponseStatusAny(value *EventBulkRetryCreateRequestQueryResponseStatusAny) *EventBulkRetryCreateRequestQueryResponseStatus {
	return &EventBulkRetryCreateRequestQueryResponseStatus{typeName: "eventBulkRetryCreateRequestQueryResponseStatusAny", EventBulkRetryCreateRequestQueryResponseStatusAny: value}
}

func NewEventBulkRetryCreateRequestQueryResponseStatusFromIntegerList(value []int) *EventBulkRetryCreateRequestQueryResponseStatus {
	return &EventBulkRetryCreateRequestQueryResponseStatus{typeName: "integerList", IntegerList: value}
}

func (e *EventBulkRetryCreateRequestQueryResponseStatus) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		e.typeName = "integer"
		e.Integer = valueInteger
		return nil
	}
	valueEventBulkRetryCreateRequestQueryResponseStatusAny := new(EventBulkRetryCreateRequestQueryResponseStatusAny)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQueryResponseStatusAny); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQueryResponseStatusAny"
		e.EventBulkRetryCreateRequestQueryResponseStatusAny = valueEventBulkRetryCreateRequestQueryResponseStatusAny
		return nil
	}
	var valueIntegerList []int
	if err := json.Unmarshal(data, &valueIntegerList); err == nil {
		e.typeName = "integerList"
		e.IntegerList = valueIntegerList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryResponseStatus) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "integer":
		return json.Marshal(e.Integer)
	case "eventBulkRetryCreateRequestQueryResponseStatusAny":
		return json.Marshal(e.EventBulkRetryCreateRequestQueryResponseStatusAny)
	case "integerList":
		return json.Marshal(e.IntegerList)
	}
}

type EventBulkRetryCreateRequestQueryResponseStatusVisitor interface {
	VisitInteger(int) error
	VisitEventBulkRetryCreateRequestQueryResponseStatusAny(*EventBulkRetryCreateRequestQueryResponseStatusAny) error
	VisitIntegerList([]int) error
}

func (e *EventBulkRetryCreateRequestQueryResponseStatus) Accept(visitor EventBulkRetryCreateRequestQueryResponseStatusVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "integer":
		return visitor.VisitInteger(e.Integer)
	case "eventBulkRetryCreateRequestQueryResponseStatusAny":
		return visitor.VisitEventBulkRetryCreateRequestQueryResponseStatusAny(e.EventBulkRetryCreateRequestQueryResponseStatusAny)
	case "integerList":
		return visitor.VisitIntegerList(e.IntegerList)
	}
}

type EventBulkRetryCreateRequestQueryResponseStatusAny struct {
	Gt       *int  `json:"gt,omitempty"`
	Gte      *int  `json:"gte,omitempty"`
	Le       *int  `json:"le,omitempty"`
	Lte      *int  `json:"lte,omitempty"`
	Any      *bool `json:"any,omitempty"`
	Contains *int  `json:"contains,omitempty"`
}

// Filter by source IDs
type EventBulkRetryCreateRequestQuerySourceId struct {
	typeName string
	// Source ID <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewEventBulkRetryCreateRequestQuerySourceIdFromString(value string) *EventBulkRetryCreateRequestQuerySourceId {
	return &EventBulkRetryCreateRequestQuerySourceId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQuerySourceIdFromStringList(value []string) *EventBulkRetryCreateRequestQuerySourceId {
	return &EventBulkRetryCreateRequestQuerySourceId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQuerySourceId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQuerySourceId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQuerySourceIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQuerySourceId) Accept(visitor EventBulkRetryCreateRequestQuerySourceIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

// Lifecyle status of the event
type EventBulkRetryCreateRequestQueryStatus struct {
	typeName        string
	EventStatus     EventStatus
	EventStatusList []EventStatus
}

func NewEventBulkRetryCreateRequestQueryStatusFromEventStatus(value EventStatus) *EventBulkRetryCreateRequestQueryStatus {
	return &EventBulkRetryCreateRequestQueryStatus{typeName: "eventStatus", EventStatus: value}
}

func NewEventBulkRetryCreateRequestQueryStatusFromEventStatusList(value []EventStatus) *EventBulkRetryCreateRequestQueryStatus {
	return &EventBulkRetryCreateRequestQueryStatus{typeName: "eventStatusList", EventStatusList: value}
}

func (e *EventBulkRetryCreateRequestQueryStatus) UnmarshalJSON(data []byte) error {
	var valueEventStatus EventStatus
	if err := json.Unmarshal(data, &valueEventStatus); err == nil {
		e.typeName = "eventStatus"
		e.EventStatus = valueEventStatus
		return nil
	}
	var valueEventStatusList []EventStatus
	if err := json.Unmarshal(data, &valueEventStatusList); err == nil {
		e.typeName = "eventStatusList"
		e.EventStatusList = valueEventStatusList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryStatus) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "eventStatus":
		return json.Marshal(e.EventStatus)
	case "eventStatusList":
		return json.Marshal(e.EventStatusList)
	}
}

type EventBulkRetryCreateRequestQueryStatusVisitor interface {
	VisitEventStatus(EventStatus) error
	VisitEventStatusList([]EventStatus) error
}

func (e *EventBulkRetryCreateRequestQueryStatus) Accept(visitor EventBulkRetryCreateRequestQueryStatusVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "eventStatus":
		return visitor.VisitEventStatus(e.EventStatus)
	case "eventStatusList":
		return visitor.VisitEventStatusList(e.EventStatusList)
	}
}

// Filter by `successful_at` date using a date operator
type EventBulkRetryCreateRequestQuerySuccessfulAt struct {
	typeName                                        string
	DateTime                                        time.Time
	EventBulkRetryCreateRequestQuerySuccessfulAtAny *EventBulkRetryCreateRequestQuerySuccessfulAtAny
}

func NewEventBulkRetryCreateRequestQuerySuccessfulAtFromDateTime(value time.Time) *EventBulkRetryCreateRequestQuerySuccessfulAt {
	return &EventBulkRetryCreateRequestQuerySuccessfulAt{typeName: "dateTime", DateTime: value}
}

func NewEventBulkRetryCreateRequestQuerySuccessfulAtFromEventBulkRetryCreateRequestQuerySuccessfulAtAny(value *EventBulkRetryCreateRequestQuerySuccessfulAtAny) *EventBulkRetryCreateRequestQuerySuccessfulAt {
	return &EventBulkRetryCreateRequestQuerySuccessfulAt{typeName: "eventBulkRetryCreateRequestQuerySuccessfulAtAny", EventBulkRetryCreateRequestQuerySuccessfulAtAny: value}
}

func (e *EventBulkRetryCreateRequestQuerySuccessfulAt) UnmarshalJSON(data []byte) error {
	var valueDateTime time.Time
	if err := json.Unmarshal(data, &valueDateTime); err == nil {
		e.typeName = "dateTime"
		e.DateTime = valueDateTime
		return nil
	}
	valueEventBulkRetryCreateRequestQuerySuccessfulAtAny := new(EventBulkRetryCreateRequestQuerySuccessfulAtAny)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQuerySuccessfulAtAny); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQuerySuccessfulAtAny"
		e.EventBulkRetryCreateRequestQuerySuccessfulAtAny = valueEventBulkRetryCreateRequestQuerySuccessfulAtAny
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQuerySuccessfulAt) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "dateTime":
		return json.Marshal(e.DateTime)
	case "eventBulkRetryCreateRequestQuerySuccessfulAtAny":
		return json.Marshal(e.EventBulkRetryCreateRequestQuerySuccessfulAtAny)
	}
}

type EventBulkRetryCreateRequestQuerySuccessfulAtVisitor interface {
	VisitDateTime(time.Time) error
	VisitEventBulkRetryCreateRequestQuerySuccessfulAtAny(*EventBulkRetryCreateRequestQuerySuccessfulAtAny) error
}

func (e *EventBulkRetryCreateRequestQuerySuccessfulAt) Accept(visitor EventBulkRetryCreateRequestQuerySuccessfulAtVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "dateTime":
		return visitor.VisitDateTime(e.DateTime)
	case "eventBulkRetryCreateRequestQuerySuccessfulAtAny":
		return visitor.VisitEventBulkRetryCreateRequestQuerySuccessfulAtAny(e.EventBulkRetryCreateRequestQuerySuccessfulAtAny)
	}
}

type EventBulkRetryCreateRequestQuerySuccessfulAtAny struct {
	Gt  *time.Time `json:"gt,omitempty"`
	Gte *time.Time `json:"gte,omitempty"`
	Le  *time.Time `json:"le,omitempty"`
	Lte *time.Time `json:"lte,omitempty"`
	Any *bool      `json:"any,omitempty"`
}

// Filter by webhook connection IDs
type EventBulkRetryCreateRequestQueryWebhookId struct {
	typeName string
	// Webhook ID <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewEventBulkRetryCreateRequestQueryWebhookIdFromString(value string) *EventBulkRetryCreateRequestQueryWebhookId {
	return &EventBulkRetryCreateRequestQueryWebhookId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryWebhookIdFromStringList(value []string) *EventBulkRetryCreateRequestQueryWebhookId {
	return &EventBulkRetryCreateRequestQueryWebhookId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQueryWebhookId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryWebhookId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryWebhookIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQueryWebhookId) Accept(visitor EventBulkRetryCreateRequestQueryWebhookIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

type EventBulkRetryListRequestDir string

const (
	EventBulkRetryListRequestDirAsc  EventBulkRetryListRequestDir = "asc"
	EventBulkRetryListRequestDirDesc EventBulkRetryListRequestDir = "desc"
)

func NewEventBulkRetryListRequestDirFromString(s string) (EventBulkRetryListRequestDir, error) {
	switch s {
	case "asc":
		return EventBulkRetryListRequestDirAsc, nil
	case "desc":
		return EventBulkRetryListRequestDirDesc, nil
	}
	var t EventBulkRetryListRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventBulkRetryListRequestDir) Ptr() *EventBulkRetryListRequestDir {
	return &e
}

type EventBulkRetryPlanResponse struct {
	// Number of batches required to complete the bulk retry
	EstimatedBatch *int `json:"estimated_batch,omitempty"`
	// Number of estimated events to be retried
	EstimatedCount *int `json:"estimated_count,omitempty"`
	// Progression of the batch operations, values 0 - 1
	Progress *float64 `json:"progress,omitempty"`
}

// Sort direction
type EventListRequestDir string

const (
	EventListRequestDirAsc  EventListRequestDir = "asc"
	EventListRequestDirDesc EventListRequestDir = "desc"
)

func NewEventListRequestDirFromString(s string) (EventListRequestDir, error) {
	switch s {
	case "asc":
		return EventListRequestDirAsc, nil
	case "desc":
		return EventListRequestDirDesc, nil
	}
	var t EventListRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventListRequestDir) Ptr() *EventListRequestDir {
	return &e
}

// Sort key
type EventListRequestOrderBy string

const (
	EventListRequestOrderByLastAttemptAt EventListRequestOrderBy = "last_attempt_at"
	EventListRequestOrderByCreatedAt     EventListRequestOrderBy = "created_at"
)

func NewEventListRequestOrderByFromString(s string) (EventListRequestOrderBy, error) {
	switch s {
	case "last_attempt_at":
		return EventListRequestOrderByLastAttemptAt, nil
	case "created_at":
		return EventListRequestOrderByCreatedAt, nil
	}
	var t EventListRequestOrderBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventListRequestOrderBy) Ptr() *EventListRequestOrderBy {
	return &e
}

type EventPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Event        `json:"models,omitempty"`
}

type EventStatus string

const (
	EventStatusScheduled  EventStatus = "SCHEDULED"
	EventStatusQueued     EventStatus = "QUEUED"
	EventStatusHold       EventStatus = "HOLD"
	EventStatusSuccessful EventStatus = "SUCCESSFUL"
	EventStatusFailed     EventStatus = "FAILED"
)

func NewEventStatusFromString(s string) (EventStatus, error) {
	switch s {
	case "SCHEDULED":
		return EventStatusScheduled, nil
	case "QUEUED":
		return EventStatusQueued, nil
	case "HOLD":
		return EventStatusHold, nil
	case "SUCCESSFUL":
		return EventStatusSuccessful, nil
	case "FAILED":
		return EventStatusFailed, nil
	}
	var t EventStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventStatus) Ptr() *EventStatus {
	return &e
}

type FilterRule struct {
	Headers *FilterRuleProperty `json:"headers,omitempty"`
	Body    *FilterRuleProperty `json:"body,omitempty"`
	Query   *FilterRuleProperty `json:"query,omitempty"`
	Path    *FilterRuleProperty `json:"path,omitempty"`
	type_   string
}

func (f *FilterRule) Type() string {
	return f.type_
}

func (f *FilterRule) UnmarshalJSON(data []byte) error {
	type unmarshaler FilterRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FilterRule(value)
	f.type_ = "filter"
	return nil
}

func (f *FilterRule) MarshalJSON() ([]byte, error) {
	type embed FilterRule
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*f),
		Type:  "filter",
	}
	return json.Marshal(marshaler)
}

// JSON using our filter syntax to filter on request headers
type FilterRuleProperty struct {
	typeName                 string
	StringOptional           *string
	DoubleOptional           *float64
	BooleanOptional          *bool
	StringUnknownMapOptional map[string]interface{}
}

func NewFilterRulePropertyFromStringOptional(value *string) *FilterRuleProperty {
	return &FilterRuleProperty{typeName: "stringOptional", StringOptional: value}
}

func NewFilterRulePropertyFromDoubleOptional(value *float64) *FilterRuleProperty {
	return &FilterRuleProperty{typeName: "doubleOptional", DoubleOptional: value}
}

func NewFilterRulePropertyFromBooleanOptional(value *bool) *FilterRuleProperty {
	return &FilterRuleProperty{typeName: "booleanOptional", BooleanOptional: value}
}

func NewFilterRulePropertyFromStringUnknownMapOptional(value map[string]interface{}) *FilterRuleProperty {
	return &FilterRuleProperty{typeName: "stringUnknownMapOptional", StringUnknownMapOptional: value}
}

func (f *FilterRuleProperty) UnmarshalJSON(data []byte) error {
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		f.typeName = "stringOptional"
		f.StringOptional = valueStringOptional
		return nil
	}
	var valueDoubleOptional *float64
	if err := json.Unmarshal(data, &valueDoubleOptional); err == nil {
		f.typeName = "doubleOptional"
		f.DoubleOptional = valueDoubleOptional
		return nil
	}
	var valueBooleanOptional *bool
	if err := json.Unmarshal(data, &valueBooleanOptional); err == nil {
		f.typeName = "booleanOptional"
		f.BooleanOptional = valueBooleanOptional
		return nil
	}
	var valueStringUnknownMapOptional map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMapOptional); err == nil {
		f.typeName = "stringUnknownMapOptional"
		f.StringUnknownMapOptional = valueStringUnknownMapOptional
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FilterRuleProperty) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "stringOptional":
		return json.Marshal(f.StringOptional)
	case "doubleOptional":
		return json.Marshal(f.DoubleOptional)
	case "booleanOptional":
		return json.Marshal(f.BooleanOptional)
	case "stringUnknownMapOptional":
		return json.Marshal(f.StringUnknownMapOptional)
	}
}

type FilterRulePropertyVisitor interface {
	VisitStringOptional(*string) error
	VisitDoubleOptional(*float64) error
	VisitBooleanOptional(*bool) error
	VisitStringUnknownMapOptional(map[string]interface{}) error
}

func (f *FilterRuleProperty) Accept(visitor FilterRulePropertyVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "stringOptional":
		return visitor.VisitStringOptional(f.StringOptional)
	case "doubleOptional":
		return visitor.VisitDoubleOptional(f.DoubleOptional)
	case "booleanOptional":
		return visitor.VisitBooleanOptional(f.BooleanOptional)
	case "stringUnknownMapOptional":
		return visitor.VisitStringUnknownMapOptional(f.StringUnknownMapOptional)
	}
}

type FilteredMeta string

const (
	FilteredMetaBody    FilteredMeta = "body"
	FilteredMetaHeaders FilteredMeta = "headers"
	FilteredMetaPath    FilteredMeta = "path"
	FilteredMetaQuery   FilteredMeta = "query"
)

func NewFilteredMetaFromString(s string) (FilteredMeta, error) {
	switch s {
	case "body":
		return FilteredMetaBody, nil
	case "headers":
		return FilteredMetaHeaders, nil
	case "path":
		return FilteredMetaPath, nil
	case "query":
		return FilteredMetaQuery, nil
	}
	var t FilteredMeta
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FilteredMeta) Ptr() *FilteredMeta {
	return &f
}

type HandledApiKeyIntegrationConfigs struct {
	ApiKey string `json:"api_key"`
}

type HandledHmacConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type HmacAlgorithms string

const (
	HmacAlgorithmsMd5    HmacAlgorithms = "md5"
	HmacAlgorithmsSha1   HmacAlgorithms = "sha1"
	HmacAlgorithmsSha256 HmacAlgorithms = "sha256"
	HmacAlgorithmsSha512 HmacAlgorithms = "sha512"
)

func NewHmacAlgorithmsFromString(s string) (HmacAlgorithms, error) {
	switch s {
	case "md5":
		return HmacAlgorithmsMd5, nil
	case "sha1":
		return HmacAlgorithmsSha1, nil
	case "sha256":
		return HmacAlgorithmsSha256, nil
	case "sha512":
		return HmacAlgorithmsSha512, nil
	}
	var t HmacAlgorithms
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HmacAlgorithms) Ptr() *HmacAlgorithms {
	return &h
}

type HmacIntegrationConfigs struct {
	WebhookSecretKey string                         `json:"webhook_secret_key"`
	Algorithm        HmacAlgorithms                 `json:"algorithm,omitempty"`
	HeaderKey        string                         `json:"header_key"`
	Encoding         HmacIntegrationConfigsEncoding `json:"encoding,omitempty"`
}

type HmacIntegrationConfigsEncoding string

const (
	HmacIntegrationConfigsEncodingBase64 HmacIntegrationConfigsEncoding = "base64"
	HmacIntegrationConfigsEncodingHex    HmacIntegrationConfigsEncoding = "hex"
)

func NewHmacIntegrationConfigsEncodingFromString(s string) (HmacIntegrationConfigsEncoding, error) {
	switch s {
	case "base64":
		return HmacIntegrationConfigsEncodingBase64, nil
	case "hex":
		return HmacIntegrationConfigsEncodingHex, nil
	}
	var t HmacIntegrationConfigsEncoding
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HmacIntegrationConfigsEncoding) Ptr() *HmacIntegrationConfigsEncoding {
	return &h
}

type IgnoredEvent struct {
	Id        string            `json:"id"`
	TeamId    string            `json:"team_id"`
	WebhookId string            `json:"webhook_id"`
	Cause     IgnoredEventCause `json:"cause,omitempty"`
	RequestId string            `json:"request_id"`
	Meta      *IgnoredEventMeta `json:"meta,omitempty"`
	UpdatedAt time.Time         `json:"updated_at"`
	CreatedAt time.Time         `json:"created_at"`
}

// Filter by the bulk retry ignored event query object
type IgnoredEventBulkRetryCreateRequestQuery struct {
	// The cause of the ignored event
	Cause *IgnoredEventBulkRetryCreateRequestQueryCause `json:"cause,omitempty"`
	// Connection ID of the ignored event
	WebhookId *IgnoredEventBulkRetryCreateRequestQueryWebhookId `json:"webhook_id,omitempty"`
	// The associated transformation ID (only applicable to the cause `TRANSFORMATION_FAILED`) <span style="white-space: nowrap">`<= 255 characters`</span>
	TransformationId *string `json:"transformation_id,omitempty"`
}

// The cause of the ignored event
type IgnoredEventBulkRetryCreateRequestQueryCause struct {
	typeName string
	// <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewIgnoredEventBulkRetryCreateRequestQueryCauseFromString(value string) *IgnoredEventBulkRetryCreateRequestQueryCause {
	return &IgnoredEventBulkRetryCreateRequestQueryCause{typeName: "string", String: value}
}

func NewIgnoredEventBulkRetryCreateRequestQueryCauseFromStringList(value []string) *IgnoredEventBulkRetryCreateRequestQueryCause {
	return &IgnoredEventBulkRetryCreateRequestQueryCause{typeName: "stringList", StringList: value}
}

func (i *IgnoredEventBulkRetryCreateRequestQueryCause) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		i.typeName = "stringList"
		i.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IgnoredEventBulkRetryCreateRequestQueryCause) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "stringList":
		return json.Marshal(i.StringList)
	}
}

type IgnoredEventBulkRetryCreateRequestQueryCauseVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (i *IgnoredEventBulkRetryCreateRequestQueryCause) Accept(visitor IgnoredEventBulkRetryCreateRequestQueryCauseVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "stringList":
		return visitor.VisitStringList(i.StringList)
	}
}

// Connection ID of the ignored event
type IgnoredEventBulkRetryCreateRequestQueryWebhookId struct {
	typeName string
	// <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewIgnoredEventBulkRetryCreateRequestQueryWebhookIdFromString(value string) *IgnoredEventBulkRetryCreateRequestQueryWebhookId {
	return &IgnoredEventBulkRetryCreateRequestQueryWebhookId{typeName: "string", String: value}
}

func NewIgnoredEventBulkRetryCreateRequestQueryWebhookIdFromStringList(value []string) *IgnoredEventBulkRetryCreateRequestQueryWebhookId {
	return &IgnoredEventBulkRetryCreateRequestQueryWebhookId{typeName: "stringList", StringList: value}
}

func (i *IgnoredEventBulkRetryCreateRequestQueryWebhookId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		i.typeName = "stringList"
		i.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IgnoredEventBulkRetryCreateRequestQueryWebhookId) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "stringList":
		return json.Marshal(i.StringList)
	}
}

type IgnoredEventBulkRetryCreateRequestQueryWebhookIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (i *IgnoredEventBulkRetryCreateRequestQueryWebhookId) Accept(visitor IgnoredEventBulkRetryCreateRequestQueryWebhookIdVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "stringList":
		return visitor.VisitStringList(i.StringList)
	}
}

type IgnoredEventBulkRetryListRequestDir string

const (
	IgnoredEventBulkRetryListRequestDirAsc  IgnoredEventBulkRetryListRequestDir = "asc"
	IgnoredEventBulkRetryListRequestDirDesc IgnoredEventBulkRetryListRequestDir = "desc"
)

func NewIgnoredEventBulkRetryListRequestDirFromString(s string) (IgnoredEventBulkRetryListRequestDir, error) {
	switch s {
	case "asc":
		return IgnoredEventBulkRetryListRequestDirAsc, nil
	case "desc":
		return IgnoredEventBulkRetryListRequestDirDesc, nil
	}
	var t IgnoredEventBulkRetryListRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IgnoredEventBulkRetryListRequestDir) Ptr() *IgnoredEventBulkRetryListRequestDir {
	return &i
}

type IgnoredEventBulkRetryPlanResponse struct {
	// Number of batches required to complete the bulk retry
	EstimatedBatch *int `json:"estimated_batch,omitempty"`
	// Number of estimated events to be retried
	EstimatedCount *int `json:"estimated_count,omitempty"`
	// Progression of the batch operations, values 0 - 1
	Progress *float64 `json:"progress,omitempty"`
}

type IgnoredEventCause string

const (
	IgnoredEventCauseArchived             IgnoredEventCause = "ARCHIVED"
	IgnoredEventCauseFiltered             IgnoredEventCause = "FILTERED"
	IgnoredEventCauseTransformationFailed IgnoredEventCause = "TRANSFORMATION_FAILED"
	IgnoredEventCauseCliDisconnected      IgnoredEventCause = "CLI_DISCONNECTED"
)

func NewIgnoredEventCauseFromString(s string) (IgnoredEventCause, error) {
	switch s {
	case "ARCHIVED":
		return IgnoredEventCauseArchived, nil
	case "FILTERED":
		return IgnoredEventCauseFiltered, nil
	case "TRANSFORMATION_FAILED":
		return IgnoredEventCauseTransformationFailed, nil
	case "CLI_DISCONNECTED":
		return IgnoredEventCauseCliDisconnected, nil
	}
	var t IgnoredEventCause
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IgnoredEventCause) Ptr() *IgnoredEventCause {
	return &i
}

type IgnoredEventMeta struct {
	typeName                 string
	FilteredMeta             FilteredMeta
	TransformationFailedMeta *TransformationFailedMeta
}

func NewIgnoredEventMetaFromFilteredMeta(value FilteredMeta) *IgnoredEventMeta {
	return &IgnoredEventMeta{typeName: "filteredMeta", FilteredMeta: value}
}

func NewIgnoredEventMetaFromTransformationFailedMeta(value *TransformationFailedMeta) *IgnoredEventMeta {
	return &IgnoredEventMeta{typeName: "transformationFailedMeta", TransformationFailedMeta: value}
}

func (i *IgnoredEventMeta) UnmarshalJSON(data []byte) error {
	var valueFilteredMeta FilteredMeta
	if err := json.Unmarshal(data, &valueFilteredMeta); err == nil {
		i.typeName = "filteredMeta"
		i.FilteredMeta = valueFilteredMeta
		return nil
	}
	valueTransformationFailedMeta := new(TransformationFailedMeta)
	if err := json.Unmarshal(data, &valueTransformationFailedMeta); err == nil {
		i.typeName = "transformationFailedMeta"
		i.TransformationFailedMeta = valueTransformationFailedMeta
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IgnoredEventMeta) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "filteredMeta":
		return json.Marshal(i.FilteredMeta)
	case "transformationFailedMeta":
		return json.Marshal(i.TransformationFailedMeta)
	}
}

type IgnoredEventMetaVisitor interface {
	VisitFilteredMeta(FilteredMeta) error
	VisitTransformationFailedMeta(*TransformationFailedMeta) error
}

func (i *IgnoredEventMeta) Accept(visitor IgnoredEventMetaVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "filteredMeta":
		return visitor.VisitFilteredMeta(i.FilteredMeta)
	case "transformationFailedMeta":
		return visitor.VisitTransformationFailedMeta(i.TransformationFailedMeta)
	}
}

type IgnoredEventPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*IgnoredEvent `json:"models,omitempty"`
}

type Integration struct {
	// ID of the integration
	Id string `json:"id"`
	// ID of the workspace
	TeamId string `json:"team_id"`
	// Label of the integration
	Label    string              `json:"label"`
	Provider IntegrationProvider `json:"provider,omitempty"`
	// List of features to enable (see features list below)
	Features []IntegrationFeature `json:"features,omitempty"`
	// Decrypted Key/Value object of the associated configuration for that provider
	Configs *IntegrationConfigs `json:"configs,omitempty"`
	// List of source IDs the integration is attached to
	Sources []string `json:"sources,omitempty"`
	// Date the integration was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the integration was created
	CreatedAt time.Time `json:"created_at"`
}

// Decrypted Key/Value object of the associated configuration for that provider
type IntegrationConfigs struct {
	typeName                        string
	HmacIntegrationConfigs          *HmacIntegrationConfigs
	ApiKeyIntegrationConfigs        *ApiKeyIntegrationConfigs
	HandledApiKeyIntegrationConfigs *HandledApiKeyIntegrationConfigs
	HandledHmacConfigs              *HandledHmacConfigs
	BasicAuthIntegrationConfigs     *BasicAuthIntegrationConfigs
	ShopifyIntegrationConfigs       *ShopifyIntegrationConfigs
	IntegrationConfigsSix           *IntegrationConfigsSix
}

func NewIntegrationConfigsFromHmacIntegrationConfigs(value *HmacIntegrationConfigs) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "hmacIntegrationConfigs", HmacIntegrationConfigs: value}
}

func NewIntegrationConfigsFromApiKeyIntegrationConfigs(value *ApiKeyIntegrationConfigs) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "apiKeyIntegrationConfigs", ApiKeyIntegrationConfigs: value}
}

func NewIntegrationConfigsFromHandledApiKeyIntegrationConfigs(value *HandledApiKeyIntegrationConfigs) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "handledApiKeyIntegrationConfigs", HandledApiKeyIntegrationConfigs: value}
}

func NewIntegrationConfigsFromHandledHmacConfigs(value *HandledHmacConfigs) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "handledHmacConfigs", HandledHmacConfigs: value}
}

func NewIntegrationConfigsFromBasicAuthIntegrationConfigs(value *BasicAuthIntegrationConfigs) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "basicAuthIntegrationConfigs", BasicAuthIntegrationConfigs: value}
}

func NewIntegrationConfigsFromShopifyIntegrationConfigs(value *ShopifyIntegrationConfigs) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "shopifyIntegrationConfigs", ShopifyIntegrationConfigs: value}
}

func NewIntegrationConfigsFromIntegrationConfigsSix(value *IntegrationConfigsSix) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "integrationConfigsSix", IntegrationConfigsSix: value}
}

func (i *IntegrationConfigs) UnmarshalJSON(data []byte) error {
	valueHmacIntegrationConfigs := new(HmacIntegrationConfigs)
	if err := json.Unmarshal(data, &valueHmacIntegrationConfigs); err == nil {
		i.typeName = "hmacIntegrationConfigs"
		i.HmacIntegrationConfigs = valueHmacIntegrationConfigs
		return nil
	}
	valueApiKeyIntegrationConfigs := new(ApiKeyIntegrationConfigs)
	if err := json.Unmarshal(data, &valueApiKeyIntegrationConfigs); err == nil {
		i.typeName = "apiKeyIntegrationConfigs"
		i.ApiKeyIntegrationConfigs = valueApiKeyIntegrationConfigs
		return nil
	}
	valueHandledApiKeyIntegrationConfigs := new(HandledApiKeyIntegrationConfigs)
	if err := json.Unmarshal(data, &valueHandledApiKeyIntegrationConfigs); err == nil {
		i.typeName = "handledApiKeyIntegrationConfigs"
		i.HandledApiKeyIntegrationConfigs = valueHandledApiKeyIntegrationConfigs
		return nil
	}
	valueHandledHmacConfigs := new(HandledHmacConfigs)
	if err := json.Unmarshal(data, &valueHandledHmacConfigs); err == nil {
		i.typeName = "handledHmacConfigs"
		i.HandledHmacConfigs = valueHandledHmacConfigs
		return nil
	}
	valueBasicAuthIntegrationConfigs := new(BasicAuthIntegrationConfigs)
	if err := json.Unmarshal(data, &valueBasicAuthIntegrationConfigs); err == nil {
		i.typeName = "basicAuthIntegrationConfigs"
		i.BasicAuthIntegrationConfigs = valueBasicAuthIntegrationConfigs
		return nil
	}
	valueShopifyIntegrationConfigs := new(ShopifyIntegrationConfigs)
	if err := json.Unmarshal(data, &valueShopifyIntegrationConfigs); err == nil {
		i.typeName = "shopifyIntegrationConfigs"
		i.ShopifyIntegrationConfigs = valueShopifyIntegrationConfigs
		return nil
	}
	valueIntegrationConfigsSix := new(IntegrationConfigsSix)
	if err := json.Unmarshal(data, &valueIntegrationConfigsSix); err == nil {
		i.typeName = "integrationConfigsSix"
		i.IntegrationConfigsSix = valueIntegrationConfigsSix
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IntegrationConfigs) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "hmacIntegrationConfigs":
		return json.Marshal(i.HmacIntegrationConfigs)
	case "apiKeyIntegrationConfigs":
		return json.Marshal(i.ApiKeyIntegrationConfigs)
	case "handledApiKeyIntegrationConfigs":
		return json.Marshal(i.HandledApiKeyIntegrationConfigs)
	case "handledHmacConfigs":
		return json.Marshal(i.HandledHmacConfigs)
	case "basicAuthIntegrationConfigs":
		return json.Marshal(i.BasicAuthIntegrationConfigs)
	case "shopifyIntegrationConfigs":
		return json.Marshal(i.ShopifyIntegrationConfigs)
	case "integrationConfigsSix":
		return json.Marshal(i.IntegrationConfigsSix)
	}
}

type IntegrationConfigsVisitor interface {
	VisitHmacIntegrationConfigs(*HmacIntegrationConfigs) error
	VisitApiKeyIntegrationConfigs(*ApiKeyIntegrationConfigs) error
	VisitHandledApiKeyIntegrationConfigs(*HandledApiKeyIntegrationConfigs) error
	VisitHandledHmacConfigs(*HandledHmacConfigs) error
	VisitBasicAuthIntegrationConfigs(*BasicAuthIntegrationConfigs) error
	VisitShopifyIntegrationConfigs(*ShopifyIntegrationConfigs) error
	VisitIntegrationConfigsSix(*IntegrationConfigsSix) error
}

func (i *IntegrationConfigs) Accept(visitor IntegrationConfigsVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "hmacIntegrationConfigs":
		return visitor.VisitHmacIntegrationConfigs(i.HmacIntegrationConfigs)
	case "apiKeyIntegrationConfigs":
		return visitor.VisitApiKeyIntegrationConfigs(i.ApiKeyIntegrationConfigs)
	case "handledApiKeyIntegrationConfigs":
		return visitor.VisitHandledApiKeyIntegrationConfigs(i.HandledApiKeyIntegrationConfigs)
	case "handledHmacConfigs":
		return visitor.VisitHandledHmacConfigs(i.HandledHmacConfigs)
	case "basicAuthIntegrationConfigs":
		return visitor.VisitBasicAuthIntegrationConfigs(i.BasicAuthIntegrationConfigs)
	case "shopifyIntegrationConfigs":
		return visitor.VisitShopifyIntegrationConfigs(i.ShopifyIntegrationConfigs)
	case "integrationConfigsSix":
		return visitor.VisitIntegrationConfigsSix(i.IntegrationConfigsSix)
	}
}

type IntegrationConfigsSix struct {
}

type IntegrationFeature string

const (
	IntegrationFeatureVerification IntegrationFeature = "VERIFICATION"
	IntegrationFeatureHandshake    IntegrationFeature = "HANDSHAKE"
	IntegrationFeaturePolling      IntegrationFeature = "POLLING"
)

func NewIntegrationFeatureFromString(s string) (IntegrationFeature, error) {
	switch s {
	case "VERIFICATION":
		return IntegrationFeatureVerification, nil
	case "HANDSHAKE":
		return IntegrationFeatureHandshake, nil
	case "POLLING":
		return IntegrationFeaturePolling, nil
	}
	var t IntegrationFeature
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IntegrationFeature) Ptr() *IntegrationFeature {
	return &i
}

type IntegrationPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Integration  `json:"models,omitempty"`
}

type IntegrationProvider string

const (
	IntegrationProviderHmac           IntegrationProvider = "hmac"
	IntegrationProviderBasicAuth      IntegrationProvider = "basic_auth"
	IntegrationProviderApiKey         IntegrationProvider = "api_key"
	IntegrationProviderTwitter        IntegrationProvider = "twitter"
	IntegrationProviderStripe         IntegrationProvider = "stripe"
	IntegrationProviderRecharge       IntegrationProvider = "recharge"
	IntegrationProviderGithub         IntegrationProvider = "github"
	IntegrationProviderShopify        IntegrationProvider = "shopify"
	IntegrationProviderPostmark       IntegrationProvider = "postmark"
	IntegrationProviderTypeform       IntegrationProvider = "typeform"
	IntegrationProviderXero           IntegrationProvider = "xero"
	IntegrationProviderSvix           IntegrationProvider = "svix"
	IntegrationProviderZoom           IntegrationProvider = "zoom"
	IntegrationProviderAkeneo         IntegrationProvider = "akeneo"
	IntegrationProviderAdyen          IntegrationProvider = "adyen"
	IntegrationProviderGitlab         IntegrationProvider = "gitlab"
	IntegrationProviderPropertyFinder IntegrationProvider = "property-finder"
	IntegrationProviderWoocommerce    IntegrationProvider = "woocommerce"
	IntegrationProviderOura           IntegrationProvider = "oura"
	IntegrationProviderCommercelayer  IntegrationProvider = "commercelayer"
	IntegrationProviderMailgun        IntegrationProvider = "mailgun"
	IntegrationProviderPipedrive      IntegrationProvider = "pipedrive"
	IntegrationProviderSendgrid       IntegrationProvider = "sendgrid"
	IntegrationProviderWorkos         IntegrationProvider = "workos"
	IntegrationProviderSynctera       IntegrationProvider = "synctera"
	IntegrationProviderAwsSns         IntegrationProvider = "aws_sns"
	IntegrationProviderThreeDEye      IntegrationProvider = "three_d_eye"
)

func NewIntegrationProviderFromString(s string) (IntegrationProvider, error) {
	switch s {
	case "hmac":
		return IntegrationProviderHmac, nil
	case "basic_auth":
		return IntegrationProviderBasicAuth, nil
	case "api_key":
		return IntegrationProviderApiKey, nil
	case "twitter":
		return IntegrationProviderTwitter, nil
	case "stripe":
		return IntegrationProviderStripe, nil
	case "recharge":
		return IntegrationProviderRecharge, nil
	case "github":
		return IntegrationProviderGithub, nil
	case "shopify":
		return IntegrationProviderShopify, nil
	case "postmark":
		return IntegrationProviderPostmark, nil
	case "typeform":
		return IntegrationProviderTypeform, nil
	case "xero":
		return IntegrationProviderXero, nil
	case "svix":
		return IntegrationProviderSvix, nil
	case "zoom":
		return IntegrationProviderZoom, nil
	case "akeneo":
		return IntegrationProviderAkeneo, nil
	case "adyen":
		return IntegrationProviderAdyen, nil
	case "gitlab":
		return IntegrationProviderGitlab, nil
	case "property-finder":
		return IntegrationProviderPropertyFinder, nil
	case "woocommerce":
		return IntegrationProviderWoocommerce, nil
	case "oura":
		return IntegrationProviderOura, nil
	case "commercelayer":
		return IntegrationProviderCommercelayer, nil
	case "mailgun":
		return IntegrationProviderMailgun, nil
	case "pipedrive":
		return IntegrationProviderPipedrive, nil
	case "sendgrid":
		return IntegrationProviderSendgrid, nil
	case "workos":
		return IntegrationProviderWorkos, nil
	case "synctera":
		return IntegrationProviderSynctera, nil
	case "aws_sns":
		return IntegrationProviderAwsSns, nil
	case "three_d_eye":
		return IntegrationProviderThreeDEye, nil
	}
	var t IntegrationProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IntegrationProvider) Ptr() *IntegrationProvider {
	return &i
}

// Issue
type Issue struct {
	typeName            string
	DeliveryIssue       *DeliveryIssue
	TransformationIssue *TransformationIssue
}

func NewIssueFromDeliveryIssue(value *DeliveryIssue) *Issue {
	return &Issue{typeName: "deliveryIssue", DeliveryIssue: value}
}

func NewIssueFromTransformationIssue(value *TransformationIssue) *Issue {
	return &Issue{typeName: "transformationIssue", TransformationIssue: value}
}

func (i *Issue) UnmarshalJSON(data []byte) error {
	valueDeliveryIssue := new(DeliveryIssue)
	if err := json.Unmarshal(data, &valueDeliveryIssue); err == nil {
		i.typeName = "deliveryIssue"
		i.DeliveryIssue = valueDeliveryIssue
		return nil
	}
	valueTransformationIssue := new(TransformationIssue)
	if err := json.Unmarshal(data, &valueTransformationIssue); err == nil {
		i.typeName = "transformationIssue"
		i.TransformationIssue = valueTransformationIssue
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i Issue) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "deliveryIssue":
		return json.Marshal(i.DeliveryIssue)
	case "transformationIssue":
		return json.Marshal(i.TransformationIssue)
	}
}

type IssueVisitor interface {
	VisitDeliveryIssue(*DeliveryIssue) error
	VisitTransformationIssue(*TransformationIssue) error
}

func (i *Issue) Accept(visitor IssueVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "deliveryIssue":
		return visitor.VisitDeliveryIssue(i.DeliveryIssue)
	case "transformationIssue":
		return visitor.VisitTransformationIssue(i.TransformationIssue)
	}
}

type IssueCount struct {
	// Number of issues
	Count int `json:"count"`
}

type IssueCountRequestDir string

const (
	IssueCountRequestDirAsc  IssueCountRequestDir = "asc"
	IssueCountRequestDirDesc IssueCountRequestDir = "desc"
)

func NewIssueCountRequestDirFromString(s string) (IssueCountRequestDir, error) {
	switch s {
	case "asc":
		return IssueCountRequestDirAsc, nil
	case "desc":
		return IssueCountRequestDirDesc, nil
	}
	var t IssueCountRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueCountRequestDir) Ptr() *IssueCountRequestDir {
	return &i
}

type IssueCountRequestOrderBy string

const (
	IssueCountRequestOrderByCreatedAt   IssueCountRequestOrderBy = "created_at"
	IssueCountRequestOrderByFirstSeenAt IssueCountRequestOrderBy = "first_seen_at"
	IssueCountRequestOrderByLastSeenAt  IssueCountRequestOrderBy = "last_seen_at"
	IssueCountRequestOrderByOpenedAt    IssueCountRequestOrderBy = "opened_at"
	IssueCountRequestOrderByStatus      IssueCountRequestOrderBy = "status"
)

func NewIssueCountRequestOrderByFromString(s string) (IssueCountRequestOrderBy, error) {
	switch s {
	case "created_at":
		return IssueCountRequestOrderByCreatedAt, nil
	case "first_seen_at":
		return IssueCountRequestOrderByFirstSeenAt, nil
	case "last_seen_at":
		return IssueCountRequestOrderByLastSeenAt, nil
	case "opened_at":
		return IssueCountRequestOrderByOpenedAt, nil
	case "status":
		return IssueCountRequestOrderByStatus, nil
	}
	var t IssueCountRequestOrderBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueCountRequestOrderBy) Ptr() *IssueCountRequestOrderBy {
	return &i
}

// Issue status
type IssueCountRequestStatus string

const (
	IssueCountRequestStatusOpened       IssueCountRequestStatus = "OPENED"
	IssueCountRequestStatusIgnored      IssueCountRequestStatus = "IGNORED"
	IssueCountRequestStatusAcknowledged IssueCountRequestStatus = "ACKNOWLEDGED"
	IssueCountRequestStatusResolved     IssueCountRequestStatus = "RESOLVED"
)

func NewIssueCountRequestStatusFromString(s string) (IssueCountRequestStatus, error) {
	switch s {
	case "OPENED":
		return IssueCountRequestStatusOpened, nil
	case "IGNORED":
		return IssueCountRequestStatusIgnored, nil
	case "ACKNOWLEDGED":
		return IssueCountRequestStatusAcknowledged, nil
	case "RESOLVED":
		return IssueCountRequestStatusResolved, nil
	}
	var t IssueCountRequestStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueCountRequestStatus) Ptr() *IssueCountRequestStatus {
	return &i
}

// Issue type
type IssueCountRequestType string

const (
	IssueCountRequestTypeDelivery       IssueCountRequestType = "delivery"
	IssueCountRequestTypeTransformation IssueCountRequestType = "transformation"
	IssueCountRequestTypeBackpressure   IssueCountRequestType = "backpressure"
)

func NewIssueCountRequestTypeFromString(s string) (IssueCountRequestType, error) {
	switch s {
	case "delivery":
		return IssueCountRequestTypeDelivery, nil
	case "transformation":
		return IssueCountRequestTypeTransformation, nil
	case "backpressure":
		return IssueCountRequestTypeBackpressure, nil
	}
	var t IssueCountRequestType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueCountRequestType) Ptr() *IssueCountRequestType {
	return &i
}

type IssueListRequestDir string

const (
	IssueListRequestDirAsc  IssueListRequestDir = "asc"
	IssueListRequestDirDesc IssueListRequestDir = "desc"
)

func NewIssueListRequestDirFromString(s string) (IssueListRequestDir, error) {
	switch s {
	case "asc":
		return IssueListRequestDirAsc, nil
	case "desc":
		return IssueListRequestDirDesc, nil
	}
	var t IssueListRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueListRequestDir) Ptr() *IssueListRequestDir {
	return &i
}

type IssueListRequestOrderBy string

const (
	IssueListRequestOrderByCreatedAt   IssueListRequestOrderBy = "created_at"
	IssueListRequestOrderByFirstSeenAt IssueListRequestOrderBy = "first_seen_at"
	IssueListRequestOrderByLastSeenAt  IssueListRequestOrderBy = "last_seen_at"
	IssueListRequestOrderByOpenedAt    IssueListRequestOrderBy = "opened_at"
	IssueListRequestOrderByStatus      IssueListRequestOrderBy = "status"
)

func NewIssueListRequestOrderByFromString(s string) (IssueListRequestOrderBy, error) {
	switch s {
	case "created_at":
		return IssueListRequestOrderByCreatedAt, nil
	case "first_seen_at":
		return IssueListRequestOrderByFirstSeenAt, nil
	case "last_seen_at":
		return IssueListRequestOrderByLastSeenAt, nil
	case "opened_at":
		return IssueListRequestOrderByOpenedAt, nil
	case "status":
		return IssueListRequestOrderByStatus, nil
	}
	var t IssueListRequestOrderBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueListRequestOrderBy) Ptr() *IssueListRequestOrderBy {
	return &i
}

// Issue status
type IssueListRequestStatus string

const (
	IssueListRequestStatusOpened       IssueListRequestStatus = "OPENED"
	IssueListRequestStatusIgnored      IssueListRequestStatus = "IGNORED"
	IssueListRequestStatusAcknowledged IssueListRequestStatus = "ACKNOWLEDGED"
	IssueListRequestStatusResolved     IssueListRequestStatus = "RESOLVED"
)

func NewIssueListRequestStatusFromString(s string) (IssueListRequestStatus, error) {
	switch s {
	case "OPENED":
		return IssueListRequestStatusOpened, nil
	case "IGNORED":
		return IssueListRequestStatusIgnored, nil
	case "ACKNOWLEDGED":
		return IssueListRequestStatusAcknowledged, nil
	case "RESOLVED":
		return IssueListRequestStatusResolved, nil
	}
	var t IssueListRequestStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueListRequestStatus) Ptr() *IssueListRequestStatus {
	return &i
}

// Issue type
type IssueListRequestType string

const (
	IssueListRequestTypeDelivery       IssueListRequestType = "delivery"
	IssueListRequestTypeTransformation IssueListRequestType = "transformation"
	IssueListRequestTypeBackpressure   IssueListRequestType = "backpressure"
)

func NewIssueListRequestTypeFromString(s string) (IssueListRequestType, error) {
	switch s {
	case "delivery":
		return IssueListRequestTypeDelivery, nil
	case "transformation":
		return IssueListRequestTypeTransformation, nil
	case "backpressure":
		return IssueListRequestTypeBackpressure, nil
	}
	var t IssueListRequestType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueListRequestType) Ptr() *IssueListRequestType {
	return &i
}

// Issue status
type IssueStatus string

const (
	IssueStatusOpened       IssueStatus = "OPENED"
	IssueStatusIgnored      IssueStatus = "IGNORED"
	IssueStatusAcknowledged IssueStatus = "ACKNOWLEDGED"
	IssueStatusResolved     IssueStatus = "RESOLVED"
)

func NewIssueStatusFromString(s string) (IssueStatus, error) {
	switch s {
	case "OPENED":
		return IssueStatusOpened, nil
	case "IGNORED":
		return IssueStatusIgnored, nil
	case "ACKNOWLEDGED":
		return IssueStatusAcknowledged, nil
	case "RESOLVED":
		return IssueStatusResolved, nil
	}
	var t IssueStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueStatus) Ptr() *IssueStatus {
	return &i
}

type IssueTrigger struct {
	// ID of the issue trigger
	Id string `json:"id"`
	// ID of the workspace
	TeamId *string `json:"team_id,omitempty"`
	// Optional unique name to use as reference when using the API
	Name     *string                `json:"name,omitempty"`
	Type     IssueType              `json:"type,omitempty"`
	Configs  *IssueTriggerReference `json:"configs,omitempty"`
	Channels *IssueTriggerChannels  `json:"channels,omitempty"`
	// ISO timestamp for when the issue trigger was disabled
	DisabledAt *time.Time `json:"disabled_at,omitempty"`
	// ISO timestamp for when the issue trigger was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// ISO timestamp for when the issue trigger was created
	CreatedAt time.Time `json:"created_at"`
	// ISO timestamp for when the issue trigger was deleted
	DeletedAt *time.Time `json:"deleted_at,omitempty"`
}

// Configurations for a 'Backpressure' issue trigger
type IssueTriggerBackpressureConfigs struct {
	Delay IssueTriggerBackpressureDelay `json:"delay"`
	// A pattern to match on the destination name or array of destination IDs. Use `*` as wildcard.
	Destinations *IssueTriggerBackpressureConfigsDestinations `json:"destinations,omitempty"`
}

// A pattern to match on the destination name or array of destination IDs. Use `*` as wildcard.
type IssueTriggerBackpressureConfigsDestinations struct {
	typeName   string
	String     string
	StringList []string
}

func NewIssueTriggerBackpressureConfigsDestinationsFromString(value string) *IssueTriggerBackpressureConfigsDestinations {
	return &IssueTriggerBackpressureConfigsDestinations{typeName: "string", String: value}
}

func NewIssueTriggerBackpressureConfigsDestinationsFromStringList(value []string) *IssueTriggerBackpressureConfigsDestinations {
	return &IssueTriggerBackpressureConfigsDestinations{typeName: "stringList", StringList: value}
}

func (i *IssueTriggerBackpressureConfigsDestinations) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		i.typeName = "stringList"
		i.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerBackpressureConfigsDestinations) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "stringList":
		return json.Marshal(i.StringList)
	}
}

type IssueTriggerBackpressureConfigsDestinationsVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (i *IssueTriggerBackpressureConfigsDestinations) Accept(visitor IssueTriggerBackpressureConfigsDestinationsVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "stringList":
		return visitor.VisitStringList(i.StringList)
	}
}

// The minimum delay (backpressure) to open the issue for min of 1 minute (60000) and max of 1 day (86400000)
type IssueTriggerBackpressureDelay = int

// Notification channels object for the specific channel type
type IssueTriggerChannels struct {
	Slack    *IssueTriggerSlackChannel       `json:"slack,omitempty"`
	Opsgenie *IssueTriggerIntegrationChannel `json:"opsgenie,omitempty"`
	Email    *IssueTriggerEmailChannel       `json:"email,omitempty"`
}

// Configuration object for the specific issue type selected
type IssueTriggerCreateRequestConfigs struct {
	typeName                          string
	IssueTriggerDeliveryConfigs       *IssueTriggerDeliveryConfigs
	IssueTriggerTransformationConfigs *IssueTriggerTransformationConfigs
	IssueTriggerBackpressureConfigs   *IssueTriggerBackpressureConfigs
}

func NewIssueTriggerCreateRequestConfigsFromIssueTriggerDeliveryConfigs(value *IssueTriggerDeliveryConfigs) *IssueTriggerCreateRequestConfigs {
	return &IssueTriggerCreateRequestConfigs{typeName: "issueTriggerDeliveryConfigs", IssueTriggerDeliveryConfigs: value}
}

func NewIssueTriggerCreateRequestConfigsFromIssueTriggerTransformationConfigs(value *IssueTriggerTransformationConfigs) *IssueTriggerCreateRequestConfigs {
	return &IssueTriggerCreateRequestConfigs{typeName: "issueTriggerTransformationConfigs", IssueTriggerTransformationConfigs: value}
}

func NewIssueTriggerCreateRequestConfigsFromIssueTriggerBackpressureConfigs(value *IssueTriggerBackpressureConfigs) *IssueTriggerCreateRequestConfigs {
	return &IssueTriggerCreateRequestConfigs{typeName: "issueTriggerBackpressureConfigs", IssueTriggerBackpressureConfigs: value}
}

func (i *IssueTriggerCreateRequestConfigs) UnmarshalJSON(data []byte) error {
	valueIssueTriggerDeliveryConfigs := new(IssueTriggerDeliveryConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerDeliveryConfigs); err == nil {
		i.typeName = "issueTriggerDeliveryConfigs"
		i.IssueTriggerDeliveryConfigs = valueIssueTriggerDeliveryConfigs
		return nil
	}
	valueIssueTriggerTransformationConfigs := new(IssueTriggerTransformationConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerTransformationConfigs); err == nil {
		i.typeName = "issueTriggerTransformationConfigs"
		i.IssueTriggerTransformationConfigs = valueIssueTriggerTransformationConfigs
		return nil
	}
	valueIssueTriggerBackpressureConfigs := new(IssueTriggerBackpressureConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerBackpressureConfigs); err == nil {
		i.typeName = "issueTriggerBackpressureConfigs"
		i.IssueTriggerBackpressureConfigs = valueIssueTriggerBackpressureConfigs
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerCreateRequestConfigs) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueTriggerDeliveryConfigs":
		return json.Marshal(i.IssueTriggerDeliveryConfigs)
	case "issueTriggerTransformationConfigs":
		return json.Marshal(i.IssueTriggerTransformationConfigs)
	case "issueTriggerBackpressureConfigs":
		return json.Marshal(i.IssueTriggerBackpressureConfigs)
	}
}

type IssueTriggerCreateRequestConfigsVisitor interface {
	VisitIssueTriggerDeliveryConfigs(*IssueTriggerDeliveryConfigs) error
	VisitIssueTriggerTransformationConfigs(*IssueTriggerTransformationConfigs) error
	VisitIssueTriggerBackpressureConfigs(*IssueTriggerBackpressureConfigs) error
}

func (i *IssueTriggerCreateRequestConfigs) Accept(visitor IssueTriggerCreateRequestConfigsVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueTriggerDeliveryConfigs":
		return visitor.VisitIssueTriggerDeliveryConfigs(i.IssueTriggerDeliveryConfigs)
	case "issueTriggerTransformationConfigs":
		return visitor.VisitIssueTriggerTransformationConfigs(i.IssueTriggerTransformationConfigs)
	case "issueTriggerBackpressureConfigs":
		return visitor.VisitIssueTriggerBackpressureConfigs(i.IssueTriggerBackpressureConfigs)
	}
}

// Configurations for a 'delivery' issue trigger
type IssueTriggerDeliveryConfigs struct {
	Strategy IssueTriggerStrategy `json:"strategy,omitempty"`
	// A pattern to match on the connection name or array of connection IDs. Use `*` as wildcard.
	Connections *IssueTriggerDeliveryConfigsConnections `json:"connections,omitempty"`
}

// A pattern to match on the connection name or array of connection IDs. Use `*` as wildcard.
type IssueTriggerDeliveryConfigsConnections struct {
	typeName   string
	String     string
	StringList []string
}

func NewIssueTriggerDeliveryConfigsConnectionsFromString(value string) *IssueTriggerDeliveryConfigsConnections {
	return &IssueTriggerDeliveryConfigsConnections{typeName: "string", String: value}
}

func NewIssueTriggerDeliveryConfigsConnectionsFromStringList(value []string) *IssueTriggerDeliveryConfigsConnections {
	return &IssueTriggerDeliveryConfigsConnections{typeName: "stringList", StringList: value}
}

func (i *IssueTriggerDeliveryConfigsConnections) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		i.typeName = "stringList"
		i.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerDeliveryConfigsConnections) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "stringList":
		return json.Marshal(i.StringList)
	}
}

type IssueTriggerDeliveryConfigsConnectionsVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (i *IssueTriggerDeliveryConfigsConnections) Accept(visitor IssueTriggerDeliveryConfigsConnectionsVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "stringList":
		return visitor.VisitStringList(i.StringList)
	}
}

// Email channel for an issue trigger
type IssueTriggerEmailChannel struct {
}

// Integration channel for an issue trigger
type IssueTriggerIntegrationChannel struct {
}

type IssueTriggerListRequestDir string

const (
	IssueTriggerListRequestDirAsc  IssueTriggerListRequestDir = "asc"
	IssueTriggerListRequestDirDesc IssueTriggerListRequestDir = "desc"
)

func NewIssueTriggerListRequestDirFromString(s string) (IssueTriggerListRequestDir, error) {
	switch s {
	case "asc":
		return IssueTriggerListRequestDirAsc, nil
	case "desc":
		return IssueTriggerListRequestDirDesc, nil
	}
	var t IssueTriggerListRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueTriggerListRequestDir) Ptr() *IssueTriggerListRequestDir {
	return &i
}

type IssueTriggerListRequestOrderBy string

const (
	IssueTriggerListRequestOrderByCreatedAt IssueTriggerListRequestOrderBy = "created_at"
	IssueTriggerListRequestOrderByType      IssueTriggerListRequestOrderBy = "type"
)

func NewIssueTriggerListRequestOrderByFromString(s string) (IssueTriggerListRequestOrderBy, error) {
	switch s {
	case "created_at":
		return IssueTriggerListRequestOrderByCreatedAt, nil
	case "type":
		return IssueTriggerListRequestOrderByType, nil
	}
	var t IssueTriggerListRequestOrderBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueTriggerListRequestOrderBy) Ptr() *IssueTriggerListRequestOrderBy {
	return &i
}

type IssueTriggerPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*IssueTrigger `json:"models,omitempty"`
}

// Configuration object for the specific issue type selected
type IssueTriggerReference struct {
	typeName                          string
	IssueTriggerDeliveryConfigs       *IssueTriggerDeliveryConfigs
	IssueTriggerTransformationConfigs *IssueTriggerTransformationConfigs
	IssueTriggerBackpressureConfigs   *IssueTriggerBackpressureConfigs
}

func NewIssueTriggerReferenceFromIssueTriggerDeliveryConfigs(value *IssueTriggerDeliveryConfigs) *IssueTriggerReference {
	return &IssueTriggerReference{typeName: "issueTriggerDeliveryConfigs", IssueTriggerDeliveryConfigs: value}
}

func NewIssueTriggerReferenceFromIssueTriggerTransformationConfigs(value *IssueTriggerTransformationConfigs) *IssueTriggerReference {
	return &IssueTriggerReference{typeName: "issueTriggerTransformationConfigs", IssueTriggerTransformationConfigs: value}
}

func NewIssueTriggerReferenceFromIssueTriggerBackpressureConfigs(value *IssueTriggerBackpressureConfigs) *IssueTriggerReference {
	return &IssueTriggerReference{typeName: "issueTriggerBackpressureConfigs", IssueTriggerBackpressureConfigs: value}
}

func (i *IssueTriggerReference) UnmarshalJSON(data []byte) error {
	valueIssueTriggerDeliveryConfigs := new(IssueTriggerDeliveryConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerDeliveryConfigs); err == nil {
		i.typeName = "issueTriggerDeliveryConfigs"
		i.IssueTriggerDeliveryConfigs = valueIssueTriggerDeliveryConfigs
		return nil
	}
	valueIssueTriggerTransformationConfigs := new(IssueTriggerTransformationConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerTransformationConfigs); err == nil {
		i.typeName = "issueTriggerTransformationConfigs"
		i.IssueTriggerTransformationConfigs = valueIssueTriggerTransformationConfigs
		return nil
	}
	valueIssueTriggerBackpressureConfigs := new(IssueTriggerBackpressureConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerBackpressureConfigs); err == nil {
		i.typeName = "issueTriggerBackpressureConfigs"
		i.IssueTriggerBackpressureConfigs = valueIssueTriggerBackpressureConfigs
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerReference) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueTriggerDeliveryConfigs":
		return json.Marshal(i.IssueTriggerDeliveryConfigs)
	case "issueTriggerTransformationConfigs":
		return json.Marshal(i.IssueTriggerTransformationConfigs)
	case "issueTriggerBackpressureConfigs":
		return json.Marshal(i.IssueTriggerBackpressureConfigs)
	}
}

type IssueTriggerReferenceVisitor interface {
	VisitIssueTriggerDeliveryConfigs(*IssueTriggerDeliveryConfigs) error
	VisitIssueTriggerTransformationConfigs(*IssueTriggerTransformationConfigs) error
	VisitIssueTriggerBackpressureConfigs(*IssueTriggerBackpressureConfigs) error
}

func (i *IssueTriggerReference) Accept(visitor IssueTriggerReferenceVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueTriggerDeliveryConfigs":
		return visitor.VisitIssueTriggerDeliveryConfigs(i.IssueTriggerDeliveryConfigs)
	case "issueTriggerTransformationConfigs":
		return visitor.VisitIssueTriggerTransformationConfigs(i.IssueTriggerTransformationConfigs)
	case "issueTriggerBackpressureConfigs":
		return visitor.VisitIssueTriggerBackpressureConfigs(i.IssueTriggerBackpressureConfigs)
	}
}

// Slack channel for an issue trigger
type IssueTriggerSlackChannel struct {
	// Channel name
	ChannelName string `json:"channel_name"`
}

// The strategy uses to open the issue
type IssueTriggerStrategy string

const (
	IssueTriggerStrategyFirstAttempt IssueTriggerStrategy = "first_attempt"
	IssueTriggerStrategyFinalAttempt IssueTriggerStrategy = "final_attempt"
)

func NewIssueTriggerStrategyFromString(s string) (IssueTriggerStrategy, error) {
	switch s {
	case "first_attempt":
		return IssueTriggerStrategyFirstAttempt, nil
	case "final_attempt":
		return IssueTriggerStrategyFinalAttempt, nil
	}
	var t IssueTriggerStrategy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueTriggerStrategy) Ptr() *IssueTriggerStrategy {
	return &i
}

// Configurations for a 'Transformation' issue trigger
type IssueTriggerTransformationConfigs struct {
	LogLevel TransformationExecutionLogLevel `json:"log_level,omitempty"`
	// A pattern to match on the transformation name or array of transformation IDs. Use `*` as wildcard.
	Transformations *IssueTriggerTransformationConfigsTransformations `json:"transformations,omitempty"`
}

// A pattern to match on the transformation name or array of transformation IDs. Use `*` as wildcard.
type IssueTriggerTransformationConfigsTransformations struct {
	typeName   string
	String     string
	StringList []string
}

func NewIssueTriggerTransformationConfigsTransformationsFromString(value string) *IssueTriggerTransformationConfigsTransformations {
	return &IssueTriggerTransformationConfigsTransformations{typeName: "string", String: value}
}

func NewIssueTriggerTransformationConfigsTransformationsFromStringList(value []string) *IssueTriggerTransformationConfigsTransformations {
	return &IssueTriggerTransformationConfigsTransformations{typeName: "stringList", StringList: value}
}

func (i *IssueTriggerTransformationConfigsTransformations) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		i.typeName = "stringList"
		i.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerTransformationConfigsTransformations) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "stringList":
		return json.Marshal(i.StringList)
	}
}

type IssueTriggerTransformationConfigsTransformationsVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (i *IssueTriggerTransformationConfigsTransformations) Accept(visitor IssueTriggerTransformationConfigsTransformationsVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "stringList":
		return visitor.VisitStringList(i.StringList)
	}
}

// Configuration object for the specific issue type selected
type IssueTriggerUpdateRequestConfigs struct {
	typeName                          string
	IssueTriggerDeliveryConfigs       *IssueTriggerDeliveryConfigs
	IssueTriggerTransformationConfigs *IssueTriggerTransformationConfigs
	IssueTriggerBackpressureConfigs   *IssueTriggerBackpressureConfigs
}

func NewIssueTriggerUpdateRequestConfigsFromIssueTriggerDeliveryConfigs(value *IssueTriggerDeliveryConfigs) *IssueTriggerUpdateRequestConfigs {
	return &IssueTriggerUpdateRequestConfigs{typeName: "issueTriggerDeliveryConfigs", IssueTriggerDeliveryConfigs: value}
}

func NewIssueTriggerUpdateRequestConfigsFromIssueTriggerTransformationConfigs(value *IssueTriggerTransformationConfigs) *IssueTriggerUpdateRequestConfigs {
	return &IssueTriggerUpdateRequestConfigs{typeName: "issueTriggerTransformationConfigs", IssueTriggerTransformationConfigs: value}
}

func NewIssueTriggerUpdateRequestConfigsFromIssueTriggerBackpressureConfigs(value *IssueTriggerBackpressureConfigs) *IssueTriggerUpdateRequestConfigs {
	return &IssueTriggerUpdateRequestConfigs{typeName: "issueTriggerBackpressureConfigs", IssueTriggerBackpressureConfigs: value}
}

func (i *IssueTriggerUpdateRequestConfigs) UnmarshalJSON(data []byte) error {
	valueIssueTriggerDeliveryConfigs := new(IssueTriggerDeliveryConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerDeliveryConfigs); err == nil {
		i.typeName = "issueTriggerDeliveryConfigs"
		i.IssueTriggerDeliveryConfigs = valueIssueTriggerDeliveryConfigs
		return nil
	}
	valueIssueTriggerTransformationConfigs := new(IssueTriggerTransformationConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerTransformationConfigs); err == nil {
		i.typeName = "issueTriggerTransformationConfigs"
		i.IssueTriggerTransformationConfigs = valueIssueTriggerTransformationConfigs
		return nil
	}
	valueIssueTriggerBackpressureConfigs := new(IssueTriggerBackpressureConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerBackpressureConfigs); err == nil {
		i.typeName = "issueTriggerBackpressureConfigs"
		i.IssueTriggerBackpressureConfigs = valueIssueTriggerBackpressureConfigs
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerUpdateRequestConfigs) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueTriggerDeliveryConfigs":
		return json.Marshal(i.IssueTriggerDeliveryConfigs)
	case "issueTriggerTransformationConfigs":
		return json.Marshal(i.IssueTriggerTransformationConfigs)
	case "issueTriggerBackpressureConfigs":
		return json.Marshal(i.IssueTriggerBackpressureConfigs)
	}
}

type IssueTriggerUpdateRequestConfigsVisitor interface {
	VisitIssueTriggerDeliveryConfigs(*IssueTriggerDeliveryConfigs) error
	VisitIssueTriggerTransformationConfigs(*IssueTriggerTransformationConfigs) error
	VisitIssueTriggerBackpressureConfigs(*IssueTriggerBackpressureConfigs) error
}

func (i *IssueTriggerUpdateRequestConfigs) Accept(visitor IssueTriggerUpdateRequestConfigsVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueTriggerDeliveryConfigs":
		return visitor.VisitIssueTriggerDeliveryConfigs(i.IssueTriggerDeliveryConfigs)
	case "issueTriggerTransformationConfigs":
		return visitor.VisitIssueTriggerTransformationConfigs(i.IssueTriggerTransformationConfigs)
	case "issueTriggerBackpressureConfigs":
		return visitor.VisitIssueTriggerBackpressureConfigs(i.IssueTriggerBackpressureConfigs)
	}
}

// Configuration object for the specific issue type selected
type IssueTriggerUpsertRequestConfigs struct {
	typeName                          string
	IssueTriggerDeliveryConfigs       *IssueTriggerDeliveryConfigs
	IssueTriggerTransformationConfigs *IssueTriggerTransformationConfigs
	IssueTriggerBackpressureConfigs   *IssueTriggerBackpressureConfigs
}

func NewIssueTriggerUpsertRequestConfigsFromIssueTriggerDeliveryConfigs(value *IssueTriggerDeliveryConfigs) *IssueTriggerUpsertRequestConfigs {
	return &IssueTriggerUpsertRequestConfigs{typeName: "issueTriggerDeliveryConfigs", IssueTriggerDeliveryConfigs: value}
}

func NewIssueTriggerUpsertRequestConfigsFromIssueTriggerTransformationConfigs(value *IssueTriggerTransformationConfigs) *IssueTriggerUpsertRequestConfigs {
	return &IssueTriggerUpsertRequestConfigs{typeName: "issueTriggerTransformationConfigs", IssueTriggerTransformationConfigs: value}
}

func NewIssueTriggerUpsertRequestConfigsFromIssueTriggerBackpressureConfigs(value *IssueTriggerBackpressureConfigs) *IssueTriggerUpsertRequestConfigs {
	return &IssueTriggerUpsertRequestConfigs{typeName: "issueTriggerBackpressureConfigs", IssueTriggerBackpressureConfigs: value}
}

func (i *IssueTriggerUpsertRequestConfigs) UnmarshalJSON(data []byte) error {
	valueIssueTriggerDeliveryConfigs := new(IssueTriggerDeliveryConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerDeliveryConfigs); err == nil {
		i.typeName = "issueTriggerDeliveryConfigs"
		i.IssueTriggerDeliveryConfigs = valueIssueTriggerDeliveryConfigs
		return nil
	}
	valueIssueTriggerTransformationConfigs := new(IssueTriggerTransformationConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerTransformationConfigs); err == nil {
		i.typeName = "issueTriggerTransformationConfigs"
		i.IssueTriggerTransformationConfigs = valueIssueTriggerTransformationConfigs
		return nil
	}
	valueIssueTriggerBackpressureConfigs := new(IssueTriggerBackpressureConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerBackpressureConfigs); err == nil {
		i.typeName = "issueTriggerBackpressureConfigs"
		i.IssueTriggerBackpressureConfigs = valueIssueTriggerBackpressureConfigs
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerUpsertRequestConfigs) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueTriggerDeliveryConfigs":
		return json.Marshal(i.IssueTriggerDeliveryConfigs)
	case "issueTriggerTransformationConfigs":
		return json.Marshal(i.IssueTriggerTransformationConfigs)
	case "issueTriggerBackpressureConfigs":
		return json.Marshal(i.IssueTriggerBackpressureConfigs)
	}
}

type IssueTriggerUpsertRequestConfigsVisitor interface {
	VisitIssueTriggerDeliveryConfigs(*IssueTriggerDeliveryConfigs) error
	VisitIssueTriggerTransformationConfigs(*IssueTriggerTransformationConfigs) error
	VisitIssueTriggerBackpressureConfigs(*IssueTriggerBackpressureConfigs) error
}

func (i *IssueTriggerUpsertRequestConfigs) Accept(visitor IssueTriggerUpsertRequestConfigsVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueTriggerDeliveryConfigs":
		return visitor.VisitIssueTriggerDeliveryConfigs(i.IssueTriggerDeliveryConfigs)
	case "issueTriggerTransformationConfigs":
		return visitor.VisitIssueTriggerTransformationConfigs(i.IssueTriggerTransformationConfigs)
	case "issueTriggerBackpressureConfigs":
		return visitor.VisitIssueTriggerBackpressureConfigs(i.IssueTriggerBackpressureConfigs)
	}
}

// Issue type
type IssueType string

const (
	IssueTypeDelivery       IssueType = "delivery"
	IssueTypeTransformation IssueType = "transformation"
	IssueTypeBackpressure   IssueType = "backpressure"
)

func NewIssueTypeFromString(s string) (IssueType, error) {
	switch s {
	case "delivery":
		return IssueTypeDelivery, nil
	case "transformation":
		return IssueTypeTransformation, nil
	case "backpressure":
		return IssueTypeBackpressure, nil
	}
	var t IssueType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueType) Ptr() *IssueType {
	return &i
}

// New status
type IssueUpdateRequestStatus string

const (
	IssueUpdateRequestStatusOpened       IssueUpdateRequestStatus = "OPENED"
	IssueUpdateRequestStatusIgnored      IssueUpdateRequestStatus = "IGNORED"
	IssueUpdateRequestStatusAcknowledged IssueUpdateRequestStatus = "ACKNOWLEDGED"
	IssueUpdateRequestStatusResolved     IssueUpdateRequestStatus = "RESOLVED"
)

func NewIssueUpdateRequestStatusFromString(s string) (IssueUpdateRequestStatus, error) {
	switch s {
	case "OPENED":
		return IssueUpdateRequestStatusOpened, nil
	case "IGNORED":
		return IssueUpdateRequestStatusIgnored, nil
	case "ACKNOWLEDGED":
		return IssueUpdateRequestStatusAcknowledged, nil
	case "RESOLVED":
		return IssueUpdateRequestStatusResolved, nil
	}
	var t IssueUpdateRequestStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueUpdateRequestStatus) Ptr() *IssueUpdateRequestStatus {
	return &i
}

type IssueWithData struct {
	typeName                    string
	DeliveryIssueWithData       *DeliveryIssueWithData
	TransformationIssueWithData *TransformationIssueWithData
}

func NewIssueWithDataFromDeliveryIssueWithData(value *DeliveryIssueWithData) *IssueWithData {
	return &IssueWithData{typeName: "deliveryIssueWithData", DeliveryIssueWithData: value}
}

func NewIssueWithDataFromTransformationIssueWithData(value *TransformationIssueWithData) *IssueWithData {
	return &IssueWithData{typeName: "transformationIssueWithData", TransformationIssueWithData: value}
}

func (i *IssueWithData) UnmarshalJSON(data []byte) error {
	valueDeliveryIssueWithData := new(DeliveryIssueWithData)
	if err := json.Unmarshal(data, &valueDeliveryIssueWithData); err == nil {
		i.typeName = "deliveryIssueWithData"
		i.DeliveryIssueWithData = valueDeliveryIssueWithData
		return nil
	}
	valueTransformationIssueWithData := new(TransformationIssueWithData)
	if err := json.Unmarshal(data, &valueTransformationIssueWithData); err == nil {
		i.typeName = "transformationIssueWithData"
		i.TransformationIssueWithData = valueTransformationIssueWithData
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueWithData) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "deliveryIssueWithData":
		return json.Marshal(i.DeliveryIssueWithData)
	case "transformationIssueWithData":
		return json.Marshal(i.TransformationIssueWithData)
	}
}

type IssueWithDataVisitor interface {
	VisitDeliveryIssueWithData(*DeliveryIssueWithData) error
	VisitTransformationIssueWithData(*TransformationIssueWithData) error
}

func (i *IssueWithData) Accept(visitor IssueWithDataVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "deliveryIssueWithData":
		return visitor.VisitDeliveryIssueWithData(i.DeliveryIssueWithData)
	case "transformationIssueWithData":
		return visitor.VisitTransformationIssueWithData(i.TransformationIssueWithData)
	}
}

type IssueWithDataPaginatedResult struct {
	Pagination *SeekPagination  `json:"pagination,omitempty"`
	Count      *int             `json:"count,omitempty"`
	Models     []*IssueWithData `json:"models,omitempty"`
}

type ListCustomDomainSchema = []*ListCustomDomainSchemaItem

type ListCustomDomainSchemaItem struct {
	Id                    *string                                          `json:"id,omitempty"`
	Hostname              *string                                          `json:"hostname,omitempty"`
	Status                *string                                          `json:"status,omitempty"`
	Ssl                   *ListCustomDomainSchemaItemSsl                   `json:"ssl,omitempty"`
	VerificationErrors    []string                                         `json:"verification_errors,omitempty"`
	OwnershipVerification *ListCustomDomainSchemaItemOwnershipVerification `json:"ownership_verification,omitempty"`
	CreatedAt             *string                                          `json:"created_at,omitempty"`
}

type ListCustomDomainSchemaItemOwnershipVerification struct {
	Type  *string `json:"type,omitempty"`
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

type ListCustomDomainSchemaItemSsl struct {
	Id                   *string                                                  `json:"id,omitempty"`
	Type                 *string                                                  `json:"type,omitempty"`
	Method               *string                                                  `json:"method,omitempty"`
	Status               *string                                                  `json:"status,omitempty"`
	TxtName              *string                                                  `json:"txt_name,omitempty"`
	TxtValue             *string                                                  `json:"txt_value,omitempty"`
	ValidationRecords    []*ListCustomDomainSchemaItemSslValidationRecordsItem    `json:"validation_records,omitempty"`
	DcvDelegationRecords []*ListCustomDomainSchemaItemSslDcvDelegationRecordsItem `json:"dcv_delegation_records,omitempty"`
	Settings             *ListCustomDomainSchemaItemSslSettings                   `json:"settings,omitempty"`
	BundleMethod         *string                                                  `json:"bundle_method,omitempty"`
	Wildcard             *bool                                                    `json:"wildcard,omitempty"`
	CertificateAuthority *string                                                  `json:"certificate_authority,omitempty"`
}

type ListCustomDomainSchemaItemSslDcvDelegationRecordsItem struct {
	Cname       *string `json:"cname,omitempty"`
	CnameTarget *string `json:"cname_target,omitempty"`
}

type ListCustomDomainSchemaItemSslSettings struct {
	MinTlsVersion *string `json:"min_tls_version,omitempty"`
}

type ListCustomDomainSchemaItemSslValidationRecordsItem struct {
	Status   *string `json:"status,omitempty"`
	TxtName  *string `json:"txt_name,omitempty"`
	TxtValue *string `json:"txt_value,omitempty"`
}

type OrderByDirection string

const (
	OrderByDirectionasc  OrderByDirection = "asc"
	OrderByDirectiondesc OrderByDirection = "desc"
	OrderByDirectionASC  OrderByDirection = "ASC"
	OrderByDirectionDESC OrderByDirection = "DESC"
)

func NewOrderByDirectionFromString(s string) (OrderByDirection, error) {
	switch s {
	case "asc":
		return OrderByDirectionasc, nil
	case "desc":
		return OrderByDirectiondesc, nil
	case "ASC":
		return OrderByDirectionASC, nil
	case "DESC":
		return OrderByDirectionDESC, nil
	}
	var t OrderByDirection
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderByDirection) Ptr() *OrderByDirection {
	return &o
}

type RawBody struct {
	Body string `json:"body"`
}

type Request struct {
	// ID of the request
	Id string `json:"id"`
	// ID of the workspace
	TeamId string `json:"team_id"`
	// Whether or not the request was verified when received
	Verified *bool `json:"verified,omitempty"`
	// ID of the request data
	OriginalEventDataId *string               `json:"original_event_data_id,omitempty"`
	RejectionCause      RequestRejectionCause `json:"rejection_cause,omitempty"`
	// The priority attributed to the request when received
	IngestPriority *RequestIngestPriority `json:"ingest_priority,omitempty"`
	// The time the request was originally received
	IngestedAt *time.Time `json:"ingested_at,omitempty"`
	// ID of the associated source
	SourceId string `json:"source_id"`
	// The count of events created from this request (CLI events not included)
	EventsCount *int `json:"events_count,omitempty"`
	// The count of CLI events created from this request
	CliEventsCount *int `json:"cli_events_count,omitempty"`
	IgnoredCount   *int `json:"ignored_count,omitempty"`
	// Date the event was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the event was created
	CreatedAt time.Time       `json:"created_at"`
	Data      *ShortEventData `json:"data,omitempty"`
}

// Filter properties for the events to be included in the bulk retry, use query parameters of [Requests](#requests)
type RequestBulkRetryCreateRequestQuery struct {
	// Filter by requests IDs
	Id *RequestBulkRetryCreateRequestQueryId `json:"id,omitempty"`
	// Filter by status
	Status *RequestBulkRetryCreateRequestQueryStatus `json:"status,omitempty"`
	// Filter by rejection cause
	RejectionCause *RequestBulkRetryCreateRequestQueryRejectionCause `json:"rejection_cause,omitempty"`
	// Filter by source IDs
	SourceId *RequestBulkRetryCreateRequestQuerySourceId `json:"source_id,omitempty"`
	// Filter by verification status
	Verified *bool `json:"verified,omitempty"`
	// URL Encoded string of the value to match partially to the body, headers, parsed_query or path
	SearchTerm *string `json:"search_term,omitempty"`
	// URL Encoded string of the JSON to match to the data headers
	Headers *RequestBulkRetryCreateRequestQueryHeaders `json:"headers,omitempty"`
	// URL Encoded string of the JSON to match to the data body
	Body *RequestBulkRetryCreateRequestQueryBody `json:"body,omitempty"`
	// URL Encoded string of the JSON to match to the parsed query (JSON representation of the query)
	ParsedQuery *RequestBulkRetryCreateRequestQueryParsedQuery `json:"parsed_query,omitempty"`
	// URL Encoded string of the value to match partially to the path
	Path *string `json:"path,omitempty"`
	// Filter by count of ignored events
	IgnoredCount *RequestBulkRetryCreateRequestQueryIgnoredCount `json:"ignored_count,omitempty"`
	// Filter by count of events
	EventsCount *RequestBulkRetryCreateRequestQueryEventsCount `json:"events_count,omitempty"`
	// Filter by event ingested date
	IngestedAt  *RequestBulkRetryCreateRequestQueryIngestedAt  `json:"ingested_at,omitempty"`
	BulkRetryId *RequestBulkRetryCreateRequestQueryBulkRetryId `json:"bulk_retry_id,omitempty"`
}

// URL Encoded string of the JSON to match to the data body
type RequestBulkRetryCreateRequestQueryBody struct {
	typeName                                  string
	String                                    string
	RequestBulkRetryCreateRequestQueryBodyOne *RequestBulkRetryCreateRequestQueryBodyOne
}

func NewRequestBulkRetryCreateRequestQueryBodyFromString(value string) *RequestBulkRetryCreateRequestQueryBody {
	return &RequestBulkRetryCreateRequestQueryBody{typeName: "string", String: value}
}

func NewRequestBulkRetryCreateRequestQueryBodyFromRequestBulkRetryCreateRequestQueryBodyOne(value *RequestBulkRetryCreateRequestQueryBodyOne) *RequestBulkRetryCreateRequestQueryBody {
	return &RequestBulkRetryCreateRequestQueryBody{typeName: "requestBulkRetryCreateRequestQueryBodyOne", RequestBulkRetryCreateRequestQueryBodyOne: value}
}

func (r *RequestBulkRetryCreateRequestQueryBody) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	valueRequestBulkRetryCreateRequestQueryBodyOne := new(RequestBulkRetryCreateRequestQueryBodyOne)
	if err := json.Unmarshal(data, &valueRequestBulkRetryCreateRequestQueryBodyOne); err == nil {
		r.typeName = "requestBulkRetryCreateRequestQueryBodyOne"
		r.RequestBulkRetryCreateRequestQueryBodyOne = valueRequestBulkRetryCreateRequestQueryBodyOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryBody) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return json.Marshal(r.String)
	case "requestBulkRetryCreateRequestQueryBodyOne":
		return json.Marshal(r.RequestBulkRetryCreateRequestQueryBodyOne)
	}
}

type RequestBulkRetryCreateRequestQueryBodyVisitor interface {
	VisitString(string) error
	VisitRequestBulkRetryCreateRequestQueryBodyOne(*RequestBulkRetryCreateRequestQueryBodyOne) error
}

func (r *RequestBulkRetryCreateRequestQueryBody) Accept(visitor RequestBulkRetryCreateRequestQueryBodyVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return visitor.VisitString(r.String)
	case "requestBulkRetryCreateRequestQueryBodyOne":
		return visitor.VisitRequestBulkRetryCreateRequestQueryBodyOne(r.RequestBulkRetryCreateRequestQueryBodyOne)
	}
}

type RequestBulkRetryCreateRequestQueryBodyOne struct {
}

type RequestBulkRetryCreateRequestQueryBulkRetryId struct {
	typeName string
	// <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewRequestBulkRetryCreateRequestQueryBulkRetryIdFromString(value string) *RequestBulkRetryCreateRequestQueryBulkRetryId {
	return &RequestBulkRetryCreateRequestQueryBulkRetryId{typeName: "string", String: value}
}

func NewRequestBulkRetryCreateRequestQueryBulkRetryIdFromStringList(value []string) *RequestBulkRetryCreateRequestQueryBulkRetryId {
	return &RequestBulkRetryCreateRequestQueryBulkRetryId{typeName: "stringList", StringList: value}
}

func (r *RequestBulkRetryCreateRequestQueryBulkRetryId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		r.typeName = "stringList"
		r.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryBulkRetryId) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return json.Marshal(r.String)
	case "stringList":
		return json.Marshal(r.StringList)
	}
}

type RequestBulkRetryCreateRequestQueryBulkRetryIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (r *RequestBulkRetryCreateRequestQueryBulkRetryId) Accept(visitor RequestBulkRetryCreateRequestQueryBulkRetryIdVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return visitor.VisitString(r.String)
	case "stringList":
		return visitor.VisitStringList(r.StringList)
	}
}

// Filter by count of events
type RequestBulkRetryCreateRequestQueryEventsCount struct {
	typeName                                         string
	Integer                                          int
	RequestBulkRetryCreateRequestQueryEventsCountAny *RequestBulkRetryCreateRequestQueryEventsCountAny
	IntegerList                                      []int
}

func NewRequestBulkRetryCreateRequestQueryEventsCountFromInteger(value int) *RequestBulkRetryCreateRequestQueryEventsCount {
	return &RequestBulkRetryCreateRequestQueryEventsCount{typeName: "integer", Integer: value}
}

func NewRequestBulkRetryCreateRequestQueryEventsCountFromRequestBulkRetryCreateRequestQueryEventsCountAny(value *RequestBulkRetryCreateRequestQueryEventsCountAny) *RequestBulkRetryCreateRequestQueryEventsCount {
	return &RequestBulkRetryCreateRequestQueryEventsCount{typeName: "requestBulkRetryCreateRequestQueryEventsCountAny", RequestBulkRetryCreateRequestQueryEventsCountAny: value}
}

func NewRequestBulkRetryCreateRequestQueryEventsCountFromIntegerList(value []int) *RequestBulkRetryCreateRequestQueryEventsCount {
	return &RequestBulkRetryCreateRequestQueryEventsCount{typeName: "integerList", IntegerList: value}
}

func (r *RequestBulkRetryCreateRequestQueryEventsCount) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		r.typeName = "integer"
		r.Integer = valueInteger
		return nil
	}
	valueRequestBulkRetryCreateRequestQueryEventsCountAny := new(RequestBulkRetryCreateRequestQueryEventsCountAny)
	if err := json.Unmarshal(data, &valueRequestBulkRetryCreateRequestQueryEventsCountAny); err == nil {
		r.typeName = "requestBulkRetryCreateRequestQueryEventsCountAny"
		r.RequestBulkRetryCreateRequestQueryEventsCountAny = valueRequestBulkRetryCreateRequestQueryEventsCountAny
		return nil
	}
	var valueIntegerList []int
	if err := json.Unmarshal(data, &valueIntegerList); err == nil {
		r.typeName = "integerList"
		r.IntegerList = valueIntegerList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryEventsCount) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "integer":
		return json.Marshal(r.Integer)
	case "requestBulkRetryCreateRequestQueryEventsCountAny":
		return json.Marshal(r.RequestBulkRetryCreateRequestQueryEventsCountAny)
	case "integerList":
		return json.Marshal(r.IntegerList)
	}
}

type RequestBulkRetryCreateRequestQueryEventsCountVisitor interface {
	VisitInteger(int) error
	VisitRequestBulkRetryCreateRequestQueryEventsCountAny(*RequestBulkRetryCreateRequestQueryEventsCountAny) error
	VisitIntegerList([]int) error
}

func (r *RequestBulkRetryCreateRequestQueryEventsCount) Accept(visitor RequestBulkRetryCreateRequestQueryEventsCountVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "integer":
		return visitor.VisitInteger(r.Integer)
	case "requestBulkRetryCreateRequestQueryEventsCountAny":
		return visitor.VisitRequestBulkRetryCreateRequestQueryEventsCountAny(r.RequestBulkRetryCreateRequestQueryEventsCountAny)
	case "integerList":
		return visitor.VisitIntegerList(r.IntegerList)
	}
}

type RequestBulkRetryCreateRequestQueryEventsCountAny struct {
	Gt       *int  `json:"gt,omitempty"`
	Gte      *int  `json:"gte,omitempty"`
	Le       *int  `json:"le,omitempty"`
	Lte      *int  `json:"lte,omitempty"`
	Any      *bool `json:"any,omitempty"`
	Contains *int  `json:"contains,omitempty"`
}

// URL Encoded string of the JSON to match to the data headers
type RequestBulkRetryCreateRequestQueryHeaders struct {
	typeName                                     string
	String                                       string
	RequestBulkRetryCreateRequestQueryHeadersOne *RequestBulkRetryCreateRequestQueryHeadersOne
}

func NewRequestBulkRetryCreateRequestQueryHeadersFromString(value string) *RequestBulkRetryCreateRequestQueryHeaders {
	return &RequestBulkRetryCreateRequestQueryHeaders{typeName: "string", String: value}
}

func NewRequestBulkRetryCreateRequestQueryHeadersFromRequestBulkRetryCreateRequestQueryHeadersOne(value *RequestBulkRetryCreateRequestQueryHeadersOne) *RequestBulkRetryCreateRequestQueryHeaders {
	return &RequestBulkRetryCreateRequestQueryHeaders{typeName: "requestBulkRetryCreateRequestQueryHeadersOne", RequestBulkRetryCreateRequestQueryHeadersOne: value}
}

func (r *RequestBulkRetryCreateRequestQueryHeaders) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	valueRequestBulkRetryCreateRequestQueryHeadersOne := new(RequestBulkRetryCreateRequestQueryHeadersOne)
	if err := json.Unmarshal(data, &valueRequestBulkRetryCreateRequestQueryHeadersOne); err == nil {
		r.typeName = "requestBulkRetryCreateRequestQueryHeadersOne"
		r.RequestBulkRetryCreateRequestQueryHeadersOne = valueRequestBulkRetryCreateRequestQueryHeadersOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryHeaders) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return json.Marshal(r.String)
	case "requestBulkRetryCreateRequestQueryHeadersOne":
		return json.Marshal(r.RequestBulkRetryCreateRequestQueryHeadersOne)
	}
}

type RequestBulkRetryCreateRequestQueryHeadersVisitor interface {
	VisitString(string) error
	VisitRequestBulkRetryCreateRequestQueryHeadersOne(*RequestBulkRetryCreateRequestQueryHeadersOne) error
}

func (r *RequestBulkRetryCreateRequestQueryHeaders) Accept(visitor RequestBulkRetryCreateRequestQueryHeadersVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return visitor.VisitString(r.String)
	case "requestBulkRetryCreateRequestQueryHeadersOne":
		return visitor.VisitRequestBulkRetryCreateRequestQueryHeadersOne(r.RequestBulkRetryCreateRequestQueryHeadersOne)
	}
}

type RequestBulkRetryCreateRequestQueryHeadersOne struct {
}

// Filter by requests IDs
type RequestBulkRetryCreateRequestQueryId struct {
	typeName string
	// Request ID <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewRequestBulkRetryCreateRequestQueryIdFromString(value string) *RequestBulkRetryCreateRequestQueryId {
	return &RequestBulkRetryCreateRequestQueryId{typeName: "string", String: value}
}

func NewRequestBulkRetryCreateRequestQueryIdFromStringList(value []string) *RequestBulkRetryCreateRequestQueryId {
	return &RequestBulkRetryCreateRequestQueryId{typeName: "stringList", StringList: value}
}

func (r *RequestBulkRetryCreateRequestQueryId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		r.typeName = "stringList"
		r.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryId) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return json.Marshal(r.String)
	case "stringList":
		return json.Marshal(r.StringList)
	}
}

type RequestBulkRetryCreateRequestQueryIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (r *RequestBulkRetryCreateRequestQueryId) Accept(visitor RequestBulkRetryCreateRequestQueryIdVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return visitor.VisitString(r.String)
	case "stringList":
		return visitor.VisitStringList(r.StringList)
	}
}

// Filter by count of ignored events
type RequestBulkRetryCreateRequestQueryIgnoredCount struct {
	typeName                                          string
	Integer                                           int
	RequestBulkRetryCreateRequestQueryIgnoredCountAny *RequestBulkRetryCreateRequestQueryIgnoredCountAny
	IntegerList                                       []int
}

func NewRequestBulkRetryCreateRequestQueryIgnoredCountFromInteger(value int) *RequestBulkRetryCreateRequestQueryIgnoredCount {
	return &RequestBulkRetryCreateRequestQueryIgnoredCount{typeName: "integer", Integer: value}
}

func NewRequestBulkRetryCreateRequestQueryIgnoredCountFromRequestBulkRetryCreateRequestQueryIgnoredCountAny(value *RequestBulkRetryCreateRequestQueryIgnoredCountAny) *RequestBulkRetryCreateRequestQueryIgnoredCount {
	return &RequestBulkRetryCreateRequestQueryIgnoredCount{typeName: "requestBulkRetryCreateRequestQueryIgnoredCountAny", RequestBulkRetryCreateRequestQueryIgnoredCountAny: value}
}

func NewRequestBulkRetryCreateRequestQueryIgnoredCountFromIntegerList(value []int) *RequestBulkRetryCreateRequestQueryIgnoredCount {
	return &RequestBulkRetryCreateRequestQueryIgnoredCount{typeName: "integerList", IntegerList: value}
}

func (r *RequestBulkRetryCreateRequestQueryIgnoredCount) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		r.typeName = "integer"
		r.Integer = valueInteger
		return nil
	}
	valueRequestBulkRetryCreateRequestQueryIgnoredCountAny := new(RequestBulkRetryCreateRequestQueryIgnoredCountAny)
	if err := json.Unmarshal(data, &valueRequestBulkRetryCreateRequestQueryIgnoredCountAny); err == nil {
		r.typeName = "requestBulkRetryCreateRequestQueryIgnoredCountAny"
		r.RequestBulkRetryCreateRequestQueryIgnoredCountAny = valueRequestBulkRetryCreateRequestQueryIgnoredCountAny
		return nil
	}
	var valueIntegerList []int
	if err := json.Unmarshal(data, &valueIntegerList); err == nil {
		r.typeName = "integerList"
		r.IntegerList = valueIntegerList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryIgnoredCount) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "integer":
		return json.Marshal(r.Integer)
	case "requestBulkRetryCreateRequestQueryIgnoredCountAny":
		return json.Marshal(r.RequestBulkRetryCreateRequestQueryIgnoredCountAny)
	case "integerList":
		return json.Marshal(r.IntegerList)
	}
}

type RequestBulkRetryCreateRequestQueryIgnoredCountVisitor interface {
	VisitInteger(int) error
	VisitRequestBulkRetryCreateRequestQueryIgnoredCountAny(*RequestBulkRetryCreateRequestQueryIgnoredCountAny) error
	VisitIntegerList([]int) error
}

func (r *RequestBulkRetryCreateRequestQueryIgnoredCount) Accept(visitor RequestBulkRetryCreateRequestQueryIgnoredCountVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "integer":
		return visitor.VisitInteger(r.Integer)
	case "requestBulkRetryCreateRequestQueryIgnoredCountAny":
		return visitor.VisitRequestBulkRetryCreateRequestQueryIgnoredCountAny(r.RequestBulkRetryCreateRequestQueryIgnoredCountAny)
	case "integerList":
		return visitor.VisitIntegerList(r.IntegerList)
	}
}

type RequestBulkRetryCreateRequestQueryIgnoredCountAny struct {
	Gt       *int  `json:"gt,omitempty"`
	Gte      *int  `json:"gte,omitempty"`
	Le       *int  `json:"le,omitempty"`
	Lte      *int  `json:"lte,omitempty"`
	Any      *bool `json:"any,omitempty"`
	Contains *int  `json:"contains,omitempty"`
}

// Filter by event ingested date
type RequestBulkRetryCreateRequestQueryIngestedAt struct {
	typeName                                        string
	DateTime                                        time.Time
	RequestBulkRetryCreateRequestQueryIngestedAtAny *RequestBulkRetryCreateRequestQueryIngestedAtAny
}

func NewRequestBulkRetryCreateRequestQueryIngestedAtFromDateTime(value time.Time) *RequestBulkRetryCreateRequestQueryIngestedAt {
	return &RequestBulkRetryCreateRequestQueryIngestedAt{typeName: "dateTime", DateTime: value}
}

func NewRequestBulkRetryCreateRequestQueryIngestedAtFromRequestBulkRetryCreateRequestQueryIngestedAtAny(value *RequestBulkRetryCreateRequestQueryIngestedAtAny) *RequestBulkRetryCreateRequestQueryIngestedAt {
	return &RequestBulkRetryCreateRequestQueryIngestedAt{typeName: "requestBulkRetryCreateRequestQueryIngestedAtAny", RequestBulkRetryCreateRequestQueryIngestedAtAny: value}
}

func (r *RequestBulkRetryCreateRequestQueryIngestedAt) UnmarshalJSON(data []byte) error {
	var valueDateTime time.Time
	if err := json.Unmarshal(data, &valueDateTime); err == nil {
		r.typeName = "dateTime"
		r.DateTime = valueDateTime
		return nil
	}
	valueRequestBulkRetryCreateRequestQueryIngestedAtAny := new(RequestBulkRetryCreateRequestQueryIngestedAtAny)
	if err := json.Unmarshal(data, &valueRequestBulkRetryCreateRequestQueryIngestedAtAny); err == nil {
		r.typeName = "requestBulkRetryCreateRequestQueryIngestedAtAny"
		r.RequestBulkRetryCreateRequestQueryIngestedAtAny = valueRequestBulkRetryCreateRequestQueryIngestedAtAny
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryIngestedAt) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "dateTime":
		return json.Marshal(r.DateTime)
	case "requestBulkRetryCreateRequestQueryIngestedAtAny":
		return json.Marshal(r.RequestBulkRetryCreateRequestQueryIngestedAtAny)
	}
}

type RequestBulkRetryCreateRequestQueryIngestedAtVisitor interface {
	VisitDateTime(time.Time) error
	VisitRequestBulkRetryCreateRequestQueryIngestedAtAny(*RequestBulkRetryCreateRequestQueryIngestedAtAny) error
}

func (r *RequestBulkRetryCreateRequestQueryIngestedAt) Accept(visitor RequestBulkRetryCreateRequestQueryIngestedAtVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "dateTime":
		return visitor.VisitDateTime(r.DateTime)
	case "requestBulkRetryCreateRequestQueryIngestedAtAny":
		return visitor.VisitRequestBulkRetryCreateRequestQueryIngestedAtAny(r.RequestBulkRetryCreateRequestQueryIngestedAtAny)
	}
}

type RequestBulkRetryCreateRequestQueryIngestedAtAny struct {
	Gt  *time.Time `json:"gt,omitempty"`
	Gte *time.Time `json:"gte,omitempty"`
	Le  *time.Time `json:"le,omitempty"`
	Lte *time.Time `json:"lte,omitempty"`
	Any *bool      `json:"any,omitempty"`
}

// URL Encoded string of the JSON to match to the parsed query (JSON representation of the query)
type RequestBulkRetryCreateRequestQueryParsedQuery struct {
	typeName                                         string
	String                                           string
	RequestBulkRetryCreateRequestQueryParsedQueryOne *RequestBulkRetryCreateRequestQueryParsedQueryOne
}

func NewRequestBulkRetryCreateRequestQueryParsedQueryFromString(value string) *RequestBulkRetryCreateRequestQueryParsedQuery {
	return &RequestBulkRetryCreateRequestQueryParsedQuery{typeName: "string", String: value}
}

func NewRequestBulkRetryCreateRequestQueryParsedQueryFromRequestBulkRetryCreateRequestQueryParsedQueryOne(value *RequestBulkRetryCreateRequestQueryParsedQueryOne) *RequestBulkRetryCreateRequestQueryParsedQuery {
	return &RequestBulkRetryCreateRequestQueryParsedQuery{typeName: "requestBulkRetryCreateRequestQueryParsedQueryOne", RequestBulkRetryCreateRequestQueryParsedQueryOne: value}
}

func (r *RequestBulkRetryCreateRequestQueryParsedQuery) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	valueRequestBulkRetryCreateRequestQueryParsedQueryOne := new(RequestBulkRetryCreateRequestQueryParsedQueryOne)
	if err := json.Unmarshal(data, &valueRequestBulkRetryCreateRequestQueryParsedQueryOne); err == nil {
		r.typeName = "requestBulkRetryCreateRequestQueryParsedQueryOne"
		r.RequestBulkRetryCreateRequestQueryParsedQueryOne = valueRequestBulkRetryCreateRequestQueryParsedQueryOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryParsedQuery) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return json.Marshal(r.String)
	case "requestBulkRetryCreateRequestQueryParsedQueryOne":
		return json.Marshal(r.RequestBulkRetryCreateRequestQueryParsedQueryOne)
	}
}

type RequestBulkRetryCreateRequestQueryParsedQueryVisitor interface {
	VisitString(string) error
	VisitRequestBulkRetryCreateRequestQueryParsedQueryOne(*RequestBulkRetryCreateRequestQueryParsedQueryOne) error
}

func (r *RequestBulkRetryCreateRequestQueryParsedQuery) Accept(visitor RequestBulkRetryCreateRequestQueryParsedQueryVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return visitor.VisitString(r.String)
	case "requestBulkRetryCreateRequestQueryParsedQueryOne":
		return visitor.VisitRequestBulkRetryCreateRequestQueryParsedQueryOne(r.RequestBulkRetryCreateRequestQueryParsedQueryOne)
	}
}

type RequestBulkRetryCreateRequestQueryParsedQueryOne struct {
}

// Filter by rejection cause
type RequestBulkRetryCreateRequestQueryRejectionCause struct {
	typeName                  string
	RequestRejectionCause     RequestRejectionCause
	RequestRejectionCauseList []RequestRejectionCause
}

func NewRequestBulkRetryCreateRequestQueryRejectionCauseFromRequestRejectionCause(value RequestRejectionCause) *RequestBulkRetryCreateRequestQueryRejectionCause {
	return &RequestBulkRetryCreateRequestQueryRejectionCause{typeName: "requestRejectionCause", RequestRejectionCause: value}
}

func NewRequestBulkRetryCreateRequestQueryRejectionCauseFromRequestRejectionCauseList(value []RequestRejectionCause) *RequestBulkRetryCreateRequestQueryRejectionCause {
	return &RequestBulkRetryCreateRequestQueryRejectionCause{typeName: "requestRejectionCauseList", RequestRejectionCauseList: value}
}

func (r *RequestBulkRetryCreateRequestQueryRejectionCause) UnmarshalJSON(data []byte) error {
	var valueRequestRejectionCause RequestRejectionCause
	if err := json.Unmarshal(data, &valueRequestRejectionCause); err == nil {
		r.typeName = "requestRejectionCause"
		r.RequestRejectionCause = valueRequestRejectionCause
		return nil
	}
	var valueRequestRejectionCauseList []RequestRejectionCause
	if err := json.Unmarshal(data, &valueRequestRejectionCauseList); err == nil {
		r.typeName = "requestRejectionCauseList"
		r.RequestRejectionCauseList = valueRequestRejectionCauseList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryRejectionCause) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "requestRejectionCause":
		return json.Marshal(r.RequestRejectionCause)
	case "requestRejectionCauseList":
		return json.Marshal(r.RequestRejectionCauseList)
	}
}

type RequestBulkRetryCreateRequestQueryRejectionCauseVisitor interface {
	VisitRequestRejectionCause(RequestRejectionCause) error
	VisitRequestRejectionCauseList([]RequestRejectionCause) error
}

func (r *RequestBulkRetryCreateRequestQueryRejectionCause) Accept(visitor RequestBulkRetryCreateRequestQueryRejectionCauseVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "requestRejectionCause":
		return visitor.VisitRequestRejectionCause(r.RequestRejectionCause)
	case "requestRejectionCauseList":
		return visitor.VisitRequestRejectionCauseList(r.RequestRejectionCauseList)
	}
}

// Filter by source IDs
type RequestBulkRetryCreateRequestQuerySourceId struct {
	typeName string
	// Source ID <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewRequestBulkRetryCreateRequestQuerySourceIdFromString(value string) *RequestBulkRetryCreateRequestQuerySourceId {
	return &RequestBulkRetryCreateRequestQuerySourceId{typeName: "string", String: value}
}

func NewRequestBulkRetryCreateRequestQuerySourceIdFromStringList(value []string) *RequestBulkRetryCreateRequestQuerySourceId {
	return &RequestBulkRetryCreateRequestQuerySourceId{typeName: "stringList", StringList: value}
}

func (r *RequestBulkRetryCreateRequestQuerySourceId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		r.typeName = "stringList"
		r.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQuerySourceId) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return json.Marshal(r.String)
	case "stringList":
		return json.Marshal(r.StringList)
	}
}

type RequestBulkRetryCreateRequestQuerySourceIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (r *RequestBulkRetryCreateRequestQuerySourceId) Accept(visitor RequestBulkRetryCreateRequestQuerySourceIdVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return visitor.VisitString(r.String)
	case "stringList":
		return visitor.VisitStringList(r.StringList)
	}
}

// Filter by status
type RequestBulkRetryCreateRequestQueryStatus string

const (
	RequestBulkRetryCreateRequestQueryStatusAccepted RequestBulkRetryCreateRequestQueryStatus = "accepted"
	RequestBulkRetryCreateRequestQueryStatusRejected RequestBulkRetryCreateRequestQueryStatus = "rejected"
)

func NewRequestBulkRetryCreateRequestQueryStatusFromString(s string) (RequestBulkRetryCreateRequestQueryStatus, error) {
	switch s {
	case "accepted":
		return RequestBulkRetryCreateRequestQueryStatusAccepted, nil
	case "rejected":
		return RequestBulkRetryCreateRequestQueryStatusRejected, nil
	}
	var t RequestBulkRetryCreateRequestQueryStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestBulkRetryCreateRequestQueryStatus) Ptr() *RequestBulkRetryCreateRequestQueryStatus {
	return &r
}

type RequestBulkRetryListRequestDir string

const (
	RequestBulkRetryListRequestDirAsc  RequestBulkRetryListRequestDir = "asc"
	RequestBulkRetryListRequestDirDesc RequestBulkRetryListRequestDir = "desc"
)

func NewRequestBulkRetryListRequestDirFromString(s string) (RequestBulkRetryListRequestDir, error) {
	switch s {
	case "asc":
		return RequestBulkRetryListRequestDirAsc, nil
	case "desc":
		return RequestBulkRetryListRequestDirDesc, nil
	}
	var t RequestBulkRetryListRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestBulkRetryListRequestDir) Ptr() *RequestBulkRetryListRequestDir {
	return &r
}

type RequestBulkRetryPlanResponse struct {
	// Number of batches required to complete the bulk retry
	EstimatedBatch *int `json:"estimated_batch,omitempty"`
	// Number of estimated events to be retried
	EstimatedCount *int `json:"estimated_count,omitempty"`
	// Progression of the batch operations, values 0 - 1
	Progress *float64 `json:"progress,omitempty"`
}

// The priority attributed to the request when received
type RequestIngestPriority string

const (
	RequestIngestPriorityNormal RequestIngestPriority = "NORMAL"
	RequestIngestPriorityLow    RequestIngestPriority = "LOW"
)

func NewRequestIngestPriorityFromString(s string) (RequestIngestPriority, error) {
	switch s {
	case "NORMAL":
		return RequestIngestPriorityNormal, nil
	case "LOW":
		return RequestIngestPriorityLow, nil
	}
	var t RequestIngestPriority
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestIngestPriority) Ptr() *RequestIngestPriority {
	return &r
}

// Sort direction
type RequestListEventRequestDir string

const (
	RequestListEventRequestDirAsc  RequestListEventRequestDir = "asc"
	RequestListEventRequestDirDesc RequestListEventRequestDir = "desc"
)

func NewRequestListEventRequestDirFromString(s string) (RequestListEventRequestDir, error) {
	switch s {
	case "asc":
		return RequestListEventRequestDirAsc, nil
	case "desc":
		return RequestListEventRequestDirDesc, nil
	}
	var t RequestListEventRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestListEventRequestDir) Ptr() *RequestListEventRequestDir {
	return &r
}

// Sort key
type RequestListEventRequestOrderBy string

const (
	RequestListEventRequestOrderByLastAttemptAt RequestListEventRequestOrderBy = "last_attempt_at"
	RequestListEventRequestOrderByCreatedAt     RequestListEventRequestOrderBy = "created_at"
)

func NewRequestListEventRequestOrderByFromString(s string) (RequestListEventRequestOrderBy, error) {
	switch s {
	case "last_attempt_at":
		return RequestListEventRequestOrderByLastAttemptAt, nil
	case "created_at":
		return RequestListEventRequestOrderByCreatedAt, nil
	}
	var t RequestListEventRequestOrderBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestListEventRequestOrderBy) Ptr() *RequestListEventRequestOrderBy {
	return &r
}

type RequestListIgnoredEventRequestDir string

const (
	RequestListIgnoredEventRequestDirAsc  RequestListIgnoredEventRequestDir = "asc"
	RequestListIgnoredEventRequestDirDesc RequestListIgnoredEventRequestDir = "desc"
)

func NewRequestListIgnoredEventRequestDirFromString(s string) (RequestListIgnoredEventRequestDir, error) {
	switch s {
	case "asc":
		return RequestListIgnoredEventRequestDirAsc, nil
	case "desc":
		return RequestListIgnoredEventRequestDirDesc, nil
	}
	var t RequestListIgnoredEventRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestListIgnoredEventRequestDir) Ptr() *RequestListIgnoredEventRequestDir {
	return &r
}

// Sort direction
type RequestListRequestDir string

const (
	RequestListRequestDirAsc  RequestListRequestDir = "asc"
	RequestListRequestDirDesc RequestListRequestDir = "desc"
)

func NewRequestListRequestDirFromString(s string) (RequestListRequestDir, error) {
	switch s {
	case "asc":
		return RequestListRequestDirAsc, nil
	case "desc":
		return RequestListRequestDirDesc, nil
	}
	var t RequestListRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestListRequestDir) Ptr() *RequestListRequestDir {
	return &r
}

// Sort key
type RequestListRequestOrderBy string

const (
	RequestListRequestOrderByIngestedAt RequestListRequestOrderBy = "ingested_at"
	RequestListRequestOrderByCreatedAt  RequestListRequestOrderBy = "created_at"
)

func NewRequestListRequestOrderByFromString(s string) (RequestListRequestOrderBy, error) {
	switch s {
	case "ingested_at":
		return RequestListRequestOrderByIngestedAt, nil
	case "created_at":
		return RequestListRequestOrderByCreatedAt, nil
	}
	var t RequestListRequestOrderBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestListRequestOrderBy) Ptr() *RequestListRequestOrderBy {
	return &r
}

// Filter by status
type RequestListRequestStatus string

const (
	RequestListRequestStatusAccepted RequestListRequestStatus = "accepted"
	RequestListRequestStatusRejected RequestListRequestStatus = "rejected"
)

func NewRequestListRequestStatusFromString(s string) (RequestListRequestStatus, error) {
	switch s {
	case "accepted":
		return RequestListRequestStatusAccepted, nil
	case "rejected":
		return RequestListRequestStatusRejected, nil
	}
	var t RequestListRequestStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestListRequestStatus) Ptr() *RequestListRequestStatus {
	return &r
}

type RequestPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Request      `json:"models,omitempty"`
}

type RequestRejectionCause string

const (
	RequestRejectionCauseSourceArchived         RequestRejectionCause = "SOURCE_ARCHIVED"
	RequestRejectionCauseNoWebhook              RequestRejectionCause = "NO_WEBHOOK"
	RequestRejectionCauseVerificationFailed     RequestRejectionCause = "VERIFICATION_FAILED"
	RequestRejectionCauseUnsupportedHttpMethod  RequestRejectionCause = "UNSUPPORTED_HTTP_METHOD"
	RequestRejectionCauseUnsupportedContentType RequestRejectionCause = "UNSUPPORTED_CONTENT_TYPE"
	RequestRejectionCauseUnparsableJson         RequestRejectionCause = "UNPARSABLE_JSON"
	RequestRejectionCausePayloadTooLarge        RequestRejectionCause = "PAYLOAD_TOO_LARGE"
	RequestRejectionCauseIngestionFatal         RequestRejectionCause = "INGESTION_FATAL"
	RequestRejectionCauseUnknown                RequestRejectionCause = "UNKNOWN"
)

func NewRequestRejectionCauseFromString(s string) (RequestRejectionCause, error) {
	switch s {
	case "SOURCE_ARCHIVED":
		return RequestRejectionCauseSourceArchived, nil
	case "NO_WEBHOOK":
		return RequestRejectionCauseNoWebhook, nil
	case "VERIFICATION_FAILED":
		return RequestRejectionCauseVerificationFailed, nil
	case "UNSUPPORTED_HTTP_METHOD":
		return RequestRejectionCauseUnsupportedHttpMethod, nil
	case "UNSUPPORTED_CONTENT_TYPE":
		return RequestRejectionCauseUnsupportedContentType, nil
	case "UNPARSABLE_JSON":
		return RequestRejectionCauseUnparsableJson, nil
	case "PAYLOAD_TOO_LARGE":
		return RequestRejectionCausePayloadTooLarge, nil
	case "INGESTION_FATAL":
		return RequestRejectionCauseIngestionFatal, nil
	case "UNKNOWN":
		return RequestRejectionCauseUnknown, nil
	}
	var t RequestRejectionCause
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestRejectionCause) Ptr() *RequestRejectionCause {
	return &r
}

type RetriedEvent struct {
	Event   *Event        `json:"event,omitempty"`
	Attempt *EventAttempt `json:"attempt,omitempty"`
}

type RetryRequest struct {
	Request *Request `json:"request,omitempty"`
	Events  []*Event `json:"events,omitempty"`
}

type RetryRule struct {
	Strategy RetryStrategy `json:"strategy,omitempty"`
	// Time in MS between each retry
	Interval *int `json:"interval,omitempty"`
	// Maximum number of retries to attempt
	Count *int `json:"count,omitempty"`
	type_ string
}

func (r *RetryRule) Type() string {
	return r.type_
}

func (r *RetryRule) UnmarshalJSON(data []byte) error {
	type unmarshaler RetryRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetryRule(value)
	r.type_ = "retry"
	return nil
}

func (r *RetryRule) MarshalJSON() ([]byte, error) {
	type embed RetryRule
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
		Type:  "retry",
	}
	return json.Marshal(marshaler)
}

// Algorithm to use when calculating delay between retries
type RetryStrategy string

const (
	RetryStrategyLinear      RetryStrategy = "linear"
	RetryStrategyExponential RetryStrategy = "exponential"
)

func NewRetryStrategyFromString(s string) (RetryStrategy, error) {
	switch s {
	case "linear":
		return RetryStrategyLinear, nil
	case "exponential":
		return RetryStrategyExponential, nil
	}
	var t RetryStrategy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RetryStrategy) Ptr() *RetryStrategy {
	return &r
}

type Rule struct {
	typeName      string
	RetryRule     *RetryRule
	FilterRule    *FilterRule
	TransformRule *TransformRule
	DelayRule     *DelayRule
}

func NewRuleFromRetryRule(value *RetryRule) *Rule {
	return &Rule{typeName: "retryRule", RetryRule: value}
}

func NewRuleFromFilterRule(value *FilterRule) *Rule {
	return &Rule{typeName: "filterRule", FilterRule: value}
}

func NewRuleFromTransformRule(value *TransformRule) *Rule {
	return &Rule{typeName: "transformRule", TransformRule: value}
}

func NewRuleFromDelayRule(value *DelayRule) *Rule {
	return &Rule{typeName: "delayRule", DelayRule: value}
}

func (r *Rule) UnmarshalJSON(data []byte) error {
	valueRetryRule := new(RetryRule)
	if err := json.Unmarshal(data, &valueRetryRule); err == nil {
		r.typeName = "retryRule"
		r.RetryRule = valueRetryRule
		return nil
	}
	valueFilterRule := new(FilterRule)
	if err := json.Unmarshal(data, &valueFilterRule); err == nil {
		r.typeName = "filterRule"
		r.FilterRule = valueFilterRule
		return nil
	}
	valueTransformRule := new(TransformRule)
	if err := json.Unmarshal(data, &valueTransformRule); err == nil {
		r.typeName = "transformRule"
		r.TransformRule = valueTransformRule
		return nil
	}
	valueDelayRule := new(DelayRule)
	if err := json.Unmarshal(data, &valueDelayRule); err == nil {
		r.typeName = "delayRule"
		r.DelayRule = valueDelayRule
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r Rule) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "retryRule":
		return json.Marshal(r.RetryRule)
	case "filterRule":
		return json.Marshal(r.FilterRule)
	case "transformRule":
		return json.Marshal(r.TransformRule)
	case "delayRule":
		return json.Marshal(r.DelayRule)
	}
}

type RuleVisitor interface {
	VisitRetryRule(*RetryRule) error
	VisitFilterRule(*FilterRule) error
	VisitTransformRule(*TransformRule) error
	VisitDelayRule(*DelayRule) error
}

func (r *Rule) Accept(visitor RuleVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "retryRule":
		return visitor.VisitRetryRule(r.RetryRule)
	case "filterRule":
		return visitor.VisitFilterRule(r.FilterRule)
	case "transformRule":
		return visitor.VisitTransformRule(r.TransformRule)
	case "delayRule":
		return visitor.VisitDelayRule(r.DelayRule)
	}
}

type SeekPagination struct {
	OrderBy *SeekPaginationOrderBy `json:"order_by,omitempty"`
	Dir     *SeekPaginationDir     `json:"dir,omitempty"`
	Limit   *int                   `json:"limit,omitempty"`
	Prev    *string                `json:"prev,omitempty"`
	Next    *string                `json:"next,omitempty"`
}

type SeekPaginationDir struct {
	typeName             string
	OrderByDirection     OrderByDirection
	OrderByDirectionList []OrderByDirection
}

func NewSeekPaginationDirFromOrderByDirection(value OrderByDirection) *SeekPaginationDir {
	return &SeekPaginationDir{typeName: "orderByDirection", OrderByDirection: value}
}

func NewSeekPaginationDirFromOrderByDirectionList(value []OrderByDirection) *SeekPaginationDir {
	return &SeekPaginationDir{typeName: "orderByDirectionList", OrderByDirectionList: value}
}

func (s *SeekPaginationDir) UnmarshalJSON(data []byte) error {
	var valueOrderByDirection OrderByDirection
	if err := json.Unmarshal(data, &valueOrderByDirection); err == nil {
		s.typeName = "orderByDirection"
		s.OrderByDirection = valueOrderByDirection
		return nil
	}
	var valueOrderByDirectionList []OrderByDirection
	if err := json.Unmarshal(data, &valueOrderByDirectionList); err == nil {
		s.typeName = "orderByDirectionList"
		s.OrderByDirectionList = valueOrderByDirectionList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SeekPaginationDir) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "orderByDirection":
		return json.Marshal(s.OrderByDirection)
	case "orderByDirectionList":
		return json.Marshal(s.OrderByDirectionList)
	}
}

type SeekPaginationDirVisitor interface {
	VisitOrderByDirection(OrderByDirection) error
	VisitOrderByDirectionList([]OrderByDirection) error
}

func (s *SeekPaginationDir) Accept(visitor SeekPaginationDirVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "orderByDirection":
		return visitor.VisitOrderByDirection(s.OrderByDirection)
	case "orderByDirectionList":
		return visitor.VisitOrderByDirectionList(s.OrderByDirectionList)
	}
}

type SeekPaginationOrderBy struct {
	typeName   string
	String     string
	StringList []string
}

func NewSeekPaginationOrderByFromString(value string) *SeekPaginationOrderBy {
	return &SeekPaginationOrderBy{typeName: "string", String: value}
}

func NewSeekPaginationOrderByFromStringList(value []string) *SeekPaginationOrderBy {
	return &SeekPaginationOrderBy{typeName: "stringList", StringList: value}
}

func (s *SeekPaginationOrderBy) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typeName = "string"
		s.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		s.typeName = "stringList"
		s.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SeekPaginationOrderBy) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return json.Marshal(s.String)
	case "stringList":
		return json.Marshal(s.StringList)
	}
}

type SeekPaginationOrderByVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (s *SeekPaginationOrderBy) Accept(visitor SeekPaginationOrderByVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return visitor.VisitString(s.String)
	case "stringList":
		return visitor.VisitStringList(s.StringList)
	}
}

type ShopifyIntegrationConfigs struct {
	WebhookSecretKey string                                    `json:"webhook_secret_key"`
	RateLimitPeriod  *ShopifyIntegrationConfigsRateLimitPeriod `json:"rate_limit_period,omitempty"`
	RateLimit        *float64                                  `json:"rate_limit,omitempty"`
	ApiKey           *string                                   `json:"api_key,omitempty"`
	ApiSecret        *string                                   `json:"api_secret,omitempty"`
	Shop             *string                                   `json:"shop,omitempty"`
}

type ShopifyIntegrationConfigsRateLimitPeriod string

const (
	ShopifyIntegrationConfigsRateLimitPeriodMinute ShopifyIntegrationConfigsRateLimitPeriod = "minute"
	ShopifyIntegrationConfigsRateLimitPeriodSecond ShopifyIntegrationConfigsRateLimitPeriod = "second"
)

func NewShopifyIntegrationConfigsRateLimitPeriodFromString(s string) (ShopifyIntegrationConfigsRateLimitPeriod, error) {
	switch s {
	case "minute":
		return ShopifyIntegrationConfigsRateLimitPeriodMinute, nil
	case "second":
		return ShopifyIntegrationConfigsRateLimitPeriodSecond, nil
	}
	var t ShopifyIntegrationConfigsRateLimitPeriod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ShopifyIntegrationConfigsRateLimitPeriod) Ptr() *ShopifyIntegrationConfigsRateLimitPeriod {
	return &s
}

// Request data
type ShortEventData struct {
	// Request path
	Path string `json:"path"`
	// Raw query param string
	Query *string `json:"query,omitempty"`
	// JSON representation of query params
	ParsedQuery *ShortEventDataParsedQuery `json:"parsed_query,omitempty"`
	// JSON representation of the headers
	Headers *ShortEventDataHeaders `json:"headers,omitempty"`
	// JSON or string representation of the body
	Body *ShortEventDataBody `json:"body,omitempty"`
	// Whether the payload is considered large payload and not searchable
	IsLargePayload *bool `json:"is_large_payload,omitempty"`
}

// JSON or string representation of the body
type ShortEventDataBody struct {
	typeName              string
	String                string
	ShortEventDataBodyOne *ShortEventDataBodyOne
	UnknownList           []interface{}
}

func NewShortEventDataBodyFromString(value string) *ShortEventDataBody {
	return &ShortEventDataBody{typeName: "string", String: value}
}

func NewShortEventDataBodyFromShortEventDataBodyOne(value *ShortEventDataBodyOne) *ShortEventDataBody {
	return &ShortEventDataBody{typeName: "shortEventDataBodyOne", ShortEventDataBodyOne: value}
}

func NewShortEventDataBodyFromUnknownList(value []interface{}) *ShortEventDataBody {
	return &ShortEventDataBody{typeName: "unknownList", UnknownList: value}
}

func (s *ShortEventDataBody) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typeName = "string"
		s.String = valueString
		return nil
	}
	valueShortEventDataBodyOne := new(ShortEventDataBodyOne)
	if err := json.Unmarshal(data, &valueShortEventDataBodyOne); err == nil {
		s.typeName = "shortEventDataBodyOne"
		s.ShortEventDataBodyOne = valueShortEventDataBodyOne
		return nil
	}
	var valueUnknownList []interface{}
	if err := json.Unmarshal(data, &valueUnknownList); err == nil {
		s.typeName = "unknownList"
		s.UnknownList = valueUnknownList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ShortEventDataBody) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return json.Marshal(s.String)
	case "shortEventDataBodyOne":
		return json.Marshal(s.ShortEventDataBodyOne)
	case "unknownList":
		return json.Marshal(s.UnknownList)
	}
}

type ShortEventDataBodyVisitor interface {
	VisitString(string) error
	VisitShortEventDataBodyOne(*ShortEventDataBodyOne) error
	VisitUnknownList([]interface{}) error
}

func (s *ShortEventDataBody) Accept(visitor ShortEventDataBodyVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return visitor.VisitString(s.String)
	case "shortEventDataBodyOne":
		return visitor.VisitShortEventDataBodyOne(s.ShortEventDataBodyOne)
	case "unknownList":
		return visitor.VisitUnknownList(s.UnknownList)
	}
}

type ShortEventDataBodyOne struct {
}

// JSON representation of the headers
type ShortEventDataHeaders struct {
	typeName                string
	String                  string
	StringStringOptionalMap map[string]*string
}

func NewShortEventDataHeadersFromString(value string) *ShortEventDataHeaders {
	return &ShortEventDataHeaders{typeName: "string", String: value}
}

func NewShortEventDataHeadersFromStringStringOptionalMap(value map[string]*string) *ShortEventDataHeaders {
	return &ShortEventDataHeaders{typeName: "stringStringOptionalMap", StringStringOptionalMap: value}
}

func (s *ShortEventDataHeaders) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typeName = "string"
		s.String = valueString
		return nil
	}
	var valueStringStringOptionalMap map[string]*string
	if err := json.Unmarshal(data, &valueStringStringOptionalMap); err == nil {
		s.typeName = "stringStringOptionalMap"
		s.StringStringOptionalMap = valueStringStringOptionalMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ShortEventDataHeaders) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return json.Marshal(s.String)
	case "stringStringOptionalMap":
		return json.Marshal(s.StringStringOptionalMap)
	}
}

type ShortEventDataHeadersVisitor interface {
	VisitString(string) error
	VisitStringStringOptionalMap(map[string]*string) error
}

func (s *ShortEventDataHeaders) Accept(visitor ShortEventDataHeadersVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return visitor.VisitString(s.String)
	case "stringStringOptionalMap":
		return visitor.VisitStringStringOptionalMap(s.StringStringOptionalMap)
	}
}

// JSON representation of query params
type ShortEventDataParsedQuery struct {
	typeName                     string
	StringOptional               *string
	ShortEventDataParsedQueryOne *ShortEventDataParsedQueryOne
}

func NewShortEventDataParsedQueryFromStringOptional(value *string) *ShortEventDataParsedQuery {
	return &ShortEventDataParsedQuery{typeName: "stringOptional", StringOptional: value}
}

func NewShortEventDataParsedQueryFromShortEventDataParsedQueryOne(value *ShortEventDataParsedQueryOne) *ShortEventDataParsedQuery {
	return &ShortEventDataParsedQuery{typeName: "shortEventDataParsedQueryOne", ShortEventDataParsedQueryOne: value}
}

func (s *ShortEventDataParsedQuery) UnmarshalJSON(data []byte) error {
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		s.typeName = "stringOptional"
		s.StringOptional = valueStringOptional
		return nil
	}
	valueShortEventDataParsedQueryOne := new(ShortEventDataParsedQueryOne)
	if err := json.Unmarshal(data, &valueShortEventDataParsedQueryOne); err == nil {
		s.typeName = "shortEventDataParsedQueryOne"
		s.ShortEventDataParsedQueryOne = valueShortEventDataParsedQueryOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ShortEventDataParsedQuery) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "stringOptional":
		return json.Marshal(s.StringOptional)
	case "shortEventDataParsedQueryOne":
		return json.Marshal(s.ShortEventDataParsedQueryOne)
	}
}

type ShortEventDataParsedQueryVisitor interface {
	VisitStringOptional(*string) error
	VisitShortEventDataParsedQueryOne(*ShortEventDataParsedQueryOne) error
}

func (s *ShortEventDataParsedQuery) Accept(visitor ShortEventDataParsedQueryVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "stringOptional":
		return visitor.VisitStringOptional(s.StringOptional)
	case "shortEventDataParsedQueryOne":
		return visitor.VisitShortEventDataParsedQueryOne(s.ShortEventDataParsedQueryOne)
	}
}

type ShortEventDataParsedQueryOne struct {
}

// Associated [Source](#source-object) object
type Source struct {
	// ID of the source
	Id string `json:"id"`
	// Name for the source
	Name string `json:"name"`
	// Description of the source
	Description *string `json:"description,omitempty"`
	// ID of the workspace
	TeamId string `json:"team_id"`
	// A unique URL that must be supplied to your webhook's provider
	Url                string                   `json:"url"`
	Verification       *VerificationConfig      `json:"verification,omitempty"`
	AllowedHttpMethods *SourceAllowedHttpMethod `json:"allowed_http_methods,omitempty"`
	CustomResponse     *SourceCustomResponse    `json:"custom_response,omitempty"`
	// Date the source was archived
	ArchivedAt *time.Time `json:"archived_at,omitempty"`
	// Date the source was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the source was created
	CreatedAt time.Time `json:"created_at"`
}

// List of allowed HTTP methods. Defaults to PUT, POST, PATCH, DELETE.
type SourceAllowedHttpMethod = []SourceAllowedHttpMethodItem

type SourceAllowedHttpMethodItem string

const (
	SourceAllowedHttpMethodItemGet    SourceAllowedHttpMethodItem = "GET"
	SourceAllowedHttpMethodItemPost   SourceAllowedHttpMethodItem = "POST"
	SourceAllowedHttpMethodItemPut    SourceAllowedHttpMethodItem = "PUT"
	SourceAllowedHttpMethodItemPatch  SourceAllowedHttpMethodItem = "PATCH"
	SourceAllowedHttpMethodItemDelete SourceAllowedHttpMethodItem = "DELETE"
)

func NewSourceAllowedHttpMethodItemFromString(s string) (SourceAllowedHttpMethodItem, error) {
	switch s {
	case "GET":
		return SourceAllowedHttpMethodItemGet, nil
	case "POST":
		return SourceAllowedHttpMethodItemPost, nil
	case "PUT":
		return SourceAllowedHttpMethodItemPut, nil
	case "PATCH":
		return SourceAllowedHttpMethodItemPatch, nil
	case "DELETE":
		return SourceAllowedHttpMethodItemDelete, nil
	}
	var t SourceAllowedHttpMethodItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SourceAllowedHttpMethodItem) Ptr() *SourceAllowedHttpMethodItem {
	return &s
}

// Custom response object
type SourceCustomResponse struct {
	ContentType SourceCustomResponseContentType `json:"content_type,omitempty"`
	// Body of the custom response <span style="white-space: nowrap">`<= 1000 characters`</span>
	Body string `json:"body"`
}

// Content type of the custom response
type SourceCustomResponseContentType string

const (
	SourceCustomResponseContentTypeJson SourceCustomResponseContentType = "json"
	SourceCustomResponseContentTypeText SourceCustomResponseContentType = "text"
	SourceCustomResponseContentTypeXml  SourceCustomResponseContentType = "xml"
)

func NewSourceCustomResponseContentTypeFromString(s string) (SourceCustomResponseContentType, error) {
	switch s {
	case "json":
		return SourceCustomResponseContentTypeJson, nil
	case "text":
		return SourceCustomResponseContentTypeText, nil
	case "xml":
		return SourceCustomResponseContentTypeXml, nil
	}
	var t SourceCustomResponseContentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SourceCustomResponseContentType) Ptr() *SourceCustomResponseContentType {
	return &s
}

type SourceDeleteResponse struct {
	// ID of the source
	Id string `json:"id"`
}

type SourceListRequestDir string

const (
	SourceListRequestDirAsc  SourceListRequestDir = "asc"
	SourceListRequestDirDesc SourceListRequestDir = "desc"
)

func NewSourceListRequestDirFromString(s string) (SourceListRequestDir, error) {
	switch s {
	case "asc":
		return SourceListRequestDirAsc, nil
	case "desc":
		return SourceListRequestDirDesc, nil
	}
	var t SourceListRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SourceListRequestDir) Ptr() *SourceListRequestDir {
	return &s
}

type SourcePaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Source       `json:"models,omitempty"`
}

type ToggleWebhookNotifications struct {
	Enabled  bool          `json:"enabled"`
	Topics   []TopicsValue `json:"topics,omitempty"`
	SourceId string        `json:"source_id"`
}

// Supported topics
type TopicsValue string

const (
	TopicsValueIssueOpened             TopicsValue = "issue.opened"
	TopicsValueIssueUpdated            TopicsValue = "issue.updated"
	TopicsValueDeprecatedAttemptFailed TopicsValue = "deprecated.attempt-failed"
	TopicsValueEventSuccessful         TopicsValue = "event.successful"
)

func NewTopicsValueFromString(s string) (TopicsValue, error) {
	switch s {
	case "issue.opened":
		return TopicsValueIssueOpened, nil
	case "issue.updated":
		return TopicsValueIssueUpdated, nil
	case "deprecated.attempt-failed":
		return TopicsValueDeprecatedAttemptFailed, nil
	case "event.successful":
		return TopicsValueEventSuccessful, nil
	}
	var t TopicsValue
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TopicsValue) Ptr() *TopicsValue {
	return &t
}

type TransformFull struct {
	// ID of the attached transformation object. Optional input, always set once the rule is defined
	TransformationId *string `json:"transformation_id,omitempty"`
	// You can optionally define a new transformation while creating a transform rule
	Transformation *TransformFullTransformation `json:"transformation,omitempty"`
	type_          string
}

func (t *TransformFull) Type() string {
	return t.type_
}

func (t *TransformFull) UnmarshalJSON(data []byte) error {
	type unmarshaler TransformFull
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransformFull(value)
	t.type_ = "transform"
	return nil
}

func (t *TransformFull) MarshalJSON() ([]byte, error) {
	type embed TransformFull
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "transform",
	}
	return json.Marshal(marshaler)
}

// You can optionally define a new transformation while creating a transform rule
type TransformFullTransformation struct {
	// The unique name of the transformation
	Name string `json:"name"`
	// A string representation of your JavaScript (ES6) code to run
	Code string `json:"code"`
	// A key-value object of environment variables to encrypt and expose to your transformation code
	Env map[string]*string `json:"env,omitempty"`
}

type TransformReference struct {
	// ID of the attached transformation object. Optional input, always set once the rule is defined
	TransformationId string `json:"transformation_id"`
	type_            string
}

func (t *TransformReference) Type() string {
	return t.type_
}

func (t *TransformReference) UnmarshalJSON(data []byte) error {
	type unmarshaler TransformReference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransformReference(value)
	t.type_ = "transform"
	return nil
}

func (t *TransformReference) MarshalJSON() ([]byte, error) {
	type embed TransformReference
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "transform",
	}
	return json.Marshal(marshaler)
}

type TransformRule struct {
	typeName           string
	TransformReference *TransformReference
	TransformFull      *TransformFull
}

func NewTransformRuleFromTransformReference(value *TransformReference) *TransformRule {
	return &TransformRule{typeName: "transformReference", TransformReference: value}
}

func NewTransformRuleFromTransformFull(value *TransformFull) *TransformRule {
	return &TransformRule{typeName: "transformFull", TransformFull: value}
}

func (t *TransformRule) UnmarshalJSON(data []byte) error {
	valueTransformReference := new(TransformReference)
	if err := json.Unmarshal(data, &valueTransformReference); err == nil {
		t.typeName = "transformReference"
		t.TransformReference = valueTransformReference
		return nil
	}
	valueTransformFull := new(TransformFull)
	if err := json.Unmarshal(data, &valueTransformFull); err == nil {
		t.typeName = "transformFull"
		t.TransformFull = valueTransformFull
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransformRule) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transformReference":
		return json.Marshal(t.TransformReference)
	case "transformFull":
		return json.Marshal(t.TransformFull)
	}
}

type TransformRuleVisitor interface {
	VisitTransformReference(*TransformReference) error
	VisitTransformFull(*TransformFull) error
}

func (t *TransformRule) Accept(visitor TransformRuleVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transformReference":
		return visitor.VisitTransformReference(t.TransformReference)
	case "transformFull":
		return visitor.VisitTransformFull(t.TransformFull)
	}
}

type Transformation struct {
	// ID of the transformation
	Id string `json:"id"`
	// ID of the workspace
	TeamId string `json:"team_id"`
	// A unique, human-friendly name for the transformation
	Name string `json:"name"`
	// JavaScript code to be executed
	Code         string  `json:"code"`
	EncryptedEnv *string `json:"encrypted_env,omitempty"`
	Iv           *string `json:"iv,omitempty"`
	// Key-value environment variables to be passed to the transformation
	Env map[string]*string `json:"env,omitempty"`
	// Date the transformation was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the transformation was created
	CreatedAt time.Time `json:"created_at"`
}

type TransformationExecution struct {
	Id                     string                          `json:"id"`
	TransformedEventDataId string                          `json:"transformed_event_data_id"`
	OriginalEventDataId    string                          `json:"original_event_data_id"`
	TransformationId       string                          `json:"transformation_id"`
	TeamId                 string                          `json:"team_id"`
	WebhookId              string                          `json:"webhook_id"`
	LogLevel               TransformationExecutionLogLevel `json:"log_level,omitempty"`
	Logs                   []*ConsoleLine                  `json:"logs,omitempty"`
	UpdatedAt              time.Time                       `json:"updated_at"`
	CreatedAt              time.Time                       `json:"created_at"`
	OriginalEventData      *ShortEventData                 `json:"original_event_data,omitempty"`
	TransformedEventData   *ShortEventData                 `json:"transformed_event_data,omitempty"`
	IssueId                *string                         `json:"issue_id,omitempty"`
}

// The minimum log level to open the issue on
type TransformationExecutionLogLevel string

const (
	TransformationExecutionLogLevelDebug TransformationExecutionLogLevel = "debug"
	TransformationExecutionLogLevelInfo  TransformationExecutionLogLevel = "info"
	TransformationExecutionLogLevelWarn  TransformationExecutionLogLevel = "warn"
	TransformationExecutionLogLevelError TransformationExecutionLogLevel = "error"
	TransformationExecutionLogLevelFatal TransformationExecutionLogLevel = "fatal"
)

func NewTransformationExecutionLogLevelFromString(s string) (TransformationExecutionLogLevel, error) {
	switch s {
	case "debug":
		return TransformationExecutionLogLevelDebug, nil
	case "info":
		return TransformationExecutionLogLevelInfo, nil
	case "warn":
		return TransformationExecutionLogLevelWarn, nil
	case "error":
		return TransformationExecutionLogLevelError, nil
	case "fatal":
		return TransformationExecutionLogLevelFatal, nil
	}
	var t TransformationExecutionLogLevel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransformationExecutionLogLevel) Ptr() *TransformationExecutionLogLevel {
	return &t
}

type TransformationExecutionPaginatedResult struct {
	Pagination *SeekPagination            `json:"pagination,omitempty"`
	Count      *int                       `json:"count,omitempty"`
	Models     []*TransformationExecution `json:"models,omitempty"`
}

type TransformationExecutorOutput struct {
	RequestId        *string                              `json:"request_id,omitempty"`
	TransformationId *string                              `json:"transformation_id,omitempty"`
	ExecutionId      *string                              `json:"execution_id,omitempty"`
	LogLevel         TransformationExecutionLogLevel      `json:"log_level,omitempty"`
	Request          *TransformationExecutorOutputRequest `json:"request,omitempty"`
	Console          []*ConsoleLine                       `json:"console,omitempty"`
}

type TransformationExecutorOutputRequest struct {
	Headers     *TransformationExecutorOutputRequestHeaders     `json:"headers,omitempty"`
	Path        string                                          `json:"path"`
	Query       *TransformationExecutorOutputRequestQuery       `json:"query,omitempty"`
	ParsedQuery *TransformationExecutorOutputRequestParsedQuery `json:"parsed_query,omitempty"`
	Body        *TransformationExecutorOutputRequestBody        `json:"body,omitempty"`
}

type TransformationExecutorOutputRequestBody struct {
	typeName                                   string
	StringOptional                             *string
	TransformationExecutorOutputRequestBodyOne *TransformationExecutorOutputRequestBodyOne
}

func NewTransformationExecutorOutputRequestBodyFromStringOptional(value *string) *TransformationExecutorOutputRequestBody {
	return &TransformationExecutorOutputRequestBody{typeName: "stringOptional", StringOptional: value}
}

func NewTransformationExecutorOutputRequestBodyFromTransformationExecutorOutputRequestBodyOne(value *TransformationExecutorOutputRequestBodyOne) *TransformationExecutorOutputRequestBody {
	return &TransformationExecutorOutputRequestBody{typeName: "transformationExecutorOutputRequestBodyOne", TransformationExecutorOutputRequestBodyOne: value}
}

func (t *TransformationExecutorOutputRequestBody) UnmarshalJSON(data []byte) error {
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		t.typeName = "stringOptional"
		t.StringOptional = valueStringOptional
		return nil
	}
	valueTransformationExecutorOutputRequestBodyOne := new(TransformationExecutorOutputRequestBodyOne)
	if err := json.Unmarshal(data, &valueTransformationExecutorOutputRequestBodyOne); err == nil {
		t.typeName = "transformationExecutorOutputRequestBodyOne"
		t.TransformationExecutorOutputRequestBodyOne = valueTransformationExecutorOutputRequestBodyOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransformationExecutorOutputRequestBody) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "stringOptional":
		return json.Marshal(t.StringOptional)
	case "transformationExecutorOutputRequestBodyOne":
		return json.Marshal(t.TransformationExecutorOutputRequestBodyOne)
	}
}

type TransformationExecutorOutputRequestBodyVisitor interface {
	VisitStringOptional(*string) error
	VisitTransformationExecutorOutputRequestBodyOne(*TransformationExecutorOutputRequestBodyOne) error
}

func (t *TransformationExecutorOutputRequestBody) Accept(visitor TransformationExecutorOutputRequestBodyVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "stringOptional":
		return visitor.VisitStringOptional(t.StringOptional)
	case "transformationExecutorOutputRequestBodyOne":
		return visitor.VisitTransformationExecutorOutputRequestBodyOne(t.TransformationExecutorOutputRequestBodyOne)
	}
}

type TransformationExecutorOutputRequestBodyOne struct {
}

type TransformationExecutorOutputRequestHeaders struct {
	typeName         string
	String           string
	StringUnknownMap map[string]interface{}
}

func NewTransformationExecutorOutputRequestHeadersFromString(value string) *TransformationExecutorOutputRequestHeaders {
	return &TransformationExecutorOutputRequestHeaders{typeName: "string", String: value}
}

func NewTransformationExecutorOutputRequestHeadersFromStringUnknownMap(value map[string]interface{}) *TransformationExecutorOutputRequestHeaders {
	return &TransformationExecutorOutputRequestHeaders{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func (t *TransformationExecutorOutputRequestHeaders) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		t.typeName = "stringUnknownMap"
		t.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransformationExecutorOutputRequestHeaders) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "stringUnknownMap":
		return json.Marshal(t.StringUnknownMap)
	}
}

type TransformationExecutorOutputRequestHeadersVisitor interface {
	VisitString(string) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (t *TransformationExecutorOutputRequestHeaders) Accept(visitor TransformationExecutorOutputRequestHeadersVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(t.StringUnknownMap)
	}
}

type TransformationExecutorOutputRequestParsedQuery struct {
	typeName                                          string
	StringOptional                                    *string
	TransformationExecutorOutputRequestParsedQueryOne *TransformationExecutorOutputRequestParsedQueryOne
}

func NewTransformationExecutorOutputRequestParsedQueryFromStringOptional(value *string) *TransformationExecutorOutputRequestParsedQuery {
	return &TransformationExecutorOutputRequestParsedQuery{typeName: "stringOptional", StringOptional: value}
}

func NewTransformationExecutorOutputRequestParsedQueryFromTransformationExecutorOutputRequestParsedQueryOne(value *TransformationExecutorOutputRequestParsedQueryOne) *TransformationExecutorOutputRequestParsedQuery {
	return &TransformationExecutorOutputRequestParsedQuery{typeName: "transformationExecutorOutputRequestParsedQueryOne", TransformationExecutorOutputRequestParsedQueryOne: value}
}

func (t *TransformationExecutorOutputRequestParsedQuery) UnmarshalJSON(data []byte) error {
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		t.typeName = "stringOptional"
		t.StringOptional = valueStringOptional
		return nil
	}
	valueTransformationExecutorOutputRequestParsedQueryOne := new(TransformationExecutorOutputRequestParsedQueryOne)
	if err := json.Unmarshal(data, &valueTransformationExecutorOutputRequestParsedQueryOne); err == nil {
		t.typeName = "transformationExecutorOutputRequestParsedQueryOne"
		t.TransformationExecutorOutputRequestParsedQueryOne = valueTransformationExecutorOutputRequestParsedQueryOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransformationExecutorOutputRequestParsedQuery) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "stringOptional":
		return json.Marshal(t.StringOptional)
	case "transformationExecutorOutputRequestParsedQueryOne":
		return json.Marshal(t.TransformationExecutorOutputRequestParsedQueryOne)
	}
}

type TransformationExecutorOutputRequestParsedQueryVisitor interface {
	VisitStringOptional(*string) error
	VisitTransformationExecutorOutputRequestParsedQueryOne(*TransformationExecutorOutputRequestParsedQueryOne) error
}

func (t *TransformationExecutorOutputRequestParsedQuery) Accept(visitor TransformationExecutorOutputRequestParsedQueryVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "stringOptional":
		return visitor.VisitStringOptional(t.StringOptional)
	case "transformationExecutorOutputRequestParsedQueryOne":
		return visitor.VisitTransformationExecutorOutputRequestParsedQueryOne(t.TransformationExecutorOutputRequestParsedQueryOne)
	}
}

type TransformationExecutorOutputRequestParsedQueryOne struct {
}

type TransformationExecutorOutputRequestQuery struct {
	typeName                                             string
	TransformationExecutorOutputRequestQueryZeroOptional *TransformationExecutorOutputRequestQueryZero
	String                                               string
}

func NewTransformationExecutorOutputRequestQueryFromTransformationExecutorOutputRequestQueryZeroOptional(value *TransformationExecutorOutputRequestQueryZero) *TransformationExecutorOutputRequestQuery {
	return &TransformationExecutorOutputRequestQuery{typeName: "transformationExecutorOutputRequestQueryZeroOptional", TransformationExecutorOutputRequestQueryZeroOptional: value}
}

func NewTransformationExecutorOutputRequestQueryFromString(value string) *TransformationExecutorOutputRequestQuery {
	return &TransformationExecutorOutputRequestQuery{typeName: "string", String: value}
}

func (t *TransformationExecutorOutputRequestQuery) UnmarshalJSON(data []byte) error {
	var valueTransformationExecutorOutputRequestQueryZeroOptional *TransformationExecutorOutputRequestQueryZero
	if err := json.Unmarshal(data, &valueTransformationExecutorOutputRequestQueryZeroOptional); err == nil {
		t.typeName = "transformationExecutorOutputRequestQueryZeroOptional"
		t.TransformationExecutorOutputRequestQueryZeroOptional = valueTransformationExecutorOutputRequestQueryZeroOptional
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransformationExecutorOutputRequestQuery) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transformationExecutorOutputRequestQueryZeroOptional":
		return json.Marshal(t.TransformationExecutorOutputRequestQueryZeroOptional)
	case "string":
		return json.Marshal(t.String)
	}
}

type TransformationExecutorOutputRequestQueryVisitor interface {
	VisitTransformationExecutorOutputRequestQueryZeroOptional(*TransformationExecutorOutputRequestQueryZero) error
	VisitString(string) error
}

func (t *TransformationExecutorOutputRequestQuery) Accept(visitor TransformationExecutorOutputRequestQueryVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transformationExecutorOutputRequestQueryZeroOptional":
		return visitor.VisitTransformationExecutorOutputRequestQueryZeroOptional(t.TransformationExecutorOutputRequestQueryZeroOptional)
	case "string":
		return visitor.VisitString(t.String)
	}
}

type TransformationExecutorOutputRequestQueryZero struct {
}

type TransformationFailedMeta struct {
	TransformationId string `json:"transformation_id"`
}

// Transformation issue
type TransformationIssue struct {
	// Issue ID
	Id string `json:"id"`
	// ID of the workspace
	TeamId string      `json:"team_id"`
	Status IssueStatus `json:"status,omitempty"`
	// ISO timestamp for when the issue was last opened
	OpenedAt time.Time `json:"opened_at"`
	// ISO timestamp for when the issue was first opened
	FirstSeenAt time.Time `json:"first_seen_at"`
	// ISO timestamp for when the issue last occured
	LastSeenAt time.Time `json:"last_seen_at"`
	// ID of the team member who last updated the issue status
	LastUpdatedBy *string `json:"last_updated_by,omitempty"`
	// ISO timestamp for when the issue was dismissed
	DismissedAt    *time.Time `json:"dismissed_at,omitempty"`
	AutoResolvedAt *time.Time `json:"auto_resolved_at,omitempty"`
	MergedWith     *string    `json:"merged_with,omitempty"`
	// ISO timestamp for when the issue was last updated
	UpdatedAt string `json:"updated_at"`
	// ISO timestamp for when the issue was created
	CreatedAt       string                              `json:"created_at"`
	AggregationKeys *TransformationIssueAggregationKeys `json:"aggregation_keys,omitempty"`
	Reference       *TransformationIssueReference       `json:"reference,omitempty"`
	type_           string
}

func (t *TransformationIssue) Type() string {
	return t.type_
}

func (t *TransformationIssue) UnmarshalJSON(data []byte) error {
	type unmarshaler TransformationIssue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransformationIssue(value)
	t.type_ = "transformation"
	return nil
}

func (t *TransformationIssue) MarshalJSON() ([]byte, error) {
	type embed TransformationIssue
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "transformation",
	}
	return json.Marshal(marshaler)
}

// Keys used as the aggregation keys a 'transformation' type issue
type TransformationIssueAggregationKeys struct {
	TransformationId []string                        `json:"transformation_id,omitempty"`
	LogLevel         TransformationExecutionLogLevel `json:"log_level,omitempty"`
}

// Transformation issue data
type TransformationIssueData struct {
	TransformationExecution *TransformationExecution `json:"transformation_execution,omitempty"`
	TriggerAttempt          *EventAttempt            `json:"trigger_attempt,omitempty"`
}

// Reference to the event request transformation an issue is being created for.
type TransformationIssueReference struct {
	TransformationExecutionId string `json:"transformation_execution_id"`
	// Deprecated but still found on historical issues
	TriggerEventRequestTransformationId *string `json:"trigger_event_request_transformation_id,omitempty"`
}

// Transformation issue
type TransformationIssueWithData struct {
	// Issue ID
	Id string `json:"id"`
	// ID of the workspace
	TeamId string      `json:"team_id"`
	Status IssueStatus `json:"status,omitempty"`
	// ISO timestamp for when the issue was last opened
	OpenedAt time.Time `json:"opened_at"`
	// ISO timestamp for when the issue was first opened
	FirstSeenAt time.Time `json:"first_seen_at"`
	// ISO timestamp for when the issue last occured
	LastSeenAt time.Time `json:"last_seen_at"`
	// ID of the team member who last updated the issue status
	LastUpdatedBy *string `json:"last_updated_by,omitempty"`
	// ISO timestamp for when the issue was dismissed
	DismissedAt    *time.Time `json:"dismissed_at,omitempty"`
	AutoResolvedAt *time.Time `json:"auto_resolved_at,omitempty"`
	MergedWith     *string    `json:"merged_with,omitempty"`
	// ISO timestamp for when the issue was last updated
	UpdatedAt string `json:"updated_at"`
	// ISO timestamp for when the issue was created
	CreatedAt       string                              `json:"created_at"`
	AggregationKeys *TransformationIssueAggregationKeys `json:"aggregation_keys,omitempty"`
	Reference       *TransformationIssueReference       `json:"reference,omitempty"`
	Data            *TransformationIssueData            `json:"data,omitempty"`
	type_           string
}

func (t *TransformationIssueWithData) Type() string {
	return t.type_
}

func (t *TransformationIssueWithData) UnmarshalJSON(data []byte) error {
	type unmarshaler TransformationIssueWithData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransformationIssueWithData(value)
	t.type_ = "transformation"
	return nil
}

func (t *TransformationIssueWithData) MarshalJSON() ([]byte, error) {
	type embed TransformationIssueWithData
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "transformation",
	}
	return json.Marshal(marshaler)
}

type TransformationListExecutionRequestDir string

const (
	TransformationListExecutionRequestDirAsc  TransformationListExecutionRequestDir = "asc"
	TransformationListExecutionRequestDirDesc TransformationListExecutionRequestDir = "desc"
)

func NewTransformationListExecutionRequestDirFromString(s string) (TransformationListExecutionRequestDir, error) {
	switch s {
	case "asc":
		return TransformationListExecutionRequestDirAsc, nil
	case "desc":
		return TransformationListExecutionRequestDirDesc, nil
	}
	var t TransformationListExecutionRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransformationListExecutionRequestDir) Ptr() *TransformationListExecutionRequestDir {
	return &t
}

type TransformationListExecutionRequestLogLevel string

const (
	TransformationListExecutionRequestLogLevelDebug TransformationListExecutionRequestLogLevel = "debug"
	TransformationListExecutionRequestLogLevelInfo  TransformationListExecutionRequestLogLevel = "info"
	TransformationListExecutionRequestLogLevelWarn  TransformationListExecutionRequestLogLevel = "warn"
	TransformationListExecutionRequestLogLevelError TransformationListExecutionRequestLogLevel = "error"
	TransformationListExecutionRequestLogLevelFatal TransformationListExecutionRequestLogLevel = "fatal"
)

func NewTransformationListExecutionRequestLogLevelFromString(s string) (TransformationListExecutionRequestLogLevel, error) {
	switch s {
	case "debug":
		return TransformationListExecutionRequestLogLevelDebug, nil
	case "info":
		return TransformationListExecutionRequestLogLevelInfo, nil
	case "warn":
		return TransformationListExecutionRequestLogLevelWarn, nil
	case "error":
		return TransformationListExecutionRequestLogLevelError, nil
	case "fatal":
		return TransformationListExecutionRequestLogLevelFatal, nil
	}
	var t TransformationListExecutionRequestLogLevel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransformationListExecutionRequestLogLevel) Ptr() *TransformationListExecutionRequestLogLevel {
	return &t
}

type TransformationListRequestDir string

const (
	TransformationListRequestDirAsc  TransformationListRequestDir = "asc"
	TransformationListRequestDirDesc TransformationListRequestDir = "desc"
)

func NewTransformationListRequestDirFromString(s string) (TransformationListRequestDir, error) {
	switch s {
	case "asc":
		return TransformationListRequestDirAsc, nil
	case "desc":
		return TransformationListRequestDirDesc, nil
	}
	var t TransformationListRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransformationListRequestDir) Ptr() *TransformationListRequestDir {
	return &t
}

type TransformationPaginatedResult struct {
	Pagination *SeekPagination   `json:"pagination,omitempty"`
	Count      *int              `json:"count,omitempty"`
	Models     []*Transformation `json:"models,omitempty"`
}

// Request input to use for the transformation execution
type TransformationRunRequestRequest struct {
	// Headers of the request
	Headers map[string]string `json:"headers,omitempty"`
	// Body of the request
	Body *TransformationRunRequestRequestBody `json:"body,omitempty"`
	// Path of the request
	Path *string `json:"path,omitempty"`
	// String representation of the query params of the request
	Query *string `json:"query,omitempty"`
	// JSON representation of the query params
	ParsedQuery *TransformationRunRequestRequestParsedQuery `json:"parsed_query,omitempty"`
}

// Body of the request
type TransformationRunRequestRequestBody struct {
	typeName                                string
	TransformationRunRequestRequestBodyZero *TransformationRunRequestRequestBodyZero
	String                                  string
}

func NewTransformationRunRequestRequestBodyFromTransformationRunRequestRequestBodyZero(value *TransformationRunRequestRequestBodyZero) *TransformationRunRequestRequestBody {
	return &TransformationRunRequestRequestBody{typeName: "transformationRunRequestRequestBodyZero", TransformationRunRequestRequestBodyZero: value}
}

func NewTransformationRunRequestRequestBodyFromString(value string) *TransformationRunRequestRequestBody {
	return &TransformationRunRequestRequestBody{typeName: "string", String: value}
}

func (t *TransformationRunRequestRequestBody) UnmarshalJSON(data []byte) error {
	valueTransformationRunRequestRequestBodyZero := new(TransformationRunRequestRequestBodyZero)
	if err := json.Unmarshal(data, &valueTransformationRunRequestRequestBodyZero); err == nil {
		t.typeName = "transformationRunRequestRequestBodyZero"
		t.TransformationRunRequestRequestBodyZero = valueTransformationRunRequestRequestBodyZero
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransformationRunRequestRequestBody) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transformationRunRequestRequestBodyZero":
		return json.Marshal(t.TransformationRunRequestRequestBodyZero)
	case "string":
		return json.Marshal(t.String)
	}
}

type TransformationRunRequestRequestBodyVisitor interface {
	VisitTransformationRunRequestRequestBodyZero(*TransformationRunRequestRequestBodyZero) error
	VisitString(string) error
}

func (t *TransformationRunRequestRequestBody) Accept(visitor TransformationRunRequestRequestBodyVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transformationRunRequestRequestBodyZero":
		return visitor.VisitTransformationRunRequestRequestBodyZero(t.TransformationRunRequestRequestBodyZero)
	case "string":
		return visitor.VisitString(t.String)
	}
}

type TransformationRunRequestRequestBodyZero struct {
}

// JSON representation of the query params
type TransformationRunRequestRequestParsedQuery struct {
}

type Verification3DEye struct {
	Configs *Verification3DEyeConfigs `json:"configs,omitempty"`
	type_   string
}

func (v *Verification3DEye) Type() string {
	return v.type_
}

func (v *Verification3DEye) UnmarshalJSON(data []byte) error {
	type unmarshaler Verification3DEye
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = Verification3DEye(value)
	v.type_ = "three_d_eye"
	return nil
}

func (v *Verification3DEye) MarshalJSON() ([]byte, error) {
	type embed Verification3DEye
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*v),
		Type:  "three_d_eye",
	}
	return json.Marshal(marshaler)
}

// The verification configs for 3dEye. Only included if the ?include=verification.configs query param is present
type Verification3DEyeConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationAdyen struct {
	Configs *VerificationAdyenConfigs `json:"configs,omitempty"`
	type_   string
}

func (v *VerificationAdyen) Type() string {
	return v.type_
}

func (v *VerificationAdyen) UnmarshalJSON(data []byte) error {
	type unmarshaler VerificationAdyen
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VerificationAdyen(value)
	v.type_ = "adyen"
	return nil
}

func (v *VerificationAdyen) MarshalJSON() ([]byte, error) {
	type embed VerificationAdyen
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*v),
		Type:  "adyen",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Adyen. Only included if the ?include=verification.configs query param is present
type VerificationAdyenConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationAkeneo struct {
	Configs *VerificationAkeneoConfigs `json:"configs,omitempty"`
	type_   string
}

func (v *VerificationAkeneo) Type() string {
	return v.type_
}

func (v *VerificationAkeneo) UnmarshalJSON(data []byte) error {
	type unmarshaler VerificationAkeneo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VerificationAkeneo(value)
	v.type_ = "akeneo"
	return nil
}

func (v *VerificationAkeneo) MarshalJSON() ([]byte, error) {
	type embed VerificationAkeneo
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*v),
		Type:  "akeneo",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Akeneo. Only included if the ?include=verification.configs query param is present
type VerificationAkeneoConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationApiKey struct {
	Configs *VerificationApiKeyConfigs `json:"configs,omitempty"`
	type_   string
}

func (v *VerificationApiKey) Type() string {
	return v.type_
}

func (v *VerificationApiKey) UnmarshalJSON(data []byte) error {
	type unmarshaler VerificationApiKey
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VerificationApiKey(value)
	v.type_ = "api_key"
	return nil
}

func (v *VerificationApiKey) MarshalJSON() ([]byte, error) {
	type embed VerificationApiKey
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*v),
		Type:  "api_key",
	}
	return json.Marshal(marshaler)
}

// The verification configs for API Key. Only included if the ?include=verification.configs query param is present
type VerificationApiKeyConfigs struct {
	HeaderKey string `json:"header_key"`
	ApiKey    string `json:"api_key"`
}

type VerificationAwssns struct {
	Configs *VerificationAwssnsConfigs `json:"configs,omitempty"`
	type_   string
}

func (v *VerificationAwssns) Type() string {
	return v.type_
}

func (v *VerificationAwssns) UnmarshalJSON(data []byte) error {
	type unmarshaler VerificationAwssns
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VerificationAwssns(value)
	v.type_ = "aws_sns"
	return nil
}

func (v *VerificationAwssns) MarshalJSON() ([]byte, error) {
	type embed VerificationAwssns
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*v),
		Type:  "aws_sns",
	}
	return json.Marshal(marshaler)
}

// The verification configs for AWS SNS. Only included if the ?include=verification.configs query param is present
type VerificationAwssnsConfigs struct {
}

type VerificationBasicAuth struct {
	Configs *VerificationBasicAuthConfigs `json:"configs,omitempty"`
	type_   string
}

func (v *VerificationBasicAuth) Type() string {
	return v.type_
}

func (v *VerificationBasicAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler VerificationBasicAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VerificationBasicAuth(value)
	v.type_ = "basic_auth"
	return nil
}

func (v *VerificationBasicAuth) MarshalJSON() ([]byte, error) {
	type embed VerificationBasicAuth
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*v),
		Type:  "basic_auth",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Basic Auth. Only included if the ?include=verification.configs query param is present
type VerificationBasicAuthConfigs struct {
	Name     string `json:"name"`
	Password string `json:"password"`
}

type VerificationCommercelayer struct {
	Configs *VerificationCommercelayerConfigs `json:"configs,omitempty"`
	type_   string
}

func (v *VerificationCommercelayer) Type() string {
	return v.type_
}

func (v *VerificationCommercelayer) UnmarshalJSON(data []byte) error {
	type unmarshaler VerificationCommercelayer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VerificationCommercelayer(value)
	v.type_ = "commercelayer"
	return nil
}

func (v *VerificationCommercelayer) MarshalJSON() ([]byte, error) {
	type embed VerificationCommercelayer
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*v),
		Type:  "commercelayer",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Commercelayer. Only included if the ?include=verification.configs query param is present
type VerificationCommercelayerConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

// The verification configs for the specific verification type
type VerificationConfig struct {
	typeName                   string
	VerificationHmac           *VerificationHmac
	VerificationBasicAuth      *VerificationBasicAuth
	VerificationApiKey         *VerificationApiKey
	VerificationTwitter        *VerificationTwitter
	VerificationStripe         *VerificationStripe
	VerificationRecharge       *VerificationRecharge
	VerificationGitHub         *VerificationGitHub
	VerificationShopify        *VerificationShopify
	VerificationPostmark       *VerificationPostmark
	VerificationTypeform       *VerificationTypeform
	VerificationXero           *VerificationXero
	VerificationSvix           *VerificationSvix
	VerificationZoom           *VerificationZoom
	VerificationAkeneo         *VerificationAkeneo
	VerificationAdyen          *VerificationAdyen
	VerificationGitLab         *VerificationGitLab
	VerificationPropertyFinder *VerificationPropertyFinder
	VerificationWooCommerce    *VerificationWooCommerce
	VerificationOura           *VerificationOura
	VerificationCommercelayer  *VerificationCommercelayer
	VerificationMailgun        *VerificationMailgun
	VerificationPipedrive      *VerificationPipedrive
	VerificationSendGrid       *VerificationSendGrid
	VerificationWorkOs         *VerificationWorkOs
	VerificationSynctera       *VerificationSynctera
	VerificationAwssns         *VerificationAwssns
	Verification3DEye          *Verification3DEye
}

func NewVerificationConfigFromVerificationHmac(value *VerificationHmac) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationHmac", VerificationHmac: value}
}

func NewVerificationConfigFromVerificationBasicAuth(value *VerificationBasicAuth) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationBasicAuth", VerificationBasicAuth: value}
}

func NewVerificationConfigFromVerificationApiKey(value *VerificationApiKey) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationApiKey", VerificationApiKey: value}
}

func NewVerificationConfigFromVerificationTwitter(value *VerificationTwitter) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationTwitter", VerificationTwitter: value}
}

func NewVerificationConfigFromVerificationStripe(value *VerificationStripe) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationStripe", VerificationStripe: value}
}

func NewVerificationConfigFromVerificationRecharge(value *VerificationRecharge) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationRecharge", VerificationRecharge: value}
}

func NewVerificationConfigFromVerificationGitHub(value *VerificationGitHub) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationGitHub", VerificationGitHub: value}
}

func NewVerificationConfigFromVerificationShopify(value *VerificationShopify) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationShopify", VerificationShopify: value}
}

func NewVerificationConfigFromVerificationPostmark(value *VerificationPostmark) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationPostmark", VerificationPostmark: value}
}

func NewVerificationConfigFromVerificationTypeform(value *VerificationTypeform) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationTypeform", VerificationTypeform: value}
}

func NewVerificationConfigFromVerificationXero(value *VerificationXero) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationXero", VerificationXero: value}
}

func NewVerificationConfigFromVerificationSvix(value *VerificationSvix) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationSvix", VerificationSvix: value}
}

func NewVerificationConfigFromVerificationZoom(value *VerificationZoom) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationZoom", VerificationZoom: value}
}

func NewVerificationConfigFromVerificationAkeneo(value *VerificationAkeneo) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationAkeneo", VerificationAkeneo: value}
}

func NewVerificationConfigFromVerificationAdyen(value *VerificationAdyen) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationAdyen", VerificationAdyen: value}
}

func NewVerificationConfigFromVerificationGitLab(value *VerificationGitLab) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationGitLab", VerificationGitLab: value}
}

func NewVerificationConfigFromVerificationPropertyFinder(value *VerificationPropertyFinder) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationPropertyFinder", VerificationPropertyFinder: value}
}

func NewVerificationConfigFromVerificationWooCommerce(value *VerificationWooCommerce) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationWooCommerce", VerificationWooCommerce: value}
}

func NewVerificationConfigFromVerificationOura(value *VerificationOura) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationOura", VerificationOura: value}
}

func NewVerificationConfigFromVerificationCommercelayer(value *VerificationCommercelayer) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationCommercelayer", VerificationCommercelayer: value}
}

func NewVerificationConfigFromVerificationMailgun(value *VerificationMailgun) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationMailgun", VerificationMailgun: value}
}

func NewVerificationConfigFromVerificationPipedrive(value *VerificationPipedrive) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationPipedrive", VerificationPipedrive: value}
}

func NewVerificationConfigFromVerificationSendGrid(value *VerificationSendGrid) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationSendGrid", VerificationSendGrid: value}
}

func NewVerificationConfigFromVerificationWorkOs(value *VerificationWorkOs) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationWorkOs", VerificationWorkOs: value}
}

func NewVerificationConfigFromVerificationSynctera(value *VerificationSynctera) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationSynctera", VerificationSynctera: value}
}

func NewVerificationConfigFromVerificationAwssns(value *VerificationAwssns) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationAwssns", VerificationAwssns: value}
}

func NewVerificationConfigFromVerification3DEye(value *Verification3DEye) *VerificationConfig {
	return &VerificationConfig{typeName: "verification3DEye", Verification3DEye: value}
}

func (v *VerificationConfig) UnmarshalJSON(data []byte) error {
	valueVerificationHmac := new(VerificationHmac)
	if err := json.Unmarshal(data, &valueVerificationHmac); err == nil {
		v.typeName = "verificationHmac"
		v.VerificationHmac = valueVerificationHmac
		return nil
	}
	valueVerificationBasicAuth := new(VerificationBasicAuth)
	if err := json.Unmarshal(data, &valueVerificationBasicAuth); err == nil {
		v.typeName = "verificationBasicAuth"
		v.VerificationBasicAuth = valueVerificationBasicAuth
		return nil
	}
	valueVerificationApiKey := new(VerificationApiKey)
	if err := json.Unmarshal(data, &valueVerificationApiKey); err == nil {
		v.typeName = "verificationApiKey"
		v.VerificationApiKey = valueVerificationApiKey
		return nil
	}
	valueVerificationTwitter := new(VerificationTwitter)
	if err := json.Unmarshal(data, &valueVerificationTwitter); err == nil {
		v.typeName = "verificationTwitter"
		v.VerificationTwitter = valueVerificationTwitter
		return nil
	}
	valueVerificationStripe := new(VerificationStripe)
	if err := json.Unmarshal(data, &valueVerificationStripe); err == nil {
		v.typeName = "verificationStripe"
		v.VerificationStripe = valueVerificationStripe
		return nil
	}
	valueVerificationRecharge := new(VerificationRecharge)
	if err := json.Unmarshal(data, &valueVerificationRecharge); err == nil {
		v.typeName = "verificationRecharge"
		v.VerificationRecharge = valueVerificationRecharge
		return nil
	}
	valueVerificationGitHub := new(VerificationGitHub)
	if err := json.Unmarshal(data, &valueVerificationGitHub); err == nil {
		v.typeName = "verificationGitHub"
		v.VerificationGitHub = valueVerificationGitHub
		return nil
	}
	valueVerificationShopify := new(VerificationShopify)
	if err := json.Unmarshal(data, &valueVerificationShopify); err == nil {
		v.typeName = "verificationShopify"
		v.VerificationShopify = valueVerificationShopify
		return nil
	}
	valueVerificationPostmark := new(VerificationPostmark)
	if err := json.Unmarshal(data, &valueVerificationPostmark); err == nil {
		v.typeName = "verificationPostmark"
		v.VerificationPostmark = valueVerificationPostmark
		return nil
	}
	valueVerificationTypeform := new(VerificationTypeform)
	if err := json.Unmarshal(data, &valueVerificationTypeform); err == nil {
		v.typeName = "verificationTypeform"
		v.VerificationTypeform = valueVerificationTypeform
		return nil
	}
	valueVerificationXero := new(VerificationXero)
	if err := json.Unmarshal(data, &valueVerificationXero); err == nil {
		v.typeName = "verificationXero"
		v.VerificationXero = valueVerificationXero
		return nil
	}
	valueVerificationSvix := new(VerificationSvix)
	if err := json.Unmarshal(data, &valueVerificationSvix); err == nil {
		v.typeName = "verificationSvix"
		v.VerificationSvix = valueVerificationSvix
		return nil
	}
	valueVerificationZoom := new(VerificationZoom)
	if err := json.Unmarshal(data, &valueVerificationZoom); err == nil {
		v.typeName = "verificationZoom"
		v.VerificationZoom = valueVerificationZoom
		return nil
	}
	valueVerificationAkeneo := new(VerificationAkeneo)
	if err := json.Unmarshal(data, &valueVerificationAkeneo); err == nil {
		v.typeName = "verificationAkeneo"
		v.VerificationAkeneo = valueVerificationAkeneo
		return nil
	}
	valueVerificationAdyen := new(VerificationAdyen)
	if err := json.Unmarshal(data, &valueVerificationAdyen); err == nil {
		v.typeName = "verificationAdyen"
		v.VerificationAdyen = valueVerificationAdyen
		return nil
	}
	valueVerificationGitLab := new(VerificationGitLab)
	if err := json.Unmarshal(data, &valueVerificationGitLab); err == nil {
		v.typeName = "verificationGitLab"
		v.VerificationGitLab = valueVerificationGitLab
		return nil
	}
	valueVerificationPropertyFinder := new(VerificationPropertyFinder)
	if err := json.Unmarshal(data, &valueVerificationPropertyFinder); err == nil {
		v.typeName = "verificationPropertyFinder"
		v.VerificationPropertyFinder = valueVerificationPropertyFinder
		return nil
	}
	valueVerificationWooCommerce := new(VerificationWooCommerce)
	if err := json.Unmarshal(data, &valueVerificationWooCommerce); err == nil {
		v.typeName = "verificationWooCommerce"
		v.VerificationWooCommerce = valueVerificationWooCommerce
		return nil
	}
	valueVerificationOura := new(VerificationOura)
	if err := json.Unmarshal(data, &valueVerificationOura); err == nil {
		v.typeName = "verificationOura"
		v.VerificationOura = valueVerificationOura
		return nil
	}
	valueVerificationCommercelayer := new(VerificationCommercelayer)
	if err := json.Unmarshal(data, &valueVerificationCommercelayer); err == nil {
		v.typeName = "verificationCommercelayer"
		v.VerificationCommercelayer = valueVerificationCommercelayer
		return nil
	}
	valueVerificationMailgun := new(VerificationMailgun)
	if err := json.Unmarshal(data, &valueVerificationMailgun); err == nil {
		v.typeName = "verificationMailgun"
		v.VerificationMailgun = valueVerificationMailgun
		return nil
	}
	valueVerificationPipedrive := new(VerificationPipedrive)
	if err := json.Unmarshal(data, &valueVerificationPipedrive); err == nil {
		v.typeName = "verificationPipedrive"
		v.VerificationPipedrive = valueVerificationPipedrive
		return nil
	}
	valueVerificationSendGrid := new(VerificationSendGrid)
	if err := json.Unmarshal(data, &valueVerificationSendGrid); err == nil {
		v.typeName = "verificationSendGrid"
		v.VerificationSendGrid = valueVerificationSendGrid
		return nil
	}
	valueVerificationWorkOs := new(VerificationWorkOs)
	if err := json.Unmarshal(data, &valueVerificationWorkOs); err == nil {
		v.typeName = "verificationWorkOs"
		v.VerificationWorkOs = valueVerificationWorkOs
		return nil
	}
	valueVerificationSynctera := new(VerificationSynctera)
	if err := json.Unmarshal(data, &valueVerificationSynctera); err == nil {
		v.typeName = "verificationSynctera"
		v.VerificationSynctera = valueVerificationSynctera
		return nil
	}
	valueVerificationAwssns := new(VerificationAwssns)
	if err := json.Unmarshal(data, &valueVerificationAwssns); err == nil {
		v.typeName = "verificationAwssns"
		v.VerificationAwssns = valueVerificationAwssns
		return nil
	}
	valueVerification3DEye := new(Verification3DEye)
	if err := json.Unmarshal(data, &valueVerification3DEye); err == nil {
		v.typeName = "verification3DEye"
		v.Verification3DEye = valueVerification3DEye
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VerificationConfig) MarshalJSON() ([]byte, error) {
	switch v.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "verificationHmac":
		return json.Marshal(v.VerificationHmac)
	case "verificationBasicAuth":
		return json.Marshal(v.VerificationBasicAuth)
	case "verificationApiKey":
		return json.Marshal(v.VerificationApiKey)
	case "verificationTwitter":
		return json.Marshal(v.VerificationTwitter)
	case "verificationStripe":
		return json.Marshal(v.VerificationStripe)
	case "verificationRecharge":
		return json.Marshal(v.VerificationRecharge)
	case "verificationGitHub":
		return json.Marshal(v.VerificationGitHub)
	case "verificationShopify":
		return json.Marshal(v.VerificationShopify)
	case "verificationPostmark":
		return json.Marshal(v.VerificationPostmark)
	case "verificationTypeform":
		return json.Marshal(v.VerificationTypeform)
	case "verificationXero":
		return json.Marshal(v.VerificationXero)
	case "verificationSvix":
		return json.Marshal(v.VerificationSvix)
	case "verificationZoom":
		return json.Marshal(v.VerificationZoom)
	case "verificationAkeneo":
		return json.Marshal(v.VerificationAkeneo)
	case "verificationAdyen":
		return json.Marshal(v.VerificationAdyen)
	case "verificationGitLab":
		return json.Marshal(v.VerificationGitLab)
	case "verificationPropertyFinder":
		return json.Marshal(v.VerificationPropertyFinder)
	case "verificationWooCommerce":
		return json.Marshal(v.VerificationWooCommerce)
	case "verificationOura":
		return json.Marshal(v.VerificationOura)
	case "verificationCommercelayer":
		return json.Marshal(v.VerificationCommercelayer)
	case "verificationMailgun":
		return json.Marshal(v.VerificationMailgun)
	case "verificationPipedrive":
		return json.Marshal(v.VerificationPipedrive)
	case "verificationSendGrid":
		return json.Marshal(v.VerificationSendGrid)
	case "verificationWorkOs":
		return json.Marshal(v.VerificationWorkOs)
	case "verificationSynctera":
		return json.Marshal(v.VerificationSynctera)
	case "verificationAwssns":
		return json.Marshal(v.VerificationAwssns)
	case "verification3DEye":
		return json.Marshal(v.Verification3DEye)
	}
}

type VerificationConfigVisitor interface {
	VisitVerificationHmac(*VerificationHmac) error
	VisitVerificationBasicAuth(*VerificationBasicAuth) error
	VisitVerificationApiKey(*VerificationApiKey) error
	VisitVerificationTwitter(*VerificationTwitter) error
	VisitVerificationStripe(*VerificationStripe) error
	VisitVerificationRecharge(*VerificationRecharge) error
	VisitVerificationGitHub(*VerificationGitHub) error
	VisitVerificationShopify(*VerificationShopify) error
	VisitVerificationPostmark(*VerificationPostmark) error
	VisitVerificationTypeform(*VerificationTypeform) error
	VisitVerificationXero(*VerificationXero) error
	VisitVerificationSvix(*VerificationSvix) error
	VisitVerificationZoom(*VerificationZoom) error
	VisitVerificationAkeneo(*VerificationAkeneo) error
	VisitVerificationAdyen(*VerificationAdyen) error
	VisitVerificationGitLab(*VerificationGitLab) error
	VisitVerificationPropertyFinder(*VerificationPropertyFinder) error
	VisitVerificationWooCommerce(*VerificationWooCommerce) error
	VisitVerificationOura(*VerificationOura) error
	VisitVerificationCommercelayer(*VerificationCommercelayer) error
	VisitVerificationMailgun(*VerificationMailgun) error
	VisitVerificationPipedrive(*VerificationPipedrive) error
	VisitVerificationSendGrid(*VerificationSendGrid) error
	VisitVerificationWorkOs(*VerificationWorkOs) error
	VisitVerificationSynctera(*VerificationSynctera) error
	VisitVerificationAwssns(*VerificationAwssns) error
	VisitVerification3DEye(*Verification3DEye) error
}

func (v *VerificationConfig) Accept(visitor VerificationConfigVisitor) error {
	switch v.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "verificationHmac":
		return visitor.VisitVerificationHmac(v.VerificationHmac)
	case "verificationBasicAuth":
		return visitor.VisitVerificationBasicAuth(v.VerificationBasicAuth)
	case "verificationApiKey":
		return visitor.VisitVerificationApiKey(v.VerificationApiKey)
	case "verificationTwitter":
		return visitor.VisitVerificationTwitter(v.VerificationTwitter)
	case "verificationStripe":
		return visitor.VisitVerificationStripe(v.VerificationStripe)
	case "verificationRecharge":
		return visitor.VisitVerificationRecharge(v.VerificationRecharge)
	case "verificationGitHub":
		return visitor.VisitVerificationGitHub(v.VerificationGitHub)
	case "verificationShopify":
		return visitor.VisitVerificationShopify(v.VerificationShopify)
	case "verificationPostmark":
		return visitor.VisitVerificationPostmark(v.VerificationPostmark)
	case "verificationTypeform":
		return visitor.VisitVerificationTypeform(v.VerificationTypeform)
	case "verificationXero":
		return visitor.VisitVerificationXero(v.VerificationXero)
	case "verificationSvix":
		return visitor.VisitVerificationSvix(v.VerificationSvix)
	case "verificationZoom":
		return visitor.VisitVerificationZoom(v.VerificationZoom)
	case "verificationAkeneo":
		return visitor.VisitVerificationAkeneo(v.VerificationAkeneo)
	case "verificationAdyen":
		return visitor.VisitVerificationAdyen(v.VerificationAdyen)
	case "verificationGitLab":
		return visitor.VisitVerificationGitLab(v.VerificationGitLab)
	case "verificationPropertyFinder":
		return visitor.VisitVerificationPropertyFinder(v.VerificationPropertyFinder)
	case "verificationWooCommerce":
		return visitor.VisitVerificationWooCommerce(v.VerificationWooCommerce)
	case "verificationOura":
		return visitor.VisitVerificationOura(v.VerificationOura)
	case "verificationCommercelayer":
		return visitor.VisitVerificationCommercelayer(v.VerificationCommercelayer)
	case "verificationMailgun":
		return visitor.VisitVerificationMailgun(v.VerificationMailgun)
	case "verificationPipedrive":
		return visitor.VisitVerificationPipedrive(v.VerificationPipedrive)
	case "verificationSendGrid":
		return visitor.VisitVerificationSendGrid(v.VerificationSendGrid)
	case "verificationWorkOs":
		return visitor.VisitVerificationWorkOs(v.VerificationWorkOs)
	case "verificationSynctera":
		return visitor.VisitVerificationSynctera(v.VerificationSynctera)
	case "verificationAwssns":
		return visitor.VisitVerificationAwssns(v.VerificationAwssns)
	case "verification3DEye":
		return visitor.VisitVerification3DEye(v.Verification3DEye)
	}
}

type VerificationGitHub struct {
	Configs *VerificationGitHubConfigs `json:"configs,omitempty"`
	type_   string
}

func (v *VerificationGitHub) Type() string {
	return v.type_
}

func (v *VerificationGitHub) UnmarshalJSON(data []byte) error {
	type unmarshaler VerificationGitHub
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VerificationGitHub(value)
	v.type_ = "github"
	return nil
}

func (v *VerificationGitHub) MarshalJSON() ([]byte, error) {
	type embed VerificationGitHub
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*v),
		Type:  "github",
	}
	return json.Marshal(marshaler)
}

// The verification configs for GitHub. Only included if the ?include=verification.configs query param is present
type VerificationGitHubConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationGitLab struct {
	Configs *VerificationGitLabConfigs `json:"configs,omitempty"`
	type_   string
}

func (v *VerificationGitLab) Type() string {
	return v.type_
}

func (v *VerificationGitLab) UnmarshalJSON(data []byte) error {
	type unmarshaler VerificationGitLab
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VerificationGitLab(value)
	v.type_ = "gitlab"
	return nil
}

func (v *VerificationGitLab) MarshalJSON() ([]byte, error) {
	type embed VerificationGitLab
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*v),
		Type:  "gitlab",
	}
	return json.Marshal(marshaler)
}

// The verification configs for GitLab. Only included if the ?include=verification.configs query param is present
type VerificationGitLabConfigs struct {
	ApiKey string `json:"api_key"`
}

type VerificationHmac struct {
	Configs *VerificationHmacConfigs `json:"configs,omitempty"`
	type_   string
}

func (v *VerificationHmac) Type() string {
	return v.type_
}

func (v *VerificationHmac) UnmarshalJSON(data []byte) error {
	type unmarshaler VerificationHmac
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VerificationHmac(value)
	v.type_ = "hmac"
	return nil
}

func (v *VerificationHmac) MarshalJSON() ([]byte, error) {
	type embed VerificationHmac
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*v),
		Type:  "hmac",
	}
	return json.Marshal(marshaler)
}

// The verification configs for HMAC. Only included if the ?include=verification.configs query param is present
type VerificationHmacConfigs struct {
	WebhookSecretKey string                          `json:"webhook_secret_key"`
	Algorithm        HmacAlgorithms                  `json:"algorithm,omitempty"`
	HeaderKey        string                          `json:"header_key"`
	Encoding         VerificationHmacConfigsEncoding `json:"encoding,omitempty"`
}

type VerificationHmacConfigsEncoding string

const (
	VerificationHmacConfigsEncodingBase64 VerificationHmacConfigsEncoding = "base64"
	VerificationHmacConfigsEncodingHex    VerificationHmacConfigsEncoding = "hex"
)

func NewVerificationHmacConfigsEncodingFromString(s string) (VerificationHmacConfigsEncoding, error) {
	switch s {
	case "base64":
		return VerificationHmacConfigsEncodingBase64, nil
	case "hex":
		return VerificationHmacConfigsEncodingHex, nil
	}
	var t VerificationHmacConfigsEncoding
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationHmacConfigsEncoding) Ptr() *VerificationHmacConfigsEncoding {
	return &v
}

type VerificationMailgun struct {
	Configs *VerificationMailgunConfigs `json:"configs,omitempty"`
	type_   string
}

func (v *VerificationMailgun) Type() string {
	return v.type_
}

func (v *VerificationMailgun) UnmarshalJSON(data []byte) error {
	type unmarshaler VerificationMailgun
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VerificationMailgun(value)
	v.type_ = "mailgun"
	return nil
}

func (v *VerificationMailgun) MarshalJSON() ([]byte, error) {
	type embed VerificationMailgun
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*v),
		Type:  "mailgun",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Mailgun. Only included if the ?include=verification.configs query param is present
type VerificationMailgunConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationOura struct {
	Configs *VerificationOuraConfigs `json:"configs,omitempty"`
	type_   string
}

func (v *VerificationOura) Type() string {
	return v.type_
}

func (v *VerificationOura) UnmarshalJSON(data []byte) error {
	type unmarshaler VerificationOura
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VerificationOura(value)
	v.type_ = "oura"
	return nil
}

func (v *VerificationOura) MarshalJSON() ([]byte, error) {
	type embed VerificationOura
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*v),
		Type:  "oura",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Oura. Only included if the ?include=verification.configs query param is present
type VerificationOuraConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationPipedrive struct {
	Configs *VerificationPipedriveConfigs `json:"configs,omitempty"`
	type_   string
}

func (v *VerificationPipedrive) Type() string {
	return v.type_
}

func (v *VerificationPipedrive) UnmarshalJSON(data []byte) error {
	type unmarshaler VerificationPipedrive
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VerificationPipedrive(value)
	v.type_ = "pipedrive"
	return nil
}

func (v *VerificationPipedrive) MarshalJSON() ([]byte, error) {
	type embed VerificationPipedrive
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*v),
		Type:  "pipedrive",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Pipedrive. Only included if the ?include=verification.configs query param is present
type VerificationPipedriveConfigs struct {
	Name     string `json:"name"`
	Password string `json:"password"`
}

type VerificationPostmark struct {
	Configs *VerificationPostmarkConfigs `json:"configs,omitempty"`
	type_   string
}

func (v *VerificationPostmark) Type() string {
	return v.type_
}

func (v *VerificationPostmark) UnmarshalJSON(data []byte) error {
	type unmarshaler VerificationPostmark
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VerificationPostmark(value)
	v.type_ = "postmark"
	return nil
}

func (v *VerificationPostmark) MarshalJSON() ([]byte, error) {
	type embed VerificationPostmark
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*v),
		Type:  "postmark",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Postmark. Only included if the ?include=verification.configs query param is present
type VerificationPostmarkConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationPropertyFinder struct {
	Configs *VerificationPropertyFinderConfigs `json:"configs,omitempty"`
	type_   string
}

func (v *VerificationPropertyFinder) Type() string {
	return v.type_
}

func (v *VerificationPropertyFinder) UnmarshalJSON(data []byte) error {
	type unmarshaler VerificationPropertyFinder
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VerificationPropertyFinder(value)
	v.type_ = "property-finder"
	return nil
}

func (v *VerificationPropertyFinder) MarshalJSON() ([]byte, error) {
	type embed VerificationPropertyFinder
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*v),
		Type:  "property-finder",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Property Finder. Only included if the ?include=verification.configs query param is present
type VerificationPropertyFinderConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationRecharge struct {
	Configs *VerificationRechargeConfigs `json:"configs,omitempty"`
	type_   string
}

func (v *VerificationRecharge) Type() string {
	return v.type_
}

func (v *VerificationRecharge) UnmarshalJSON(data []byte) error {
	type unmarshaler VerificationRecharge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VerificationRecharge(value)
	v.type_ = "recharge"
	return nil
}

func (v *VerificationRecharge) MarshalJSON() ([]byte, error) {
	type embed VerificationRecharge
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*v),
		Type:  "recharge",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Recharge. Only included if the ?include=verification.configs query param is present
type VerificationRechargeConfigs struct {
	WebhookSecretKey string                              `json:"webhook_secret_key"`
	Algorithm        HmacAlgorithms                      `json:"algorithm,omitempty"`
	HeaderKey        string                              `json:"header_key"`
	Encoding         VerificationRechargeConfigsEncoding `json:"encoding,omitempty"`
}

type VerificationRechargeConfigsEncoding string

const (
	VerificationRechargeConfigsEncodingBase64 VerificationRechargeConfigsEncoding = "base64"
	VerificationRechargeConfigsEncodingHex    VerificationRechargeConfigsEncoding = "hex"
)

func NewVerificationRechargeConfigsEncodingFromString(s string) (VerificationRechargeConfigsEncoding, error) {
	switch s {
	case "base64":
		return VerificationRechargeConfigsEncodingBase64, nil
	case "hex":
		return VerificationRechargeConfigsEncodingHex, nil
	}
	var t VerificationRechargeConfigsEncoding
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationRechargeConfigsEncoding) Ptr() *VerificationRechargeConfigsEncoding {
	return &v
}

type VerificationSendGrid struct {
	Configs *VerificationSendGridConfigs `json:"configs,omitempty"`
	type_   string
}

func (v *VerificationSendGrid) Type() string {
	return v.type_
}

func (v *VerificationSendGrid) UnmarshalJSON(data []byte) error {
	type unmarshaler VerificationSendGrid
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VerificationSendGrid(value)
	v.type_ = "sendgrid"
	return nil
}

func (v *VerificationSendGrid) MarshalJSON() ([]byte, error) {
	type embed VerificationSendGrid
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*v),
		Type:  "sendgrid",
	}
	return json.Marshal(marshaler)
}

// The verification configs for SendGrid. Only included if the ?include=verification.configs query param is present
type VerificationSendGridConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationShopify struct {
	Configs *VerificationShopifyConfigs `json:"configs,omitempty"`
	type_   string
}

func (v *VerificationShopify) Type() string {
	return v.type_
}

func (v *VerificationShopify) UnmarshalJSON(data []byte) error {
	type unmarshaler VerificationShopify
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VerificationShopify(value)
	v.type_ = "shopify"
	return nil
}

func (v *VerificationShopify) MarshalJSON() ([]byte, error) {
	type embed VerificationShopify
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*v),
		Type:  "shopify",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Shopify. Only included if the ?include=verification.configs query param is present
type VerificationShopifyConfigs struct {
	WebhookSecretKey string                                     `json:"webhook_secret_key"`
	RateLimitPeriod  *VerificationShopifyConfigsRateLimitPeriod `json:"rate_limit_period,omitempty"`
	RateLimit        *float64                                   `json:"rate_limit,omitempty"`
	ApiKey           *string                                    `json:"api_key,omitempty"`
	ApiSecret        *string                                    `json:"api_secret,omitempty"`
	Shop             *string                                    `json:"shop,omitempty"`
}

type VerificationShopifyConfigsRateLimitPeriod string

const (
	VerificationShopifyConfigsRateLimitPeriodMinute VerificationShopifyConfigsRateLimitPeriod = "minute"
	VerificationShopifyConfigsRateLimitPeriodSecond VerificationShopifyConfigsRateLimitPeriod = "second"
)

func NewVerificationShopifyConfigsRateLimitPeriodFromString(s string) (VerificationShopifyConfigsRateLimitPeriod, error) {
	switch s {
	case "minute":
		return VerificationShopifyConfigsRateLimitPeriodMinute, nil
	case "second":
		return VerificationShopifyConfigsRateLimitPeriodSecond, nil
	}
	var t VerificationShopifyConfigsRateLimitPeriod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationShopifyConfigsRateLimitPeriod) Ptr() *VerificationShopifyConfigsRateLimitPeriod {
	return &v
}

type VerificationStripe struct {
	Configs *VerificationStripeConfigs `json:"configs,omitempty"`
	type_   string
}

func (v *VerificationStripe) Type() string {
	return v.type_
}

func (v *VerificationStripe) UnmarshalJSON(data []byte) error {
	type unmarshaler VerificationStripe
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VerificationStripe(value)
	v.type_ = "stripe"
	return nil
}

func (v *VerificationStripe) MarshalJSON() ([]byte, error) {
	type embed VerificationStripe
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*v),
		Type:  "stripe",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Stripe. Only included if the ?include=verification.configs query param is present
type VerificationStripeConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationSvix struct {
	Configs *VerificationSvixConfigs `json:"configs,omitempty"`
	type_   string
}

func (v *VerificationSvix) Type() string {
	return v.type_
}

func (v *VerificationSvix) UnmarshalJSON(data []byte) error {
	type unmarshaler VerificationSvix
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VerificationSvix(value)
	v.type_ = "svix"
	return nil
}

func (v *VerificationSvix) MarshalJSON() ([]byte, error) {
	type embed VerificationSvix
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*v),
		Type:  "svix",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Svix. Only included if the ?include=verification.configs query param is present
type VerificationSvixConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationSynctera struct {
	Configs *VerificationSyncteraConfigs `json:"configs,omitempty"`
	type_   string
}

func (v *VerificationSynctera) Type() string {
	return v.type_
}

func (v *VerificationSynctera) UnmarshalJSON(data []byte) error {
	type unmarshaler VerificationSynctera
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VerificationSynctera(value)
	v.type_ = "synctera"
	return nil
}

func (v *VerificationSynctera) MarshalJSON() ([]byte, error) {
	type embed VerificationSynctera
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*v),
		Type:  "synctera",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Synctera. Only included if the ?include=verification.configs query param is present
type VerificationSyncteraConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationTwitter struct {
	Configs *VerificationTwitterConfigs `json:"configs,omitempty"`
	type_   string
}

func (v *VerificationTwitter) Type() string {
	return v.type_
}

func (v *VerificationTwitter) UnmarshalJSON(data []byte) error {
	type unmarshaler VerificationTwitter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VerificationTwitter(value)
	v.type_ = "twitter"
	return nil
}

func (v *VerificationTwitter) MarshalJSON() ([]byte, error) {
	type embed VerificationTwitter
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*v),
		Type:  "twitter",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Twitter. Only included if the ?include=verification.configs query param is present
type VerificationTwitterConfigs struct {
	ApiKey string `json:"api_key"`
}

type VerificationTypeform struct {
	Configs *VerificationTypeformConfigs `json:"configs,omitempty"`
	type_   string
}

func (v *VerificationTypeform) Type() string {
	return v.type_
}

func (v *VerificationTypeform) UnmarshalJSON(data []byte) error {
	type unmarshaler VerificationTypeform
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VerificationTypeform(value)
	v.type_ = "typeform"
	return nil
}

func (v *VerificationTypeform) MarshalJSON() ([]byte, error) {
	type embed VerificationTypeform
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*v),
		Type:  "typeform",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Typeform. Only included if the ?include=verification.configs query param is present
type VerificationTypeformConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationWooCommerce struct {
	Configs *VerificationWooCommerceConfigs `json:"configs,omitempty"`
	type_   string
}

func (v *VerificationWooCommerce) Type() string {
	return v.type_
}

func (v *VerificationWooCommerce) UnmarshalJSON(data []byte) error {
	type unmarshaler VerificationWooCommerce
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VerificationWooCommerce(value)
	v.type_ = "woocommerce"
	return nil
}

func (v *VerificationWooCommerce) MarshalJSON() ([]byte, error) {
	type embed VerificationWooCommerce
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*v),
		Type:  "woocommerce",
	}
	return json.Marshal(marshaler)
}

// The verification configs for WooCommerce. Only included if the ?include=verification.configs query param is present
type VerificationWooCommerceConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationWorkOs struct {
	Configs *VerificationWorkOsConfigs `json:"configs,omitempty"`
	type_   string
}

func (v *VerificationWorkOs) Type() string {
	return v.type_
}

func (v *VerificationWorkOs) UnmarshalJSON(data []byte) error {
	type unmarshaler VerificationWorkOs
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VerificationWorkOs(value)
	v.type_ = "workos"
	return nil
}

func (v *VerificationWorkOs) MarshalJSON() ([]byte, error) {
	type embed VerificationWorkOs
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*v),
		Type:  "workos",
	}
	return json.Marshal(marshaler)
}

// The verification configs for WorkOS. Only included if the ?include=verification.configs query param is present
type VerificationWorkOsConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationXero struct {
	Configs *VerificationXeroConfigs `json:"configs,omitempty"`
	type_   string
}

func (v *VerificationXero) Type() string {
	return v.type_
}

func (v *VerificationXero) UnmarshalJSON(data []byte) error {
	type unmarshaler VerificationXero
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VerificationXero(value)
	v.type_ = "xero"
	return nil
}

func (v *VerificationXero) MarshalJSON() ([]byte, error) {
	type embed VerificationXero
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*v),
		Type:  "xero",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Xero. Only included if the ?include=verification.configs query param is present
type VerificationXeroConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationZoom struct {
	Configs *VerificationZoomConfigs `json:"configs,omitempty"`
	type_   string
}

func (v *VerificationZoom) Type() string {
	return v.type_
}

func (v *VerificationZoom) UnmarshalJSON(data []byte) error {
	type unmarshaler VerificationZoom
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VerificationZoom(value)
	v.type_ = "zoom"
	return nil
}

func (v *VerificationZoom) MarshalJSON() ([]byte, error) {
	type embed VerificationZoom
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*v),
		Type:  "zoom",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Zoom. Only included if the ?include=verification.configs query param is present
type VerificationZoomConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}
