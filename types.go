// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	strconv "strconv"
	time "time"
)

type AddCustomHostname struct {
	// The custom hostname to attach to the workspace
	Hostname string `json:"hostname"`
}

type Adyen struct {
	Configs *AdyenConfigs `json:"configs,omitempty"`
	type_   string
}

func (a *Adyen) Type() string {
	return a.type_
}

func (a *Adyen) UnmarshalJSON(data []byte) error {
	type unmarshaler Adyen
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Adyen(value)
	a.type_ = "adyen"
	return nil
}

func (a *Adyen) MarshalJSON() ([]byte, error) {
	type embed Adyen
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
		Type:  "adyen",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Adyen. Only included if the ?include=verification.configs query param is present
type AdyenConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type Akeneo struct {
	Configs *AkeneoConfigs `json:"configs,omitempty"`
	type_   string
}

func (a *Akeneo) Type() string {
	return a.type_
}

func (a *Akeneo) UnmarshalJSON(data []byte) error {
	type unmarshaler Akeneo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Akeneo(value)
	a.type_ = "akeneo"
	return nil
}

func (a *Akeneo) MarshalJSON() ([]byte, error) {
	type embed Akeneo
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
		Type:  "akeneo",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Akeneo. Only included if the ?include=verification.configs query param is present
type AkeneoConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

// Error response model
type ApiErrorResponse struct {
	// Error code
	Code string `json:"code"`
	// Status code
	Status float64 `json:"status"`
	// Error description
	Message string                `json:"message"`
	Data    *ApiErrorResponseData `json:"data,omitempty"`
}

type ApiErrorResponseData struct {
}

type ApiKey struct {
	Configs *ApiKeyConfigs `json:"configs,omitempty"`
	type_   string
}

func (a *ApiKey) Type() string {
	return a.type_
}

func (a *ApiKey) UnmarshalJSON(data []byte) error {
	type unmarshaler ApiKey
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApiKey(value)
	a.type_ = "api_key"
	return nil
}

func (a *ApiKey) MarshalJSON() ([]byte, error) {
	type embed ApiKey
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
		Type:  "api_key",
	}
	return json.Marshal(marshaler)
}

// The verification configs for API Key. Only included if the ?include=verification.configs query param is present
type ApiKeyConfigs struct {
	HeaderKey string `json:"header_key"`
	ApiKey    string `json:"api_key"`
}

type ApiKeyIntegrationConfigs struct {
	HeaderKey string `json:"header_key"`
	ApiKey    string `json:"api_key"`
}

type AttachedIntegrationToSource struct {
	Success bool `json:"success"`
}

// Error code of the delivery attempt
type AttemptErrorCodes uint

const (
	AttemptErrorCodesCancelled AttemptErrorCodes = iota + 1
	AttemptErrorCodesTimeout
	AttemptErrorCodesNotFound
	AttemptErrorCodesConnectionRefused
	AttemptErrorCodesConnectionReset
	AttemptErrorCodesMissingUrl
	AttemptErrorCodesCli
	AttemptErrorCodesCliUnavailable
	AttemptErrorCodesSelfSignedCert
	AttemptErrorCodesErrTlsCertAltnameInvalid
	AttemptErrorCodesSslErrorCaUnknown
	AttemptErrorCodesTtlExpired
	AttemptErrorCodesDataArchived
	AttemptErrorCodesSslCertExpired
	AttemptErrorCodesBulkRetryCancelled
	AttemptErrorCodesDnsLookupFailed
	AttemptErrorCodesHostUnreachable
	AttemptErrorCodesProtocolError
	AttemptErrorCodesSocketClosed
	AttemptErrorCodesUnknown
)

func (a AttemptErrorCodes) String() string {
	switch a {
	default:
		return strconv.Itoa(int(a))
	case AttemptErrorCodesCancelled:
		return "CANCELLED"
	case AttemptErrorCodesTimeout:
		return "TIMEOUT"
	case AttemptErrorCodesNotFound:
		return "NOT_FOUND"
	case AttemptErrorCodesConnectionRefused:
		return "CONNECTION_REFUSED"
	case AttemptErrorCodesConnectionReset:
		return "CONNECTION_RESET"
	case AttemptErrorCodesMissingUrl:
		return "MISSING_URL"
	case AttemptErrorCodesCli:
		return "CLI"
	case AttemptErrorCodesCliUnavailable:
		return "CLI_UNAVAILABLE"
	case AttemptErrorCodesSelfSignedCert:
		return "SELF_SIGNED_CERT"
	case AttemptErrorCodesErrTlsCertAltnameInvalid:
		return "ERR_TLS_CERT_ALTNAME_INVALID"
	case AttemptErrorCodesSslErrorCaUnknown:
		return "SSL_ERROR_CA_UNKNOWN"
	case AttemptErrorCodesTtlExpired:
		return "TTL_EXPIRED"
	case AttemptErrorCodesDataArchived:
		return "DATA_ARCHIVED"
	case AttemptErrorCodesSslCertExpired:
		return "SSL_CERT_EXPIRED"
	case AttemptErrorCodesBulkRetryCancelled:
		return "BULK_RETRY_CANCELLED"
	case AttemptErrorCodesDnsLookupFailed:
		return "DNS_LOOKUP_FAILED"
	case AttemptErrorCodesHostUnreachable:
		return "HOST_UNREACHABLE"
	case AttemptErrorCodesProtocolError:
		return "PROTOCOL_ERROR"
	case AttemptErrorCodesSocketClosed:
		return "SOCKET_CLOSED"
	case AttemptErrorCodesUnknown:
		return "UNKNOWN"
	}
}

func (a AttemptErrorCodes) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", a.String())), nil
}

func (a *AttemptErrorCodes) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "CANCELLED":
		value := AttemptErrorCodesCancelled
		*a = value
	case "TIMEOUT":
		value := AttemptErrorCodesTimeout
		*a = value
	case "NOT_FOUND":
		value := AttemptErrorCodesNotFound
		*a = value
	case "CONNECTION_REFUSED":
		value := AttemptErrorCodesConnectionRefused
		*a = value
	case "CONNECTION_RESET":
		value := AttemptErrorCodesConnectionReset
		*a = value
	case "MISSING_URL":
		value := AttemptErrorCodesMissingUrl
		*a = value
	case "CLI":
		value := AttemptErrorCodesCli
		*a = value
	case "CLI_UNAVAILABLE":
		value := AttemptErrorCodesCliUnavailable
		*a = value
	case "SELF_SIGNED_CERT":
		value := AttemptErrorCodesSelfSignedCert
		*a = value
	case "ERR_TLS_CERT_ALTNAME_INVALID":
		value := AttemptErrorCodesErrTlsCertAltnameInvalid
		*a = value
	case "SSL_ERROR_CA_UNKNOWN":
		value := AttemptErrorCodesSslErrorCaUnknown
		*a = value
	case "TTL_EXPIRED":
		value := AttemptErrorCodesTtlExpired
		*a = value
	case "DATA_ARCHIVED":
		value := AttemptErrorCodesDataArchived
		*a = value
	case "SSL_CERT_EXPIRED":
		value := AttemptErrorCodesSslCertExpired
		*a = value
	case "BULK_RETRY_CANCELLED":
		value := AttemptErrorCodesBulkRetryCancelled
		*a = value
	case "DNS_LOOKUP_FAILED":
		value := AttemptErrorCodesDnsLookupFailed
		*a = value
	case "HOST_UNREACHABLE":
		value := AttemptErrorCodesHostUnreachable
		*a = value
	case "PROTOCOL_ERROR":
		value := AttemptErrorCodesProtocolError
		*a = value
	case "SOCKET_CLOSED":
		value := AttemptErrorCodesSocketClosed
		*a = value
	case "UNKNOWN":
		value := AttemptErrorCodesUnknown
		*a = value
	}
	return nil
}

type AttemptState uint

const (
	AttemptStateDelivering AttemptState = iota + 1
	AttemptStateQueued
	AttemptStatePending
	AttemptStateCompleted
	AttemptStateHold
)

func (a AttemptState) String() string {
	switch a {
	default:
		return strconv.Itoa(int(a))
	case AttemptStateDelivering:
		return "DELIVERING"
	case AttemptStateQueued:
		return "QUEUED"
	case AttemptStatePending:
		return "PENDING"
	case AttemptStateCompleted:
		return "COMPLETED"
	case AttemptStateHold:
		return "HOLD"
	}
}

func (a AttemptState) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", a.String())), nil
}

func (a *AttemptState) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "DELIVERING":
		value := AttemptStateDelivering
		*a = value
	case "QUEUED":
		value := AttemptStateQueued
		*a = value
	case "PENDING":
		value := AttemptStatePending
		*a = value
	case "COMPLETED":
		value := AttemptStateCompleted
		*a = value
	case "HOLD":
		value := AttemptStateHold
		*a = value
	}
	return nil
}

// Attempt status
type AttemptStatus uint

const (
	AttemptStatusQueued AttemptStatus = iota + 1
	AttemptStatusFailed
	AttemptStatusSuccessful
	AttemptStatusHold
)

func (a AttemptStatus) String() string {
	switch a {
	default:
		return strconv.Itoa(int(a))
	case AttemptStatusQueued:
		return "QUEUED"
	case AttemptStatusFailed:
		return "FAILED"
	case AttemptStatusSuccessful:
		return "SUCCESSFUL"
	case AttemptStatusHold:
		return "HOLD"
	}
}

func (a AttemptStatus) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", a.String())), nil
}

func (a *AttemptStatus) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "QUEUED":
		value := AttemptStatusQueued
		*a = value
	case "FAILED":
		value := AttemptStatusFailed
		*a = value
	case "SUCCESSFUL":
		value := AttemptStatusSuccessful
		*a = value
	case "HOLD":
		value := AttemptStatusHold
		*a = value
	}
	return nil
}

// How the attempt was triggered
type AttemptTrigger uint

const (
	AttemptTriggerInitial AttemptTrigger = iota + 1
	AttemptTriggerManual
	AttemptTriggerBulkRetry
	AttemptTriggerUnpause
	AttemptTriggerAutomatic
)

func (a AttemptTrigger) String() string {
	switch a {
	default:
		return strconv.Itoa(int(a))
	case AttemptTriggerInitial:
		return "INITIAL"
	case AttemptTriggerManual:
		return "MANUAL"
	case AttemptTriggerBulkRetry:
		return "BULK_RETRY"
	case AttemptTriggerUnpause:
		return "UNPAUSE"
	case AttemptTriggerAutomatic:
		return "AUTOMATIC"
	}
}

func (a AttemptTrigger) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", a.String())), nil
}

func (a *AttemptTrigger) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "INITIAL":
		value := AttemptTriggerInitial
		*a = value
	case "MANUAL":
		value := AttemptTriggerManual
		*a = value
	case "BULK_RETRY":
		value := AttemptTriggerBulkRetry
		*a = value
	case "UNPAUSE":
		value := AttemptTriggerUnpause
		*a = value
	case "AUTOMATIC":
		value := AttemptTriggerAutomatic
		*a = value
	}
	return nil
}

type AwsSns struct {
	Configs *AwsSnsConfigs `json:"configs,omitempty"`
	type_   string
}

func (a *AwsSns) Type() string {
	return a.type_
}

func (a *AwsSns) UnmarshalJSON(data []byte) error {
	type unmarshaler AwsSns
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AwsSns(value)
	a.type_ = "aws_sns"
	return nil
}

func (a *AwsSns) MarshalJSON() ([]byte, error) {
	type embed AwsSns
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
		Type:  "aws_sns",
	}
	return json.Marshal(marshaler)
}

// The verification configs for AWS SNS. Only included if the ?include=verification.configs query param is present
type AwsSnsConfigs struct {
}

type BasicAuth struct {
	Configs *BasicAuthConfigs `json:"configs,omitempty"`
	type_   string
}

func (b *BasicAuth) Type() string {
	return b.type_
}

func (b *BasicAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler BasicAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BasicAuth(value)
	b.type_ = "basic_auth"
	return nil
}

func (b *BasicAuth) MarshalJSON() ([]byte, error) {
	type embed BasicAuth
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*b),
		Type:  "basic_auth",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Basic Auth. Only included if the ?include=verification.configs query param is present
type BasicAuthConfigs struct {
	Name     string `json:"name"`
	Password string `json:"password"`
}

type BasicAuthIntegrationConfigs struct {
	Name     string `json:"name"`
	Password string `json:"password"`
}

type BatchOperation struct {
	// ID of the bulk retry
	Id string `json:"id"`
	// ID of the workspace
	TeamId string `json:"team_id"`
	// Query object to filter records
	Query *BatchOperationQuery `json:"query,omitempty"`
	// Date the bulk retry was created
	CreatedAt time.Time `json:"created_at"`
	// Last time the bulk retry was updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the bulk retry was cancelled
	CancelledAt *time.Time `json:"cancelled_at,omitempty"`
	// Date the bulk retry was completed
	CompletedAt *time.Time `json:"completed_at,omitempty"`
	// Number of batches required to complete the bulk retry
	EstimatedBatch *int `json:"estimated_batch,omitempty"`
	// Number of estimated events to be retried
	EstimatedCount *int `json:"estimated_count,omitempty"`
	// Number of batches currently processed
	ProcessedBatch *int `json:"processed_batch,omitempty"`
	// Number of events that were successfully delivered
	CompletedCount *int `json:"completed_count,omitempty"`
	// Indicates if the bulk retry is currently in progress
	InProgress bool `json:"in_progress"`
	// Progression of the batch operations, values 0 - 1
	Progress *float64 `json:"progress,omitempty"`
	// Number of events that failed to be delivered
	FailedCount *int     `json:"failed_count,omitempty"`
	Number      *float64 `json:"number,omitempty"`
}

type BatchOperationPaginatedResult struct {
	Pagination *SeekPagination   `json:"pagination,omitempty"`
	Count      *int              `json:"count,omitempty"`
	Models     []*BatchOperation `json:"models,omitempty"`
}

// Query object to filter records
type BatchOperationQuery struct {
	typeName         string
	StringUnknownMap map[string]any
	StringOptional   *string
}

func NewBatchOperationQueryFromStringUnknownMap(value map[string]any) *BatchOperationQuery {
	return &BatchOperationQuery{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func NewBatchOperationQueryFromStringOptional(value *string) *BatchOperationQuery {
	return &BatchOperationQuery{typeName: "stringOptional", StringOptional: value}
}

func (b *BatchOperationQuery) UnmarshalJSON(data []byte) error {
	var valueStringUnknownMap map[string]any
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		b.typeName = "stringUnknownMap"
		b.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		b.typeName = "stringOptional"
		b.StringOptional = valueStringOptional
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BatchOperationQuery) MarshalJSON() ([]byte, error) {
	switch b.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "stringUnknownMap":
		return json.Marshal(b.StringUnknownMap)
	case "stringOptional":
		return json.Marshal(b.StringOptional)
	}
}

type BatchOperationQueryVisitor interface {
	VisitStringUnknownMap(map[string]any) error
	VisitStringOptional(*string) error
}

func (b *BatchOperationQuery) Accept(visitor BatchOperationQueryVisitor) error {
	switch b.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(b.StringUnknownMap)
	case "stringOptional":
		return visitor.VisitStringOptional(b.StringOptional)
	}
}

// Bearer Token
type BearerToken struct {
	Config *DestinationAuthMethodBearerTokenConfig `json:"config,omitempty"`
	type_  string
}

func (b *BearerToken) Type() string {
	return b.type_
}

func (b *BearerToken) UnmarshalJSON(data []byte) error {
	type unmarshaler BearerToken
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BearerToken(value)
	b.type_ = "BEARER_TOKEN"
	return nil
}

func (b *BearerToken) MarshalJSON() ([]byte, error) {
	type embed BearerToken
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*b),
		Type:  "BEARER_TOKEN",
	}
	return json.Marshal(marshaler)
}

type Bookmark struct {
	// ID of the bookmark
	Id string `json:"id"`
	// ID of the workspace
	TeamId string `json:"team_id"`
	// ID of the associated connection
	WebhookId string `json:"webhook_id"`
	// ID of the bookmarked event data
	EventDataId string `json:"event_data_id"`
	// Descriptive name of the bookmark
	Label string `json:"label"`
	// Alternate alias for the bookmark
	Alias *string         `json:"alias,omitempty"`
	Data  *ShortEventData `json:"data,omitempty"`
	// Date the bookmark was last manually triggered
	LastUsedAt *time.Time `json:"last_used_at,omitempty"`
	// Date the bookmark was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the bookmark was created
	CreatedAt time.Time `json:"created_at"`
}

type BookmarkPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Bookmark     `json:"models,omitempty"`
}

type Commercelayer struct {
	Configs *CommercelayerConfigs `json:"configs,omitempty"`
	type_   string
}

func (c *Commercelayer) Type() string {
	return c.type_
}

func (c *Commercelayer) UnmarshalJSON(data []byte) error {
	type unmarshaler Commercelayer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Commercelayer(value)
	c.type_ = "commercelayer"
	return nil
}

func (c *Commercelayer) MarshalJSON() ([]byte, error) {
	type embed Commercelayer
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "commercelayer",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Commercelayer. Only included if the ?include=verification.configs query param is present
type CommercelayerConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type Connection struct {
	// ID of the connection
	Id string `json:"id"`
	// Unique name of the connection for this source
	Name *string `json:"name,omitempty"`
	// Full name of the connection concatenated from source, connection and desitnation name
	FullName *string `json:"full_name,omitempty"`
	// Description of the connection
	Description *string `json:"description,omitempty"`
	// ID of the workspace
	TeamId      string       `json:"team_id"`
	Destination *Destination `json:"destination,omitempty"`
	Source      *Source      `json:"source,omitempty"`
	// Array of rules configured on the connection
	Rules []*Rule `json:"rules,omitempty"`
	// Date the connection was archived
	ArchivedAt *time.Time `json:"archived_at,omitempty"`
	// Date the connection was paused
	PausedAt *time.Time `json:"paused_at,omitempty"`
	// Date the connection was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the connection was created
	CreatedAt time.Time `json:"created_at"`
}

// JSON using our filter syntax to filter on request headers
type ConnectionFilterProperty struct {
	typeName                      string
	StringOptional                *string
	Double                        float64
	Boolean                       bool
	ConnectionFilterPropertyThree *ConnectionFilterPropertyThree
}

func NewConnectionFilterPropertyFromStringOptional(value *string) *ConnectionFilterProperty {
	return &ConnectionFilterProperty{typeName: "stringOptional", StringOptional: value}
}

func NewConnectionFilterPropertyFromDouble(value float64) *ConnectionFilterProperty {
	return &ConnectionFilterProperty{typeName: "double", Double: value}
}

func NewConnectionFilterPropertyFromBoolean(value bool) *ConnectionFilterProperty {
	return &ConnectionFilterProperty{typeName: "boolean", Boolean: value}
}

func NewConnectionFilterPropertyFromConnectionFilterPropertyThree(value *ConnectionFilterPropertyThree) *ConnectionFilterProperty {
	return &ConnectionFilterProperty{typeName: "connectionFilterPropertyThree", ConnectionFilterPropertyThree: value}
}

func (c *ConnectionFilterProperty) UnmarshalJSON(data []byte) error {
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		c.typeName = "stringOptional"
		c.StringOptional = valueStringOptional
		return nil
	}
	var valueDouble float64
	if err := json.Unmarshal(data, &valueDouble); err == nil {
		c.typeName = "double"
		c.Double = valueDouble
		return nil
	}
	var valueBoolean bool
	if err := json.Unmarshal(data, &valueBoolean); err == nil {
		c.typeName = "boolean"
		c.Boolean = valueBoolean
		return nil
	}
	valueConnectionFilterPropertyThree := new(ConnectionFilterPropertyThree)
	if err := json.Unmarshal(data, &valueConnectionFilterPropertyThree); err == nil {
		c.typeName = "connectionFilterPropertyThree"
		c.ConnectionFilterPropertyThree = valueConnectionFilterPropertyThree
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ConnectionFilterProperty) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "stringOptional":
		return json.Marshal(c.StringOptional)
	case "double":
		return json.Marshal(c.Double)
	case "boolean":
		return json.Marshal(c.Boolean)
	case "connectionFilterPropertyThree":
		return json.Marshal(c.ConnectionFilterPropertyThree)
	}
}

type ConnectionFilterPropertyVisitor interface {
	VisitStringOptional(*string) error
	VisitDouble(float64) error
	VisitBoolean(bool) error
	VisitConnectionFilterPropertyThree(*ConnectionFilterPropertyThree) error
}

func (c *ConnectionFilterProperty) Accept(visitor ConnectionFilterPropertyVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "stringOptional":
		return visitor.VisitStringOptional(c.StringOptional)
	case "double":
		return visitor.VisitDouble(c.Double)
	case "boolean":
		return visitor.VisitBoolean(c.Boolean)
	case "connectionFilterPropertyThree":
		return visitor.VisitConnectionFilterPropertyThree(c.ConnectionFilterPropertyThree)
	}
}

type ConnectionFilterPropertyThree struct {
}

type ConnectionPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Connection   `json:"models,omitempty"`
}

type ConsoleLine struct {
	Type    ConsoleLineType `json:"type,omitempty"`
	Message string          `json:"message"`
}

type ConsoleLineType uint

const (
	ConsoleLineTypeError ConsoleLineType = iota + 1
	ConsoleLineTypeLog
	ConsoleLineTypeWarn
	ConsoleLineTypeInfo
	ConsoleLineTypeDebug
)

func (c ConsoleLineType) String() string {
	switch c {
	default:
		return strconv.Itoa(int(c))
	case ConsoleLineTypeError:
		return "error"
	case ConsoleLineTypeLog:
		return "log"
	case ConsoleLineTypeWarn:
		return "warn"
	case ConsoleLineTypeInfo:
		return "info"
	case ConsoleLineTypeDebug:
		return "debug"
	}
}

func (c ConsoleLineType) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", c.String())), nil
}

func (c *ConsoleLineType) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "error":
		value := ConsoleLineTypeError
		*c = value
	case "log":
		value := ConsoleLineTypeLog
		*c = value
	case "warn":
		value := ConsoleLineTypeWarn
		*c = value
	case "info":
		value := ConsoleLineTypeInfo
		*c = value
	case "debug":
		value := ConsoleLineTypeDebug
		*c = value
	}
	return nil
}

// Destination input object
type CreateConnectionRequestDestination struct {
	// Name for the destination <span style="white-space: nowrap">`<= 155 characters`</span>
	Name string `json:"name"`
	// Description for the destination
	Description *string `json:"description,omitempty"`
	// Endpoint of the destination
	Url *string `json:"url,omitempty"`
	// Path for the CLI destination
	CliPath *string `json:"cli_path,omitempty"`
	// Period to rate limit attempts
	RateLimitPeriod *CreateConnectionRequestDestinationRateLimitPeriod `json:"rate_limit_period,omitempty"`
	// Limit event attempts to receive per period
	RateLimit              *int                         `json:"rate_limit,omitempty"`
	HttpMethod             *DestinationHttpMethod       `json:"http_method,omitempty"`
	AuthMethod             *DestinationAuthMethodConfig `json:"auth_method,omitempty"`
	PathForwardingDisabled *bool                        `json:"path_forwarding_disabled,omitempty"`
}

// Period to rate limit attempts
type CreateConnectionRequestDestinationRateLimitPeriod uint

const (
	CreateConnectionRequestDestinationRateLimitPeriodSecond CreateConnectionRequestDestinationRateLimitPeriod = iota + 1
	CreateConnectionRequestDestinationRateLimitPeriodMinute
	CreateConnectionRequestDestinationRateLimitPeriodHour
)

func (c CreateConnectionRequestDestinationRateLimitPeriod) String() string {
	switch c {
	default:
		return strconv.Itoa(int(c))
	case CreateConnectionRequestDestinationRateLimitPeriodSecond:
		return "second"
	case CreateConnectionRequestDestinationRateLimitPeriodMinute:
		return "minute"
	case CreateConnectionRequestDestinationRateLimitPeriodHour:
		return "hour"
	}
}

func (c CreateConnectionRequestDestinationRateLimitPeriod) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", c.String())), nil
}

func (c *CreateConnectionRequestDestinationRateLimitPeriod) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "second":
		value := CreateConnectionRequestDestinationRateLimitPeriodSecond
		*c = value
	case "minute":
		value := CreateConnectionRequestDestinationRateLimitPeriodMinute
		*c = value
	case "hour":
		value := CreateConnectionRequestDestinationRateLimitPeriodHour
		*c = value
	}
	return nil
}

// Source input object
type CreateConnectionRequestSource struct {
	// A unique name for the source <span style="white-space: nowrap">`<= 155 characters`</span>
	Name string `json:"name"`
	// Description for the source
	Description        *string                  `json:"description,omitempty"`
	AllowedHttpMethods *SourceAllowedHttpMethod `json:"allowed_http_methods,omitempty"`
	CustomResponse     *SourceCustomResponse    `json:"custom_response,omitempty"`
	Verification       *VerificationConfig      `json:"verification,omitempty"`
}

// Period to rate limit attempts
type CreateDestinationRequestRateLimitPeriod uint

const (
	CreateDestinationRequestRateLimitPeriodSecond CreateDestinationRequestRateLimitPeriod = iota + 1
	CreateDestinationRequestRateLimitPeriodMinute
	CreateDestinationRequestRateLimitPeriodHour
)

func (c CreateDestinationRequestRateLimitPeriod) String() string {
	switch c {
	default:
		return strconv.Itoa(int(c))
	case CreateDestinationRequestRateLimitPeriodSecond:
		return "second"
	case CreateDestinationRequestRateLimitPeriodMinute:
		return "minute"
	case CreateDestinationRequestRateLimitPeriodHour:
		return "hour"
	}
}

func (c CreateDestinationRequestRateLimitPeriod) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", c.String())), nil
}

func (c *CreateDestinationRequestRateLimitPeriod) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "second":
		value := CreateDestinationRequestRateLimitPeriodSecond
		*c = value
	case "minute":
		value := CreateDestinationRequestRateLimitPeriodMinute
		*c = value
	case "hour":
		value := CreateDestinationRequestRateLimitPeriodHour
		*c = value
	}
	return nil
}

// Filter properties for the events to be included in the bulk retry
type CreateEventBulkRetryRequestQuery struct {
	// Filter by event IDs
	Id *CreateEventBulkRetryRequestQueryId `json:"id,omitempty"`
	// Lifecyle status of the event
	Status *CreateEventBulkRetryRequestQueryStatus `json:"status,omitempty"`
	// Filter by webhook connection IDs
	WebhookId *CreateEventBulkRetryRequestQueryWebhookId `json:"webhook_id,omitempty"`
	// Filter by destination IDs
	DestinationId *CreateEventBulkRetryRequestQueryDestinationId `json:"destination_id,omitempty"`
	// Filter by source IDs
	SourceId *CreateEventBulkRetryRequestQuerySourceId `json:"source_id,omitempty"`
	// Filter by number of attempts
	Attempts *CreateEventBulkRetryRequestQueryAttempts `json:"attempts,omitempty"`
	// Filter by HTTP response status code
	ResponseStatus *CreateEventBulkRetryRequestQueryResponseStatus `json:"response_status,omitempty"`
	// Filter by `successful_at` date using a date operator
	SuccessfulAt *CreateEventBulkRetryRequestQuerySuccessfulAt `json:"successful_at,omitempty"`
	// Filter by `created_at` date using a date operator
	CreatedAt *CreateEventBulkRetryRequestQueryCreatedAt `json:"created_at,omitempty"`
	// Filter by error code code
	ErrorCode *CreateEventBulkRetryRequestQueryErrorCode `json:"error_code,omitempty"`
	// Filter by CLI IDs. `?[any]=true` operator for any CLI.
	CliId *CreateEventBulkRetryRequestQueryCliId `json:"cli_id,omitempty"`
	// Filter by `last_attempt_at` date using a date operator
	LastAttemptAt *CreateEventBulkRetryRequestQueryLastAttemptAt `json:"last_attempt_at,omitempty"`
	// URL Encoded string of the value to match partially to the body, headers, parsed_query or path
	SearchTerm *string `json:"search_term,omitempty"`
	// URL Encoded string of the JSON to match to the data headers
	Headers *CreateEventBulkRetryRequestQueryHeaders `json:"headers,omitempty"`
	// URL Encoded string of the JSON to match to the data body
	Body *CreateEventBulkRetryRequestQueryBody `json:"body,omitempty"`
	// URL Encoded string of the JSON to match to the parsed query (JSON representation of the query)
	ParsedQuery *CreateEventBulkRetryRequestQueryParsedQuery `json:"parsed_query,omitempty"`
	// URL Encoded string of the value to match partially to the path
	Path        *string                                      `json:"path,omitempty"`
	CliUserId   *CreateEventBulkRetryRequestQueryCliUserId   `json:"cli_user_id,omitempty"`
	IssueId     *CreateEventBulkRetryRequestQueryIssueId     `json:"issue_id,omitempty"`
	EventDataId *CreateEventBulkRetryRequestQueryEventDataId `json:"event_data_id,omitempty"`
	BulkRetryId *CreateEventBulkRetryRequestQueryBulkRetryId `json:"bulk_retry_id,omitempty"`
}

// Filter by number of attempts
type CreateEventBulkRetryRequestQueryAttempts struct {
	typeName                                    string
	Integer                                     int
	CreateEventBulkRetryRequestQueryAttemptsAny *CreateEventBulkRetryRequestQueryAttemptsAny
}

func NewCreateEventBulkRetryRequestQueryAttemptsFromInteger(value int) *CreateEventBulkRetryRequestQueryAttempts {
	return &CreateEventBulkRetryRequestQueryAttempts{typeName: "integer", Integer: value}
}

func NewCreateEventBulkRetryRequestQueryAttemptsFromCreateEventBulkRetryRequestQueryAttemptsAny(value *CreateEventBulkRetryRequestQueryAttemptsAny) *CreateEventBulkRetryRequestQueryAttempts {
	return &CreateEventBulkRetryRequestQueryAttempts{typeName: "createEventBulkRetryRequestQueryAttemptsAny", CreateEventBulkRetryRequestQueryAttemptsAny: value}
}

func (c *CreateEventBulkRetryRequestQueryAttempts) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		c.typeName = "integer"
		c.Integer = valueInteger
		return nil
	}
	valueCreateEventBulkRetryRequestQueryAttemptsAny := new(CreateEventBulkRetryRequestQueryAttemptsAny)
	if err := json.Unmarshal(data, &valueCreateEventBulkRetryRequestQueryAttemptsAny); err == nil {
		c.typeName = "createEventBulkRetryRequestQueryAttemptsAny"
		c.CreateEventBulkRetryRequestQueryAttemptsAny = valueCreateEventBulkRetryRequestQueryAttemptsAny
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateEventBulkRetryRequestQueryAttempts) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "integer":
		return json.Marshal(c.Integer)
	case "createEventBulkRetryRequestQueryAttemptsAny":
		return json.Marshal(c.CreateEventBulkRetryRequestQueryAttemptsAny)
	}
}

type CreateEventBulkRetryRequestQueryAttemptsVisitor interface {
	VisitInteger(int) error
	VisitCreateEventBulkRetryRequestQueryAttemptsAny(*CreateEventBulkRetryRequestQueryAttemptsAny) error
}

func (c *CreateEventBulkRetryRequestQueryAttempts) Accept(visitor CreateEventBulkRetryRequestQueryAttemptsVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "integer":
		return visitor.VisitInteger(c.Integer)
	case "createEventBulkRetryRequestQueryAttemptsAny":
		return visitor.VisitCreateEventBulkRetryRequestQueryAttemptsAny(c.CreateEventBulkRetryRequestQueryAttemptsAny)
	}
}

type CreateEventBulkRetryRequestQueryAttemptsAny struct {
	Gt       *int  `json:"gt,omitempty"`
	Gte      *int  `json:"gte,omitempty"`
	Le       *int  `json:"le,omitempty"`
	Lte      *int  `json:"lte,omitempty"`
	Any      *bool `json:"any,omitempty"`
	Contains *int  `json:"contains,omitempty"`
}

// URL Encoded string of the JSON to match to the data body
type CreateEventBulkRetryRequestQueryBody struct {
	typeName                                string
	String                                  string
	CreateEventBulkRetryRequestQueryBodyOne *CreateEventBulkRetryRequestQueryBodyOne
}

func NewCreateEventBulkRetryRequestQueryBodyFromString(value string) *CreateEventBulkRetryRequestQueryBody {
	return &CreateEventBulkRetryRequestQueryBody{typeName: "string", String: value}
}

func NewCreateEventBulkRetryRequestQueryBodyFromCreateEventBulkRetryRequestQueryBodyOne(value *CreateEventBulkRetryRequestQueryBodyOne) *CreateEventBulkRetryRequestQueryBody {
	return &CreateEventBulkRetryRequestQueryBody{typeName: "createEventBulkRetryRequestQueryBodyOne", CreateEventBulkRetryRequestQueryBodyOne: value}
}

func (c *CreateEventBulkRetryRequestQueryBody) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valueCreateEventBulkRetryRequestQueryBodyOne := new(CreateEventBulkRetryRequestQueryBodyOne)
	if err := json.Unmarshal(data, &valueCreateEventBulkRetryRequestQueryBodyOne); err == nil {
		c.typeName = "createEventBulkRetryRequestQueryBodyOne"
		c.CreateEventBulkRetryRequestQueryBodyOne = valueCreateEventBulkRetryRequestQueryBodyOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateEventBulkRetryRequestQueryBody) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "createEventBulkRetryRequestQueryBodyOne":
		return json.Marshal(c.CreateEventBulkRetryRequestQueryBodyOne)
	}
}

type CreateEventBulkRetryRequestQueryBodyVisitor interface {
	VisitString(string) error
	VisitCreateEventBulkRetryRequestQueryBodyOne(*CreateEventBulkRetryRequestQueryBodyOne) error
}

func (c *CreateEventBulkRetryRequestQueryBody) Accept(visitor CreateEventBulkRetryRequestQueryBodyVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "createEventBulkRetryRequestQueryBodyOne":
		return visitor.VisitCreateEventBulkRetryRequestQueryBodyOne(c.CreateEventBulkRetryRequestQueryBodyOne)
	}
}

type CreateEventBulkRetryRequestQueryBodyOne struct {
}

type CreateEventBulkRetryRequestQueryBulkRetryId struct {
	typeName string
	// <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewCreateEventBulkRetryRequestQueryBulkRetryIdFromString(value string) *CreateEventBulkRetryRequestQueryBulkRetryId {
	return &CreateEventBulkRetryRequestQueryBulkRetryId{typeName: "string", String: value}
}

func NewCreateEventBulkRetryRequestQueryBulkRetryIdFromStringList(value []string) *CreateEventBulkRetryRequestQueryBulkRetryId {
	return &CreateEventBulkRetryRequestQueryBulkRetryId{typeName: "stringList", StringList: value}
}

func (c *CreateEventBulkRetryRequestQueryBulkRetryId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		c.typeName = "stringList"
		c.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateEventBulkRetryRequestQueryBulkRetryId) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "stringList":
		return json.Marshal(c.StringList)
	}
}

type CreateEventBulkRetryRequestQueryBulkRetryIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (c *CreateEventBulkRetryRequestQueryBulkRetryId) Accept(visitor CreateEventBulkRetryRequestQueryBulkRetryIdVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "stringList":
		return visitor.VisitStringList(c.StringList)
	}
}

// Filter by CLI IDs. `?[any]=true` operator for any CLI.
type CreateEventBulkRetryRequestQueryCliId struct {
	typeName                                 string
	String                                   string
	CreateEventBulkRetryRequestQueryCliIdAny *CreateEventBulkRetryRequestQueryCliIdAny
	StringList                               []string
}

func NewCreateEventBulkRetryRequestQueryCliIdFromString(value string) *CreateEventBulkRetryRequestQueryCliId {
	return &CreateEventBulkRetryRequestQueryCliId{typeName: "string", String: value}
}

func NewCreateEventBulkRetryRequestQueryCliIdFromCreateEventBulkRetryRequestQueryCliIdAny(value *CreateEventBulkRetryRequestQueryCliIdAny) *CreateEventBulkRetryRequestQueryCliId {
	return &CreateEventBulkRetryRequestQueryCliId{typeName: "createEventBulkRetryRequestQueryCliIdAny", CreateEventBulkRetryRequestQueryCliIdAny: value}
}

func NewCreateEventBulkRetryRequestQueryCliIdFromStringList(value []string) *CreateEventBulkRetryRequestQueryCliId {
	return &CreateEventBulkRetryRequestQueryCliId{typeName: "stringList", StringList: value}
}

func (c *CreateEventBulkRetryRequestQueryCliId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valueCreateEventBulkRetryRequestQueryCliIdAny := new(CreateEventBulkRetryRequestQueryCliIdAny)
	if err := json.Unmarshal(data, &valueCreateEventBulkRetryRequestQueryCliIdAny); err == nil {
		c.typeName = "createEventBulkRetryRequestQueryCliIdAny"
		c.CreateEventBulkRetryRequestQueryCliIdAny = valueCreateEventBulkRetryRequestQueryCliIdAny
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		c.typeName = "stringList"
		c.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateEventBulkRetryRequestQueryCliId) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "createEventBulkRetryRequestQueryCliIdAny":
		return json.Marshal(c.CreateEventBulkRetryRequestQueryCliIdAny)
	case "stringList":
		return json.Marshal(c.StringList)
	}
}

type CreateEventBulkRetryRequestQueryCliIdVisitor interface {
	VisitString(string) error
	VisitCreateEventBulkRetryRequestQueryCliIdAny(*CreateEventBulkRetryRequestQueryCliIdAny) error
	VisitStringList([]string) error
}

func (c *CreateEventBulkRetryRequestQueryCliId) Accept(visitor CreateEventBulkRetryRequestQueryCliIdVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "createEventBulkRetryRequestQueryCliIdAny":
		return visitor.VisitCreateEventBulkRetryRequestQueryCliIdAny(c.CreateEventBulkRetryRequestQueryCliIdAny)
	case "stringList":
		return visitor.VisitStringList(c.StringList)
	}
}

type CreateEventBulkRetryRequestQueryCliIdAny struct {
	Any *bool `json:"any,omitempty"`
}

type CreateEventBulkRetryRequestQueryCliUserId struct {
	typeName   string
	String     string
	StringList []string
}

func NewCreateEventBulkRetryRequestQueryCliUserIdFromString(value string) *CreateEventBulkRetryRequestQueryCliUserId {
	return &CreateEventBulkRetryRequestQueryCliUserId{typeName: "string", String: value}
}

func NewCreateEventBulkRetryRequestQueryCliUserIdFromStringList(value []string) *CreateEventBulkRetryRequestQueryCliUserId {
	return &CreateEventBulkRetryRequestQueryCliUserId{typeName: "stringList", StringList: value}
}

func (c *CreateEventBulkRetryRequestQueryCliUserId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		c.typeName = "stringList"
		c.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateEventBulkRetryRequestQueryCliUserId) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "stringList":
		return json.Marshal(c.StringList)
	}
}

type CreateEventBulkRetryRequestQueryCliUserIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (c *CreateEventBulkRetryRequestQueryCliUserId) Accept(visitor CreateEventBulkRetryRequestQueryCliUserIdVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "stringList":
		return visitor.VisitStringList(c.StringList)
	}
}

// Filter by `created_at` date using a date operator
type CreateEventBulkRetryRequestQueryCreatedAt struct {
	typeName                                     string
	DateTime                                     time.Time
	CreateEventBulkRetryRequestQueryCreatedAtAny *CreateEventBulkRetryRequestQueryCreatedAtAny
}

func NewCreateEventBulkRetryRequestQueryCreatedAtFromDateTime(value time.Time) *CreateEventBulkRetryRequestQueryCreatedAt {
	return &CreateEventBulkRetryRequestQueryCreatedAt{typeName: "dateTime", DateTime: value}
}

func NewCreateEventBulkRetryRequestQueryCreatedAtFromCreateEventBulkRetryRequestQueryCreatedAtAny(value *CreateEventBulkRetryRequestQueryCreatedAtAny) *CreateEventBulkRetryRequestQueryCreatedAt {
	return &CreateEventBulkRetryRequestQueryCreatedAt{typeName: "createEventBulkRetryRequestQueryCreatedAtAny", CreateEventBulkRetryRequestQueryCreatedAtAny: value}
}

func (c *CreateEventBulkRetryRequestQueryCreatedAt) UnmarshalJSON(data []byte) error {
	var valueDateTime time.Time
	if err := json.Unmarshal(data, &valueDateTime); err == nil {
		c.typeName = "dateTime"
		c.DateTime = valueDateTime
		return nil
	}
	valueCreateEventBulkRetryRequestQueryCreatedAtAny := new(CreateEventBulkRetryRequestQueryCreatedAtAny)
	if err := json.Unmarshal(data, &valueCreateEventBulkRetryRequestQueryCreatedAtAny); err == nil {
		c.typeName = "createEventBulkRetryRequestQueryCreatedAtAny"
		c.CreateEventBulkRetryRequestQueryCreatedAtAny = valueCreateEventBulkRetryRequestQueryCreatedAtAny
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateEventBulkRetryRequestQueryCreatedAt) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "dateTime":
		return json.Marshal(c.DateTime)
	case "createEventBulkRetryRequestQueryCreatedAtAny":
		return json.Marshal(c.CreateEventBulkRetryRequestQueryCreatedAtAny)
	}
}

type CreateEventBulkRetryRequestQueryCreatedAtVisitor interface {
	VisitDateTime(time.Time) error
	VisitCreateEventBulkRetryRequestQueryCreatedAtAny(*CreateEventBulkRetryRequestQueryCreatedAtAny) error
}

func (c *CreateEventBulkRetryRequestQueryCreatedAt) Accept(visitor CreateEventBulkRetryRequestQueryCreatedAtVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "dateTime":
		return visitor.VisitDateTime(c.DateTime)
	case "createEventBulkRetryRequestQueryCreatedAtAny":
		return visitor.VisitCreateEventBulkRetryRequestQueryCreatedAtAny(c.CreateEventBulkRetryRequestQueryCreatedAtAny)
	}
}

type CreateEventBulkRetryRequestQueryCreatedAtAny struct {
	Gt  *time.Time `json:"gt,omitempty"`
	Gte *time.Time `json:"gte,omitempty"`
	Le  *time.Time `json:"le,omitempty"`
	Lte *time.Time `json:"lte,omitempty"`
	Any *bool      `json:"any,omitempty"`
}

// Filter by destination IDs
type CreateEventBulkRetryRequestQueryDestinationId struct {
	typeName string
	// Destination ID <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewCreateEventBulkRetryRequestQueryDestinationIdFromString(value string) *CreateEventBulkRetryRequestQueryDestinationId {
	return &CreateEventBulkRetryRequestQueryDestinationId{typeName: "string", String: value}
}

func NewCreateEventBulkRetryRequestQueryDestinationIdFromStringList(value []string) *CreateEventBulkRetryRequestQueryDestinationId {
	return &CreateEventBulkRetryRequestQueryDestinationId{typeName: "stringList", StringList: value}
}

func (c *CreateEventBulkRetryRequestQueryDestinationId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		c.typeName = "stringList"
		c.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateEventBulkRetryRequestQueryDestinationId) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "stringList":
		return json.Marshal(c.StringList)
	}
}

type CreateEventBulkRetryRequestQueryDestinationIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (c *CreateEventBulkRetryRequestQueryDestinationId) Accept(visitor CreateEventBulkRetryRequestQueryDestinationIdVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "stringList":
		return visitor.VisitStringList(c.StringList)
	}
}

// Filter by error code code
type CreateEventBulkRetryRequestQueryErrorCode struct {
	typeName              string
	AttemptErrorCodes     AttemptErrorCodes
	AttemptErrorCodesList []AttemptErrorCodes
}

func NewCreateEventBulkRetryRequestQueryErrorCodeFromAttemptErrorCodes(value AttemptErrorCodes) *CreateEventBulkRetryRequestQueryErrorCode {
	return &CreateEventBulkRetryRequestQueryErrorCode{typeName: "attemptErrorCodes", AttemptErrorCodes: value}
}

func NewCreateEventBulkRetryRequestQueryErrorCodeFromAttemptErrorCodesList(value []AttemptErrorCodes) *CreateEventBulkRetryRequestQueryErrorCode {
	return &CreateEventBulkRetryRequestQueryErrorCode{typeName: "attemptErrorCodesList", AttemptErrorCodesList: value}
}

func (c *CreateEventBulkRetryRequestQueryErrorCode) UnmarshalJSON(data []byte) error {
	var valueAttemptErrorCodes AttemptErrorCodes
	if err := json.Unmarshal(data, &valueAttemptErrorCodes); err == nil {
		c.typeName = "attemptErrorCodes"
		c.AttemptErrorCodes = valueAttemptErrorCodes
		return nil
	}
	var valueAttemptErrorCodesList []AttemptErrorCodes
	if err := json.Unmarshal(data, &valueAttemptErrorCodesList); err == nil {
		c.typeName = "attemptErrorCodesList"
		c.AttemptErrorCodesList = valueAttemptErrorCodesList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateEventBulkRetryRequestQueryErrorCode) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "attemptErrorCodes":
		return json.Marshal(c.AttemptErrorCodes)
	case "attemptErrorCodesList":
		return json.Marshal(c.AttemptErrorCodesList)
	}
}

type CreateEventBulkRetryRequestQueryErrorCodeVisitor interface {
	VisitAttemptErrorCodes(AttemptErrorCodes) error
	VisitAttemptErrorCodesList([]AttemptErrorCodes) error
}

func (c *CreateEventBulkRetryRequestQueryErrorCode) Accept(visitor CreateEventBulkRetryRequestQueryErrorCodeVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "attemptErrorCodes":
		return visitor.VisitAttemptErrorCodes(c.AttemptErrorCodes)
	case "attemptErrorCodesList":
		return visitor.VisitAttemptErrorCodesList(c.AttemptErrorCodesList)
	}
}

type CreateEventBulkRetryRequestQueryEventDataId struct {
	typeName string
	// <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewCreateEventBulkRetryRequestQueryEventDataIdFromString(value string) *CreateEventBulkRetryRequestQueryEventDataId {
	return &CreateEventBulkRetryRequestQueryEventDataId{typeName: "string", String: value}
}

func NewCreateEventBulkRetryRequestQueryEventDataIdFromStringList(value []string) *CreateEventBulkRetryRequestQueryEventDataId {
	return &CreateEventBulkRetryRequestQueryEventDataId{typeName: "stringList", StringList: value}
}

func (c *CreateEventBulkRetryRequestQueryEventDataId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		c.typeName = "stringList"
		c.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateEventBulkRetryRequestQueryEventDataId) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "stringList":
		return json.Marshal(c.StringList)
	}
}

type CreateEventBulkRetryRequestQueryEventDataIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (c *CreateEventBulkRetryRequestQueryEventDataId) Accept(visitor CreateEventBulkRetryRequestQueryEventDataIdVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "stringList":
		return visitor.VisitStringList(c.StringList)
	}
}

// URL Encoded string of the JSON to match to the data headers
type CreateEventBulkRetryRequestQueryHeaders struct {
	typeName                                   string
	String                                     string
	CreateEventBulkRetryRequestQueryHeadersOne *CreateEventBulkRetryRequestQueryHeadersOne
}

func NewCreateEventBulkRetryRequestQueryHeadersFromString(value string) *CreateEventBulkRetryRequestQueryHeaders {
	return &CreateEventBulkRetryRequestQueryHeaders{typeName: "string", String: value}
}

func NewCreateEventBulkRetryRequestQueryHeadersFromCreateEventBulkRetryRequestQueryHeadersOne(value *CreateEventBulkRetryRequestQueryHeadersOne) *CreateEventBulkRetryRequestQueryHeaders {
	return &CreateEventBulkRetryRequestQueryHeaders{typeName: "createEventBulkRetryRequestQueryHeadersOne", CreateEventBulkRetryRequestQueryHeadersOne: value}
}

func (c *CreateEventBulkRetryRequestQueryHeaders) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valueCreateEventBulkRetryRequestQueryHeadersOne := new(CreateEventBulkRetryRequestQueryHeadersOne)
	if err := json.Unmarshal(data, &valueCreateEventBulkRetryRequestQueryHeadersOne); err == nil {
		c.typeName = "createEventBulkRetryRequestQueryHeadersOne"
		c.CreateEventBulkRetryRequestQueryHeadersOne = valueCreateEventBulkRetryRequestQueryHeadersOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateEventBulkRetryRequestQueryHeaders) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "createEventBulkRetryRequestQueryHeadersOne":
		return json.Marshal(c.CreateEventBulkRetryRequestQueryHeadersOne)
	}
}

type CreateEventBulkRetryRequestQueryHeadersVisitor interface {
	VisitString(string) error
	VisitCreateEventBulkRetryRequestQueryHeadersOne(*CreateEventBulkRetryRequestQueryHeadersOne) error
}

func (c *CreateEventBulkRetryRequestQueryHeaders) Accept(visitor CreateEventBulkRetryRequestQueryHeadersVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "createEventBulkRetryRequestQueryHeadersOne":
		return visitor.VisitCreateEventBulkRetryRequestQueryHeadersOne(c.CreateEventBulkRetryRequestQueryHeadersOne)
	}
}

type CreateEventBulkRetryRequestQueryHeadersOne struct {
}

// Filter by event IDs
type CreateEventBulkRetryRequestQueryId struct {
	typeName string
	// Event ID <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewCreateEventBulkRetryRequestQueryIdFromString(value string) *CreateEventBulkRetryRequestQueryId {
	return &CreateEventBulkRetryRequestQueryId{typeName: "string", String: value}
}

func NewCreateEventBulkRetryRequestQueryIdFromStringList(value []string) *CreateEventBulkRetryRequestQueryId {
	return &CreateEventBulkRetryRequestQueryId{typeName: "stringList", StringList: value}
}

func (c *CreateEventBulkRetryRequestQueryId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		c.typeName = "stringList"
		c.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateEventBulkRetryRequestQueryId) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "stringList":
		return json.Marshal(c.StringList)
	}
}

type CreateEventBulkRetryRequestQueryIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (c *CreateEventBulkRetryRequestQueryId) Accept(visitor CreateEventBulkRetryRequestQueryIdVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "stringList":
		return visitor.VisitStringList(c.StringList)
	}
}

type CreateEventBulkRetryRequestQueryIssueId struct {
	typeName string
	// <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewCreateEventBulkRetryRequestQueryIssueIdFromString(value string) *CreateEventBulkRetryRequestQueryIssueId {
	return &CreateEventBulkRetryRequestQueryIssueId{typeName: "string", String: value}
}

func NewCreateEventBulkRetryRequestQueryIssueIdFromStringList(value []string) *CreateEventBulkRetryRequestQueryIssueId {
	return &CreateEventBulkRetryRequestQueryIssueId{typeName: "stringList", StringList: value}
}

func (c *CreateEventBulkRetryRequestQueryIssueId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		c.typeName = "stringList"
		c.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateEventBulkRetryRequestQueryIssueId) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "stringList":
		return json.Marshal(c.StringList)
	}
}

type CreateEventBulkRetryRequestQueryIssueIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (c *CreateEventBulkRetryRequestQueryIssueId) Accept(visitor CreateEventBulkRetryRequestQueryIssueIdVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "stringList":
		return visitor.VisitStringList(c.StringList)
	}
}

// Filter by `last_attempt_at` date using a date operator
type CreateEventBulkRetryRequestQueryLastAttemptAt struct {
	typeName                                         string
	DateTime                                         time.Time
	CreateEventBulkRetryRequestQueryLastAttemptAtAny *CreateEventBulkRetryRequestQueryLastAttemptAtAny
}

func NewCreateEventBulkRetryRequestQueryLastAttemptAtFromDateTime(value time.Time) *CreateEventBulkRetryRequestQueryLastAttemptAt {
	return &CreateEventBulkRetryRequestQueryLastAttemptAt{typeName: "dateTime", DateTime: value}
}

func NewCreateEventBulkRetryRequestQueryLastAttemptAtFromCreateEventBulkRetryRequestQueryLastAttemptAtAny(value *CreateEventBulkRetryRequestQueryLastAttemptAtAny) *CreateEventBulkRetryRequestQueryLastAttemptAt {
	return &CreateEventBulkRetryRequestQueryLastAttemptAt{typeName: "createEventBulkRetryRequestQueryLastAttemptAtAny", CreateEventBulkRetryRequestQueryLastAttemptAtAny: value}
}

func (c *CreateEventBulkRetryRequestQueryLastAttemptAt) UnmarshalJSON(data []byte) error {
	var valueDateTime time.Time
	if err := json.Unmarshal(data, &valueDateTime); err == nil {
		c.typeName = "dateTime"
		c.DateTime = valueDateTime
		return nil
	}
	valueCreateEventBulkRetryRequestQueryLastAttemptAtAny := new(CreateEventBulkRetryRequestQueryLastAttemptAtAny)
	if err := json.Unmarshal(data, &valueCreateEventBulkRetryRequestQueryLastAttemptAtAny); err == nil {
		c.typeName = "createEventBulkRetryRequestQueryLastAttemptAtAny"
		c.CreateEventBulkRetryRequestQueryLastAttemptAtAny = valueCreateEventBulkRetryRequestQueryLastAttemptAtAny
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateEventBulkRetryRequestQueryLastAttemptAt) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "dateTime":
		return json.Marshal(c.DateTime)
	case "createEventBulkRetryRequestQueryLastAttemptAtAny":
		return json.Marshal(c.CreateEventBulkRetryRequestQueryLastAttemptAtAny)
	}
}

type CreateEventBulkRetryRequestQueryLastAttemptAtVisitor interface {
	VisitDateTime(time.Time) error
	VisitCreateEventBulkRetryRequestQueryLastAttemptAtAny(*CreateEventBulkRetryRequestQueryLastAttemptAtAny) error
}

func (c *CreateEventBulkRetryRequestQueryLastAttemptAt) Accept(visitor CreateEventBulkRetryRequestQueryLastAttemptAtVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "dateTime":
		return visitor.VisitDateTime(c.DateTime)
	case "createEventBulkRetryRequestQueryLastAttemptAtAny":
		return visitor.VisitCreateEventBulkRetryRequestQueryLastAttemptAtAny(c.CreateEventBulkRetryRequestQueryLastAttemptAtAny)
	}
}

type CreateEventBulkRetryRequestQueryLastAttemptAtAny struct {
	Gt  *time.Time `json:"gt,omitempty"`
	Gte *time.Time `json:"gte,omitempty"`
	Le  *time.Time `json:"le,omitempty"`
	Lte *time.Time `json:"lte,omitempty"`
	Any *bool      `json:"any,omitempty"`
}

// URL Encoded string of the JSON to match to the parsed query (JSON representation of the query)
type CreateEventBulkRetryRequestQueryParsedQuery struct {
	typeName                                       string
	String                                         string
	CreateEventBulkRetryRequestQueryParsedQueryOne *CreateEventBulkRetryRequestQueryParsedQueryOne
}

func NewCreateEventBulkRetryRequestQueryParsedQueryFromString(value string) *CreateEventBulkRetryRequestQueryParsedQuery {
	return &CreateEventBulkRetryRequestQueryParsedQuery{typeName: "string", String: value}
}

func NewCreateEventBulkRetryRequestQueryParsedQueryFromCreateEventBulkRetryRequestQueryParsedQueryOne(value *CreateEventBulkRetryRequestQueryParsedQueryOne) *CreateEventBulkRetryRequestQueryParsedQuery {
	return &CreateEventBulkRetryRequestQueryParsedQuery{typeName: "createEventBulkRetryRequestQueryParsedQueryOne", CreateEventBulkRetryRequestQueryParsedQueryOne: value}
}

func (c *CreateEventBulkRetryRequestQueryParsedQuery) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valueCreateEventBulkRetryRequestQueryParsedQueryOne := new(CreateEventBulkRetryRequestQueryParsedQueryOne)
	if err := json.Unmarshal(data, &valueCreateEventBulkRetryRequestQueryParsedQueryOne); err == nil {
		c.typeName = "createEventBulkRetryRequestQueryParsedQueryOne"
		c.CreateEventBulkRetryRequestQueryParsedQueryOne = valueCreateEventBulkRetryRequestQueryParsedQueryOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateEventBulkRetryRequestQueryParsedQuery) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "createEventBulkRetryRequestQueryParsedQueryOne":
		return json.Marshal(c.CreateEventBulkRetryRequestQueryParsedQueryOne)
	}
}

type CreateEventBulkRetryRequestQueryParsedQueryVisitor interface {
	VisitString(string) error
	VisitCreateEventBulkRetryRequestQueryParsedQueryOne(*CreateEventBulkRetryRequestQueryParsedQueryOne) error
}

func (c *CreateEventBulkRetryRequestQueryParsedQuery) Accept(visitor CreateEventBulkRetryRequestQueryParsedQueryVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "createEventBulkRetryRequestQueryParsedQueryOne":
		return visitor.VisitCreateEventBulkRetryRequestQueryParsedQueryOne(c.CreateEventBulkRetryRequestQueryParsedQueryOne)
	}
}

type CreateEventBulkRetryRequestQueryParsedQueryOne struct {
}

// Filter by HTTP response status code
type CreateEventBulkRetryRequestQueryResponseStatus struct {
	typeName                                          string
	Integer                                           int
	CreateEventBulkRetryRequestQueryResponseStatusAny *CreateEventBulkRetryRequestQueryResponseStatusAny
	IntegerList                                       []int
}

func NewCreateEventBulkRetryRequestQueryResponseStatusFromInteger(value int) *CreateEventBulkRetryRequestQueryResponseStatus {
	return &CreateEventBulkRetryRequestQueryResponseStatus{typeName: "integer", Integer: value}
}

func NewCreateEventBulkRetryRequestQueryResponseStatusFromCreateEventBulkRetryRequestQueryResponseStatusAny(value *CreateEventBulkRetryRequestQueryResponseStatusAny) *CreateEventBulkRetryRequestQueryResponseStatus {
	return &CreateEventBulkRetryRequestQueryResponseStatus{typeName: "createEventBulkRetryRequestQueryResponseStatusAny", CreateEventBulkRetryRequestQueryResponseStatusAny: value}
}

func NewCreateEventBulkRetryRequestQueryResponseStatusFromIntegerList(value []int) *CreateEventBulkRetryRequestQueryResponseStatus {
	return &CreateEventBulkRetryRequestQueryResponseStatus{typeName: "integerList", IntegerList: value}
}

func (c *CreateEventBulkRetryRequestQueryResponseStatus) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		c.typeName = "integer"
		c.Integer = valueInteger
		return nil
	}
	valueCreateEventBulkRetryRequestQueryResponseStatusAny := new(CreateEventBulkRetryRequestQueryResponseStatusAny)
	if err := json.Unmarshal(data, &valueCreateEventBulkRetryRequestQueryResponseStatusAny); err == nil {
		c.typeName = "createEventBulkRetryRequestQueryResponseStatusAny"
		c.CreateEventBulkRetryRequestQueryResponseStatusAny = valueCreateEventBulkRetryRequestQueryResponseStatusAny
		return nil
	}
	var valueIntegerList []int
	if err := json.Unmarshal(data, &valueIntegerList); err == nil {
		c.typeName = "integerList"
		c.IntegerList = valueIntegerList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateEventBulkRetryRequestQueryResponseStatus) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "integer":
		return json.Marshal(c.Integer)
	case "createEventBulkRetryRequestQueryResponseStatusAny":
		return json.Marshal(c.CreateEventBulkRetryRequestQueryResponseStatusAny)
	case "integerList":
		return json.Marshal(c.IntegerList)
	}
}

type CreateEventBulkRetryRequestQueryResponseStatusVisitor interface {
	VisitInteger(int) error
	VisitCreateEventBulkRetryRequestQueryResponseStatusAny(*CreateEventBulkRetryRequestQueryResponseStatusAny) error
	VisitIntegerList([]int) error
}

func (c *CreateEventBulkRetryRequestQueryResponseStatus) Accept(visitor CreateEventBulkRetryRequestQueryResponseStatusVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "integer":
		return visitor.VisitInteger(c.Integer)
	case "createEventBulkRetryRequestQueryResponseStatusAny":
		return visitor.VisitCreateEventBulkRetryRequestQueryResponseStatusAny(c.CreateEventBulkRetryRequestQueryResponseStatusAny)
	case "integerList":
		return visitor.VisitIntegerList(c.IntegerList)
	}
}

type CreateEventBulkRetryRequestQueryResponseStatusAny struct {
	Gt       *int  `json:"gt,omitempty"`
	Gte      *int  `json:"gte,omitempty"`
	Le       *int  `json:"le,omitempty"`
	Lte      *int  `json:"lte,omitempty"`
	Any      *bool `json:"any,omitempty"`
	Contains *int  `json:"contains,omitempty"`
}

// Filter by source IDs
type CreateEventBulkRetryRequestQuerySourceId struct {
	typeName string
	// Source ID <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewCreateEventBulkRetryRequestQuerySourceIdFromString(value string) *CreateEventBulkRetryRequestQuerySourceId {
	return &CreateEventBulkRetryRequestQuerySourceId{typeName: "string", String: value}
}

func NewCreateEventBulkRetryRequestQuerySourceIdFromStringList(value []string) *CreateEventBulkRetryRequestQuerySourceId {
	return &CreateEventBulkRetryRequestQuerySourceId{typeName: "stringList", StringList: value}
}

func (c *CreateEventBulkRetryRequestQuerySourceId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		c.typeName = "stringList"
		c.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateEventBulkRetryRequestQuerySourceId) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "stringList":
		return json.Marshal(c.StringList)
	}
}

type CreateEventBulkRetryRequestQuerySourceIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (c *CreateEventBulkRetryRequestQuerySourceId) Accept(visitor CreateEventBulkRetryRequestQuerySourceIdVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "stringList":
		return visitor.VisitStringList(c.StringList)
	}
}

// Lifecyle status of the event
type CreateEventBulkRetryRequestQueryStatus struct {
	typeName        string
	EventStatus     EventStatus
	EventStatusList []EventStatus
}

func NewCreateEventBulkRetryRequestQueryStatusFromEventStatus(value EventStatus) *CreateEventBulkRetryRequestQueryStatus {
	return &CreateEventBulkRetryRequestQueryStatus{typeName: "eventStatus", EventStatus: value}
}

func NewCreateEventBulkRetryRequestQueryStatusFromEventStatusList(value []EventStatus) *CreateEventBulkRetryRequestQueryStatus {
	return &CreateEventBulkRetryRequestQueryStatus{typeName: "eventStatusList", EventStatusList: value}
}

func (c *CreateEventBulkRetryRequestQueryStatus) UnmarshalJSON(data []byte) error {
	var valueEventStatus EventStatus
	if err := json.Unmarshal(data, &valueEventStatus); err == nil {
		c.typeName = "eventStatus"
		c.EventStatus = valueEventStatus
		return nil
	}
	var valueEventStatusList []EventStatus
	if err := json.Unmarshal(data, &valueEventStatusList); err == nil {
		c.typeName = "eventStatusList"
		c.EventStatusList = valueEventStatusList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateEventBulkRetryRequestQueryStatus) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "eventStatus":
		return json.Marshal(c.EventStatus)
	case "eventStatusList":
		return json.Marshal(c.EventStatusList)
	}
}

type CreateEventBulkRetryRequestQueryStatusVisitor interface {
	VisitEventStatus(EventStatus) error
	VisitEventStatusList([]EventStatus) error
}

func (c *CreateEventBulkRetryRequestQueryStatus) Accept(visitor CreateEventBulkRetryRequestQueryStatusVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "eventStatus":
		return visitor.VisitEventStatus(c.EventStatus)
	case "eventStatusList":
		return visitor.VisitEventStatusList(c.EventStatusList)
	}
}

// Filter by `successful_at` date using a date operator
type CreateEventBulkRetryRequestQuerySuccessfulAt struct {
	typeName                                        string
	DateTime                                        time.Time
	CreateEventBulkRetryRequestQuerySuccessfulAtAny *CreateEventBulkRetryRequestQuerySuccessfulAtAny
}

func NewCreateEventBulkRetryRequestQuerySuccessfulAtFromDateTime(value time.Time) *CreateEventBulkRetryRequestQuerySuccessfulAt {
	return &CreateEventBulkRetryRequestQuerySuccessfulAt{typeName: "dateTime", DateTime: value}
}

func NewCreateEventBulkRetryRequestQuerySuccessfulAtFromCreateEventBulkRetryRequestQuerySuccessfulAtAny(value *CreateEventBulkRetryRequestQuerySuccessfulAtAny) *CreateEventBulkRetryRequestQuerySuccessfulAt {
	return &CreateEventBulkRetryRequestQuerySuccessfulAt{typeName: "createEventBulkRetryRequestQuerySuccessfulAtAny", CreateEventBulkRetryRequestQuerySuccessfulAtAny: value}
}

func (c *CreateEventBulkRetryRequestQuerySuccessfulAt) UnmarshalJSON(data []byte) error {
	var valueDateTime time.Time
	if err := json.Unmarshal(data, &valueDateTime); err == nil {
		c.typeName = "dateTime"
		c.DateTime = valueDateTime
		return nil
	}
	valueCreateEventBulkRetryRequestQuerySuccessfulAtAny := new(CreateEventBulkRetryRequestQuerySuccessfulAtAny)
	if err := json.Unmarshal(data, &valueCreateEventBulkRetryRequestQuerySuccessfulAtAny); err == nil {
		c.typeName = "createEventBulkRetryRequestQuerySuccessfulAtAny"
		c.CreateEventBulkRetryRequestQuerySuccessfulAtAny = valueCreateEventBulkRetryRequestQuerySuccessfulAtAny
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateEventBulkRetryRequestQuerySuccessfulAt) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "dateTime":
		return json.Marshal(c.DateTime)
	case "createEventBulkRetryRequestQuerySuccessfulAtAny":
		return json.Marshal(c.CreateEventBulkRetryRequestQuerySuccessfulAtAny)
	}
}

type CreateEventBulkRetryRequestQuerySuccessfulAtVisitor interface {
	VisitDateTime(time.Time) error
	VisitCreateEventBulkRetryRequestQuerySuccessfulAtAny(*CreateEventBulkRetryRequestQuerySuccessfulAtAny) error
}

func (c *CreateEventBulkRetryRequestQuerySuccessfulAt) Accept(visitor CreateEventBulkRetryRequestQuerySuccessfulAtVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "dateTime":
		return visitor.VisitDateTime(c.DateTime)
	case "createEventBulkRetryRequestQuerySuccessfulAtAny":
		return visitor.VisitCreateEventBulkRetryRequestQuerySuccessfulAtAny(c.CreateEventBulkRetryRequestQuerySuccessfulAtAny)
	}
}

type CreateEventBulkRetryRequestQuerySuccessfulAtAny struct {
	Gt  *time.Time `json:"gt,omitempty"`
	Gte *time.Time `json:"gte,omitempty"`
	Le  *time.Time `json:"le,omitempty"`
	Lte *time.Time `json:"lte,omitempty"`
	Any *bool      `json:"any,omitempty"`
}

// Filter by webhook connection IDs
type CreateEventBulkRetryRequestQueryWebhookId struct {
	typeName string
	// Webhook ID <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewCreateEventBulkRetryRequestQueryWebhookIdFromString(value string) *CreateEventBulkRetryRequestQueryWebhookId {
	return &CreateEventBulkRetryRequestQueryWebhookId{typeName: "string", String: value}
}

func NewCreateEventBulkRetryRequestQueryWebhookIdFromStringList(value []string) *CreateEventBulkRetryRequestQueryWebhookId {
	return &CreateEventBulkRetryRequestQueryWebhookId{typeName: "stringList", StringList: value}
}

func (c *CreateEventBulkRetryRequestQueryWebhookId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		c.typeName = "stringList"
		c.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateEventBulkRetryRequestQueryWebhookId) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "stringList":
		return json.Marshal(c.StringList)
	}
}

type CreateEventBulkRetryRequestQueryWebhookIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (c *CreateEventBulkRetryRequestQueryWebhookId) Accept(visitor CreateEventBulkRetryRequestQueryWebhookIdVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "stringList":
		return visitor.VisitStringList(c.StringList)
	}
}

// Filter by the bulk retry ignored event query object
type CreateIgnoredEventBulkRetryRequestQuery struct {
	// The cause of the ignored event
	Cause *CreateIgnoredEventBulkRetryRequestQueryCause `json:"cause,omitempty"`
	// Connection ID of the ignored event
	WebhookId *CreateIgnoredEventBulkRetryRequestQueryWebhookId `json:"webhook_id,omitempty"`
	// The associated transformation ID (only applicable to the cause `TRANSFORMATION_FAILED`) <span style="white-space: nowrap">`<= 255 characters`</span>
	TransformationId *string `json:"transformation_id,omitempty"`
}

// The cause of the ignored event
type CreateIgnoredEventBulkRetryRequestQueryCause struct {
	typeName string
	// <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewCreateIgnoredEventBulkRetryRequestQueryCauseFromString(value string) *CreateIgnoredEventBulkRetryRequestQueryCause {
	return &CreateIgnoredEventBulkRetryRequestQueryCause{typeName: "string", String: value}
}

func NewCreateIgnoredEventBulkRetryRequestQueryCauseFromStringList(value []string) *CreateIgnoredEventBulkRetryRequestQueryCause {
	return &CreateIgnoredEventBulkRetryRequestQueryCause{typeName: "stringList", StringList: value}
}

func (c *CreateIgnoredEventBulkRetryRequestQueryCause) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		c.typeName = "stringList"
		c.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateIgnoredEventBulkRetryRequestQueryCause) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "stringList":
		return json.Marshal(c.StringList)
	}
}

type CreateIgnoredEventBulkRetryRequestQueryCauseVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (c *CreateIgnoredEventBulkRetryRequestQueryCause) Accept(visitor CreateIgnoredEventBulkRetryRequestQueryCauseVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "stringList":
		return visitor.VisitStringList(c.StringList)
	}
}

// Connection ID of the ignored event
type CreateIgnoredEventBulkRetryRequestQueryWebhookId struct {
	typeName string
	// <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewCreateIgnoredEventBulkRetryRequestQueryWebhookIdFromString(value string) *CreateIgnoredEventBulkRetryRequestQueryWebhookId {
	return &CreateIgnoredEventBulkRetryRequestQueryWebhookId{typeName: "string", String: value}
}

func NewCreateIgnoredEventBulkRetryRequestQueryWebhookIdFromStringList(value []string) *CreateIgnoredEventBulkRetryRequestQueryWebhookId {
	return &CreateIgnoredEventBulkRetryRequestQueryWebhookId{typeName: "stringList", StringList: value}
}

func (c *CreateIgnoredEventBulkRetryRequestQueryWebhookId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		c.typeName = "stringList"
		c.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateIgnoredEventBulkRetryRequestQueryWebhookId) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "stringList":
		return json.Marshal(c.StringList)
	}
}

type CreateIgnoredEventBulkRetryRequestQueryWebhookIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (c *CreateIgnoredEventBulkRetryRequestQueryWebhookId) Accept(visitor CreateIgnoredEventBulkRetryRequestQueryWebhookIdVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "stringList":
		return visitor.VisitStringList(c.StringList)
	}
}

// Decrypted Key/Value object of the associated configuration for that provider
type CreateIntegrationRequestConfigs struct {
	typeName                           string
	HmacIntegrationConfigs             *HmacIntegrationConfigs
	ApiKeyIntegrationConfigs           *ApiKeyIntegrationConfigs
	HandledApiKeyIntegrationConfigs    *HandledApiKeyIntegrationConfigs
	HandledHmacConfigs                 *HandledHmacConfigs
	BasicAuthIntegrationConfigs        *BasicAuthIntegrationConfigs
	ShopifyIntegrationConfigs          *ShopifyIntegrationConfigs
	CreateIntegrationRequestConfigsSix *CreateIntegrationRequestConfigsSix
}

func NewCreateIntegrationRequestConfigsFromHmacIntegrationConfigs(value *HmacIntegrationConfigs) *CreateIntegrationRequestConfigs {
	return &CreateIntegrationRequestConfigs{typeName: "hmacIntegrationConfigs", HmacIntegrationConfigs: value}
}

func NewCreateIntegrationRequestConfigsFromApiKeyIntegrationConfigs(value *ApiKeyIntegrationConfigs) *CreateIntegrationRequestConfigs {
	return &CreateIntegrationRequestConfigs{typeName: "apiKeyIntegrationConfigs", ApiKeyIntegrationConfigs: value}
}

func NewCreateIntegrationRequestConfigsFromHandledApiKeyIntegrationConfigs(value *HandledApiKeyIntegrationConfigs) *CreateIntegrationRequestConfigs {
	return &CreateIntegrationRequestConfigs{typeName: "handledApiKeyIntegrationConfigs", HandledApiKeyIntegrationConfigs: value}
}

func NewCreateIntegrationRequestConfigsFromHandledHmacConfigs(value *HandledHmacConfigs) *CreateIntegrationRequestConfigs {
	return &CreateIntegrationRequestConfigs{typeName: "handledHmacConfigs", HandledHmacConfigs: value}
}

func NewCreateIntegrationRequestConfigsFromBasicAuthIntegrationConfigs(value *BasicAuthIntegrationConfigs) *CreateIntegrationRequestConfigs {
	return &CreateIntegrationRequestConfigs{typeName: "basicAuthIntegrationConfigs", BasicAuthIntegrationConfigs: value}
}

func NewCreateIntegrationRequestConfigsFromShopifyIntegrationConfigs(value *ShopifyIntegrationConfigs) *CreateIntegrationRequestConfigs {
	return &CreateIntegrationRequestConfigs{typeName: "shopifyIntegrationConfigs", ShopifyIntegrationConfigs: value}
}

func NewCreateIntegrationRequestConfigsFromCreateIntegrationRequestConfigsSix(value *CreateIntegrationRequestConfigsSix) *CreateIntegrationRequestConfigs {
	return &CreateIntegrationRequestConfigs{typeName: "createIntegrationRequestConfigsSix", CreateIntegrationRequestConfigsSix: value}
}

func (c *CreateIntegrationRequestConfigs) UnmarshalJSON(data []byte) error {
	valueHmacIntegrationConfigs := new(HmacIntegrationConfigs)
	if err := json.Unmarshal(data, &valueHmacIntegrationConfigs); err == nil {
		c.typeName = "hmacIntegrationConfigs"
		c.HmacIntegrationConfigs = valueHmacIntegrationConfigs
		return nil
	}
	valueApiKeyIntegrationConfigs := new(ApiKeyIntegrationConfigs)
	if err := json.Unmarshal(data, &valueApiKeyIntegrationConfigs); err == nil {
		c.typeName = "apiKeyIntegrationConfigs"
		c.ApiKeyIntegrationConfigs = valueApiKeyIntegrationConfigs
		return nil
	}
	valueHandledApiKeyIntegrationConfigs := new(HandledApiKeyIntegrationConfigs)
	if err := json.Unmarshal(data, &valueHandledApiKeyIntegrationConfigs); err == nil {
		c.typeName = "handledApiKeyIntegrationConfigs"
		c.HandledApiKeyIntegrationConfigs = valueHandledApiKeyIntegrationConfigs
		return nil
	}
	valueHandledHmacConfigs := new(HandledHmacConfigs)
	if err := json.Unmarshal(data, &valueHandledHmacConfigs); err == nil {
		c.typeName = "handledHmacConfigs"
		c.HandledHmacConfigs = valueHandledHmacConfigs
		return nil
	}
	valueBasicAuthIntegrationConfigs := new(BasicAuthIntegrationConfigs)
	if err := json.Unmarshal(data, &valueBasicAuthIntegrationConfigs); err == nil {
		c.typeName = "basicAuthIntegrationConfigs"
		c.BasicAuthIntegrationConfigs = valueBasicAuthIntegrationConfigs
		return nil
	}
	valueShopifyIntegrationConfigs := new(ShopifyIntegrationConfigs)
	if err := json.Unmarshal(data, &valueShopifyIntegrationConfigs); err == nil {
		c.typeName = "shopifyIntegrationConfigs"
		c.ShopifyIntegrationConfigs = valueShopifyIntegrationConfigs
		return nil
	}
	valueCreateIntegrationRequestConfigsSix := new(CreateIntegrationRequestConfigsSix)
	if err := json.Unmarshal(data, &valueCreateIntegrationRequestConfigsSix); err == nil {
		c.typeName = "createIntegrationRequestConfigsSix"
		c.CreateIntegrationRequestConfigsSix = valueCreateIntegrationRequestConfigsSix
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateIntegrationRequestConfigs) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "hmacIntegrationConfigs":
		return json.Marshal(c.HmacIntegrationConfigs)
	case "apiKeyIntegrationConfigs":
		return json.Marshal(c.ApiKeyIntegrationConfigs)
	case "handledApiKeyIntegrationConfigs":
		return json.Marshal(c.HandledApiKeyIntegrationConfigs)
	case "handledHmacConfigs":
		return json.Marshal(c.HandledHmacConfigs)
	case "basicAuthIntegrationConfigs":
		return json.Marshal(c.BasicAuthIntegrationConfigs)
	case "shopifyIntegrationConfigs":
		return json.Marshal(c.ShopifyIntegrationConfigs)
	case "createIntegrationRequestConfigsSix":
		return json.Marshal(c.CreateIntegrationRequestConfigsSix)
	}
}

type CreateIntegrationRequestConfigsVisitor interface {
	VisitHmacIntegrationConfigs(*HmacIntegrationConfigs) error
	VisitApiKeyIntegrationConfigs(*ApiKeyIntegrationConfigs) error
	VisitHandledApiKeyIntegrationConfigs(*HandledApiKeyIntegrationConfigs) error
	VisitHandledHmacConfigs(*HandledHmacConfigs) error
	VisitBasicAuthIntegrationConfigs(*BasicAuthIntegrationConfigs) error
	VisitShopifyIntegrationConfigs(*ShopifyIntegrationConfigs) error
	VisitCreateIntegrationRequestConfigsSix(*CreateIntegrationRequestConfigsSix) error
}

func (c *CreateIntegrationRequestConfigs) Accept(visitor CreateIntegrationRequestConfigsVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "hmacIntegrationConfigs":
		return visitor.VisitHmacIntegrationConfigs(c.HmacIntegrationConfigs)
	case "apiKeyIntegrationConfigs":
		return visitor.VisitApiKeyIntegrationConfigs(c.ApiKeyIntegrationConfigs)
	case "handledApiKeyIntegrationConfigs":
		return visitor.VisitHandledApiKeyIntegrationConfigs(c.HandledApiKeyIntegrationConfigs)
	case "handledHmacConfigs":
		return visitor.VisitHandledHmacConfigs(c.HandledHmacConfigs)
	case "basicAuthIntegrationConfigs":
		return visitor.VisitBasicAuthIntegrationConfigs(c.BasicAuthIntegrationConfigs)
	case "shopifyIntegrationConfigs":
		return visitor.VisitShopifyIntegrationConfigs(c.ShopifyIntegrationConfigs)
	case "createIntegrationRequestConfigsSix":
		return visitor.VisitCreateIntegrationRequestConfigsSix(c.CreateIntegrationRequestConfigsSix)
	}
}

type CreateIntegrationRequestConfigsSix struct {
}

// Configuration object for the specific issue type selected
type CreateIssueTriggerRequestConfigs struct {
	typeName                          string
	IssueTriggerDeliveryConfigs       *IssueTriggerDeliveryConfigs
	IssueTriggerTransformationConfigs *IssueTriggerTransformationConfigs
	IssueTriggerBackpressureConfigs   *IssueTriggerBackpressureConfigs
}

func NewCreateIssueTriggerRequestConfigsFromIssueTriggerDeliveryConfigs(value *IssueTriggerDeliveryConfigs) *CreateIssueTriggerRequestConfigs {
	return &CreateIssueTriggerRequestConfigs{typeName: "issueTriggerDeliveryConfigs", IssueTriggerDeliveryConfigs: value}
}

func NewCreateIssueTriggerRequestConfigsFromIssueTriggerTransformationConfigs(value *IssueTriggerTransformationConfigs) *CreateIssueTriggerRequestConfigs {
	return &CreateIssueTriggerRequestConfigs{typeName: "issueTriggerTransformationConfigs", IssueTriggerTransformationConfigs: value}
}

func NewCreateIssueTriggerRequestConfigsFromIssueTriggerBackpressureConfigs(value *IssueTriggerBackpressureConfigs) *CreateIssueTriggerRequestConfigs {
	return &CreateIssueTriggerRequestConfigs{typeName: "issueTriggerBackpressureConfigs", IssueTriggerBackpressureConfigs: value}
}

func (c *CreateIssueTriggerRequestConfigs) UnmarshalJSON(data []byte) error {
	valueIssueTriggerDeliveryConfigs := new(IssueTriggerDeliveryConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerDeliveryConfigs); err == nil {
		c.typeName = "issueTriggerDeliveryConfigs"
		c.IssueTriggerDeliveryConfigs = valueIssueTriggerDeliveryConfigs
		return nil
	}
	valueIssueTriggerTransformationConfigs := new(IssueTriggerTransformationConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerTransformationConfigs); err == nil {
		c.typeName = "issueTriggerTransformationConfigs"
		c.IssueTriggerTransformationConfigs = valueIssueTriggerTransformationConfigs
		return nil
	}
	valueIssueTriggerBackpressureConfigs := new(IssueTriggerBackpressureConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerBackpressureConfigs); err == nil {
		c.typeName = "issueTriggerBackpressureConfigs"
		c.IssueTriggerBackpressureConfigs = valueIssueTriggerBackpressureConfigs
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateIssueTriggerRequestConfigs) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "issueTriggerDeliveryConfigs":
		return json.Marshal(c.IssueTriggerDeliveryConfigs)
	case "issueTriggerTransformationConfigs":
		return json.Marshal(c.IssueTriggerTransformationConfigs)
	case "issueTriggerBackpressureConfigs":
		return json.Marshal(c.IssueTriggerBackpressureConfigs)
	}
}

type CreateIssueTriggerRequestConfigsVisitor interface {
	VisitIssueTriggerDeliveryConfigs(*IssueTriggerDeliveryConfigs) error
	VisitIssueTriggerTransformationConfigs(*IssueTriggerTransformationConfigs) error
	VisitIssueTriggerBackpressureConfigs(*IssueTriggerBackpressureConfigs) error
}

func (c *CreateIssueTriggerRequestConfigs) Accept(visitor CreateIssueTriggerRequestConfigsVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "issueTriggerDeliveryConfigs":
		return visitor.VisitIssueTriggerDeliveryConfigs(c.IssueTriggerDeliveryConfigs)
	case "issueTriggerTransformationConfigs":
		return visitor.VisitIssueTriggerTransformationConfigs(c.IssueTriggerTransformationConfigs)
	case "issueTriggerBackpressureConfigs":
		return visitor.VisitIssueTriggerBackpressureConfigs(c.IssueTriggerBackpressureConfigs)
	}
}

// Filter properties for the events to be included in the bulk retry, use query parameters of [Requests](#requests)
type CreateRequestBulkRetryRequestQuery struct {
	// Filter by requests IDs
	Id *CreateRequestBulkRetryRequestQueryId `json:"id,omitempty"`
	// Filter by status
	Status *CreateRequestBulkRetryRequestQueryStatus `json:"status,omitempty"`
	// Filter by rejection cause
	RejectionCause *CreateRequestBulkRetryRequestQueryRejectionCause `json:"rejection_cause,omitempty"`
	// Filter by source IDs
	SourceId *CreateRequestBulkRetryRequestQuerySourceId `json:"source_id,omitempty"`
	// Filter by verification status
	Verified *bool `json:"verified,omitempty"`
	// URL Encoded string of the value to match partially to the body, headers, parsed_query or path
	SearchTerm *string `json:"search_term,omitempty"`
	// URL Encoded string of the JSON to match to the data headers
	Headers *CreateRequestBulkRetryRequestQueryHeaders `json:"headers,omitempty"`
	// URL Encoded string of the JSON to match to the data body
	Body *CreateRequestBulkRetryRequestQueryBody `json:"body,omitempty"`
	// URL Encoded string of the JSON to match to the parsed query (JSON representation of the query)
	ParsedQuery *CreateRequestBulkRetryRequestQueryParsedQuery `json:"parsed_query,omitempty"`
	// URL Encoded string of the value to match partially to the path
	Path *string `json:"path,omitempty"`
	// Filter by count of ignored events
	IgnoredCount *CreateRequestBulkRetryRequestQueryIgnoredCount `json:"ignored_count,omitempty"`
	// Filter by count of events
	EventsCount *CreateRequestBulkRetryRequestQueryEventsCount `json:"events_count,omitempty"`
	// Filter by event ingested date
	IngestedAt  *CreateRequestBulkRetryRequestQueryIngestedAt  `json:"ingested_at,omitempty"`
	BulkRetryId *CreateRequestBulkRetryRequestQueryBulkRetryId `json:"bulk_retry_id,omitempty"`
}

// URL Encoded string of the JSON to match to the data body
type CreateRequestBulkRetryRequestQueryBody struct {
	typeName                                  string
	String                                    string
	CreateRequestBulkRetryRequestQueryBodyOne *CreateRequestBulkRetryRequestQueryBodyOne
}

func NewCreateRequestBulkRetryRequestQueryBodyFromString(value string) *CreateRequestBulkRetryRequestQueryBody {
	return &CreateRequestBulkRetryRequestQueryBody{typeName: "string", String: value}
}

func NewCreateRequestBulkRetryRequestQueryBodyFromCreateRequestBulkRetryRequestQueryBodyOne(value *CreateRequestBulkRetryRequestQueryBodyOne) *CreateRequestBulkRetryRequestQueryBody {
	return &CreateRequestBulkRetryRequestQueryBody{typeName: "createRequestBulkRetryRequestQueryBodyOne", CreateRequestBulkRetryRequestQueryBodyOne: value}
}

func (c *CreateRequestBulkRetryRequestQueryBody) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valueCreateRequestBulkRetryRequestQueryBodyOne := new(CreateRequestBulkRetryRequestQueryBodyOne)
	if err := json.Unmarshal(data, &valueCreateRequestBulkRetryRequestQueryBodyOne); err == nil {
		c.typeName = "createRequestBulkRetryRequestQueryBodyOne"
		c.CreateRequestBulkRetryRequestQueryBodyOne = valueCreateRequestBulkRetryRequestQueryBodyOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateRequestBulkRetryRequestQueryBody) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "createRequestBulkRetryRequestQueryBodyOne":
		return json.Marshal(c.CreateRequestBulkRetryRequestQueryBodyOne)
	}
}

type CreateRequestBulkRetryRequestQueryBodyVisitor interface {
	VisitString(string) error
	VisitCreateRequestBulkRetryRequestQueryBodyOne(*CreateRequestBulkRetryRequestQueryBodyOne) error
}

func (c *CreateRequestBulkRetryRequestQueryBody) Accept(visitor CreateRequestBulkRetryRequestQueryBodyVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "createRequestBulkRetryRequestQueryBodyOne":
		return visitor.VisitCreateRequestBulkRetryRequestQueryBodyOne(c.CreateRequestBulkRetryRequestQueryBodyOne)
	}
}

type CreateRequestBulkRetryRequestQueryBodyOne struct {
}

type CreateRequestBulkRetryRequestQueryBulkRetryId struct {
	typeName string
	// <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewCreateRequestBulkRetryRequestQueryBulkRetryIdFromString(value string) *CreateRequestBulkRetryRequestQueryBulkRetryId {
	return &CreateRequestBulkRetryRequestQueryBulkRetryId{typeName: "string", String: value}
}

func NewCreateRequestBulkRetryRequestQueryBulkRetryIdFromStringList(value []string) *CreateRequestBulkRetryRequestQueryBulkRetryId {
	return &CreateRequestBulkRetryRequestQueryBulkRetryId{typeName: "stringList", StringList: value}
}

func (c *CreateRequestBulkRetryRequestQueryBulkRetryId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		c.typeName = "stringList"
		c.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateRequestBulkRetryRequestQueryBulkRetryId) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "stringList":
		return json.Marshal(c.StringList)
	}
}

type CreateRequestBulkRetryRequestQueryBulkRetryIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (c *CreateRequestBulkRetryRequestQueryBulkRetryId) Accept(visitor CreateRequestBulkRetryRequestQueryBulkRetryIdVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "stringList":
		return visitor.VisitStringList(c.StringList)
	}
}

// Filter by count of events
type CreateRequestBulkRetryRequestQueryEventsCount struct {
	typeName                                         string
	Integer                                          int
	CreateRequestBulkRetryRequestQueryEventsCountAny *CreateRequestBulkRetryRequestQueryEventsCountAny
	IntegerList                                      []int
}

func NewCreateRequestBulkRetryRequestQueryEventsCountFromInteger(value int) *CreateRequestBulkRetryRequestQueryEventsCount {
	return &CreateRequestBulkRetryRequestQueryEventsCount{typeName: "integer", Integer: value}
}

func NewCreateRequestBulkRetryRequestQueryEventsCountFromCreateRequestBulkRetryRequestQueryEventsCountAny(value *CreateRequestBulkRetryRequestQueryEventsCountAny) *CreateRequestBulkRetryRequestQueryEventsCount {
	return &CreateRequestBulkRetryRequestQueryEventsCount{typeName: "createRequestBulkRetryRequestQueryEventsCountAny", CreateRequestBulkRetryRequestQueryEventsCountAny: value}
}

func NewCreateRequestBulkRetryRequestQueryEventsCountFromIntegerList(value []int) *CreateRequestBulkRetryRequestQueryEventsCount {
	return &CreateRequestBulkRetryRequestQueryEventsCount{typeName: "integerList", IntegerList: value}
}

func (c *CreateRequestBulkRetryRequestQueryEventsCount) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		c.typeName = "integer"
		c.Integer = valueInteger
		return nil
	}
	valueCreateRequestBulkRetryRequestQueryEventsCountAny := new(CreateRequestBulkRetryRequestQueryEventsCountAny)
	if err := json.Unmarshal(data, &valueCreateRequestBulkRetryRequestQueryEventsCountAny); err == nil {
		c.typeName = "createRequestBulkRetryRequestQueryEventsCountAny"
		c.CreateRequestBulkRetryRequestQueryEventsCountAny = valueCreateRequestBulkRetryRequestQueryEventsCountAny
		return nil
	}
	var valueIntegerList []int
	if err := json.Unmarshal(data, &valueIntegerList); err == nil {
		c.typeName = "integerList"
		c.IntegerList = valueIntegerList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateRequestBulkRetryRequestQueryEventsCount) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "integer":
		return json.Marshal(c.Integer)
	case "createRequestBulkRetryRequestQueryEventsCountAny":
		return json.Marshal(c.CreateRequestBulkRetryRequestQueryEventsCountAny)
	case "integerList":
		return json.Marshal(c.IntegerList)
	}
}

type CreateRequestBulkRetryRequestQueryEventsCountVisitor interface {
	VisitInteger(int) error
	VisitCreateRequestBulkRetryRequestQueryEventsCountAny(*CreateRequestBulkRetryRequestQueryEventsCountAny) error
	VisitIntegerList([]int) error
}

func (c *CreateRequestBulkRetryRequestQueryEventsCount) Accept(visitor CreateRequestBulkRetryRequestQueryEventsCountVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "integer":
		return visitor.VisitInteger(c.Integer)
	case "createRequestBulkRetryRequestQueryEventsCountAny":
		return visitor.VisitCreateRequestBulkRetryRequestQueryEventsCountAny(c.CreateRequestBulkRetryRequestQueryEventsCountAny)
	case "integerList":
		return visitor.VisitIntegerList(c.IntegerList)
	}
}

type CreateRequestBulkRetryRequestQueryEventsCountAny struct {
	Gt       *int  `json:"gt,omitempty"`
	Gte      *int  `json:"gte,omitempty"`
	Le       *int  `json:"le,omitempty"`
	Lte      *int  `json:"lte,omitempty"`
	Any      *bool `json:"any,omitempty"`
	Contains *int  `json:"contains,omitempty"`
}

// URL Encoded string of the JSON to match to the data headers
type CreateRequestBulkRetryRequestQueryHeaders struct {
	typeName                                     string
	String                                       string
	CreateRequestBulkRetryRequestQueryHeadersOne *CreateRequestBulkRetryRequestQueryHeadersOne
}

func NewCreateRequestBulkRetryRequestQueryHeadersFromString(value string) *CreateRequestBulkRetryRequestQueryHeaders {
	return &CreateRequestBulkRetryRequestQueryHeaders{typeName: "string", String: value}
}

func NewCreateRequestBulkRetryRequestQueryHeadersFromCreateRequestBulkRetryRequestQueryHeadersOne(value *CreateRequestBulkRetryRequestQueryHeadersOne) *CreateRequestBulkRetryRequestQueryHeaders {
	return &CreateRequestBulkRetryRequestQueryHeaders{typeName: "createRequestBulkRetryRequestQueryHeadersOne", CreateRequestBulkRetryRequestQueryHeadersOne: value}
}

func (c *CreateRequestBulkRetryRequestQueryHeaders) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valueCreateRequestBulkRetryRequestQueryHeadersOne := new(CreateRequestBulkRetryRequestQueryHeadersOne)
	if err := json.Unmarshal(data, &valueCreateRequestBulkRetryRequestQueryHeadersOne); err == nil {
		c.typeName = "createRequestBulkRetryRequestQueryHeadersOne"
		c.CreateRequestBulkRetryRequestQueryHeadersOne = valueCreateRequestBulkRetryRequestQueryHeadersOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateRequestBulkRetryRequestQueryHeaders) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "createRequestBulkRetryRequestQueryHeadersOne":
		return json.Marshal(c.CreateRequestBulkRetryRequestQueryHeadersOne)
	}
}

type CreateRequestBulkRetryRequestQueryHeadersVisitor interface {
	VisitString(string) error
	VisitCreateRequestBulkRetryRequestQueryHeadersOne(*CreateRequestBulkRetryRequestQueryHeadersOne) error
}

func (c *CreateRequestBulkRetryRequestQueryHeaders) Accept(visitor CreateRequestBulkRetryRequestQueryHeadersVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "createRequestBulkRetryRequestQueryHeadersOne":
		return visitor.VisitCreateRequestBulkRetryRequestQueryHeadersOne(c.CreateRequestBulkRetryRequestQueryHeadersOne)
	}
}

type CreateRequestBulkRetryRequestQueryHeadersOne struct {
}

// Filter by requests IDs
type CreateRequestBulkRetryRequestQueryId struct {
	typeName string
	// Request ID <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewCreateRequestBulkRetryRequestQueryIdFromString(value string) *CreateRequestBulkRetryRequestQueryId {
	return &CreateRequestBulkRetryRequestQueryId{typeName: "string", String: value}
}

func NewCreateRequestBulkRetryRequestQueryIdFromStringList(value []string) *CreateRequestBulkRetryRequestQueryId {
	return &CreateRequestBulkRetryRequestQueryId{typeName: "stringList", StringList: value}
}

func (c *CreateRequestBulkRetryRequestQueryId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		c.typeName = "stringList"
		c.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateRequestBulkRetryRequestQueryId) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "stringList":
		return json.Marshal(c.StringList)
	}
}

type CreateRequestBulkRetryRequestQueryIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (c *CreateRequestBulkRetryRequestQueryId) Accept(visitor CreateRequestBulkRetryRequestQueryIdVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "stringList":
		return visitor.VisitStringList(c.StringList)
	}
}

// Filter by count of ignored events
type CreateRequestBulkRetryRequestQueryIgnoredCount struct {
	typeName                                          string
	Integer                                           int
	CreateRequestBulkRetryRequestQueryIgnoredCountAny *CreateRequestBulkRetryRequestQueryIgnoredCountAny
	IntegerList                                       []int
}

func NewCreateRequestBulkRetryRequestQueryIgnoredCountFromInteger(value int) *CreateRequestBulkRetryRequestQueryIgnoredCount {
	return &CreateRequestBulkRetryRequestQueryIgnoredCount{typeName: "integer", Integer: value}
}

func NewCreateRequestBulkRetryRequestQueryIgnoredCountFromCreateRequestBulkRetryRequestQueryIgnoredCountAny(value *CreateRequestBulkRetryRequestQueryIgnoredCountAny) *CreateRequestBulkRetryRequestQueryIgnoredCount {
	return &CreateRequestBulkRetryRequestQueryIgnoredCount{typeName: "createRequestBulkRetryRequestQueryIgnoredCountAny", CreateRequestBulkRetryRequestQueryIgnoredCountAny: value}
}

func NewCreateRequestBulkRetryRequestQueryIgnoredCountFromIntegerList(value []int) *CreateRequestBulkRetryRequestQueryIgnoredCount {
	return &CreateRequestBulkRetryRequestQueryIgnoredCount{typeName: "integerList", IntegerList: value}
}

func (c *CreateRequestBulkRetryRequestQueryIgnoredCount) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		c.typeName = "integer"
		c.Integer = valueInteger
		return nil
	}
	valueCreateRequestBulkRetryRequestQueryIgnoredCountAny := new(CreateRequestBulkRetryRequestQueryIgnoredCountAny)
	if err := json.Unmarshal(data, &valueCreateRequestBulkRetryRequestQueryIgnoredCountAny); err == nil {
		c.typeName = "createRequestBulkRetryRequestQueryIgnoredCountAny"
		c.CreateRequestBulkRetryRequestQueryIgnoredCountAny = valueCreateRequestBulkRetryRequestQueryIgnoredCountAny
		return nil
	}
	var valueIntegerList []int
	if err := json.Unmarshal(data, &valueIntegerList); err == nil {
		c.typeName = "integerList"
		c.IntegerList = valueIntegerList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateRequestBulkRetryRequestQueryIgnoredCount) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "integer":
		return json.Marshal(c.Integer)
	case "createRequestBulkRetryRequestQueryIgnoredCountAny":
		return json.Marshal(c.CreateRequestBulkRetryRequestQueryIgnoredCountAny)
	case "integerList":
		return json.Marshal(c.IntegerList)
	}
}

type CreateRequestBulkRetryRequestQueryIgnoredCountVisitor interface {
	VisitInteger(int) error
	VisitCreateRequestBulkRetryRequestQueryIgnoredCountAny(*CreateRequestBulkRetryRequestQueryIgnoredCountAny) error
	VisitIntegerList([]int) error
}

func (c *CreateRequestBulkRetryRequestQueryIgnoredCount) Accept(visitor CreateRequestBulkRetryRequestQueryIgnoredCountVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "integer":
		return visitor.VisitInteger(c.Integer)
	case "createRequestBulkRetryRequestQueryIgnoredCountAny":
		return visitor.VisitCreateRequestBulkRetryRequestQueryIgnoredCountAny(c.CreateRequestBulkRetryRequestQueryIgnoredCountAny)
	case "integerList":
		return visitor.VisitIntegerList(c.IntegerList)
	}
}

type CreateRequestBulkRetryRequestQueryIgnoredCountAny struct {
	Gt       *int  `json:"gt,omitempty"`
	Gte      *int  `json:"gte,omitempty"`
	Le       *int  `json:"le,omitempty"`
	Lte      *int  `json:"lte,omitempty"`
	Any      *bool `json:"any,omitempty"`
	Contains *int  `json:"contains,omitempty"`
}

// Filter by event ingested date
type CreateRequestBulkRetryRequestQueryIngestedAt struct {
	typeName                                        string
	DateTime                                        time.Time
	CreateRequestBulkRetryRequestQueryIngestedAtAny *CreateRequestBulkRetryRequestQueryIngestedAtAny
}

func NewCreateRequestBulkRetryRequestQueryIngestedAtFromDateTime(value time.Time) *CreateRequestBulkRetryRequestQueryIngestedAt {
	return &CreateRequestBulkRetryRequestQueryIngestedAt{typeName: "dateTime", DateTime: value}
}

func NewCreateRequestBulkRetryRequestQueryIngestedAtFromCreateRequestBulkRetryRequestQueryIngestedAtAny(value *CreateRequestBulkRetryRequestQueryIngestedAtAny) *CreateRequestBulkRetryRequestQueryIngestedAt {
	return &CreateRequestBulkRetryRequestQueryIngestedAt{typeName: "createRequestBulkRetryRequestQueryIngestedAtAny", CreateRequestBulkRetryRequestQueryIngestedAtAny: value}
}

func (c *CreateRequestBulkRetryRequestQueryIngestedAt) UnmarshalJSON(data []byte) error {
	var valueDateTime time.Time
	if err := json.Unmarshal(data, &valueDateTime); err == nil {
		c.typeName = "dateTime"
		c.DateTime = valueDateTime
		return nil
	}
	valueCreateRequestBulkRetryRequestQueryIngestedAtAny := new(CreateRequestBulkRetryRequestQueryIngestedAtAny)
	if err := json.Unmarshal(data, &valueCreateRequestBulkRetryRequestQueryIngestedAtAny); err == nil {
		c.typeName = "createRequestBulkRetryRequestQueryIngestedAtAny"
		c.CreateRequestBulkRetryRequestQueryIngestedAtAny = valueCreateRequestBulkRetryRequestQueryIngestedAtAny
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateRequestBulkRetryRequestQueryIngestedAt) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "dateTime":
		return json.Marshal(c.DateTime)
	case "createRequestBulkRetryRequestQueryIngestedAtAny":
		return json.Marshal(c.CreateRequestBulkRetryRequestQueryIngestedAtAny)
	}
}

type CreateRequestBulkRetryRequestQueryIngestedAtVisitor interface {
	VisitDateTime(time.Time) error
	VisitCreateRequestBulkRetryRequestQueryIngestedAtAny(*CreateRequestBulkRetryRequestQueryIngestedAtAny) error
}

func (c *CreateRequestBulkRetryRequestQueryIngestedAt) Accept(visitor CreateRequestBulkRetryRequestQueryIngestedAtVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "dateTime":
		return visitor.VisitDateTime(c.DateTime)
	case "createRequestBulkRetryRequestQueryIngestedAtAny":
		return visitor.VisitCreateRequestBulkRetryRequestQueryIngestedAtAny(c.CreateRequestBulkRetryRequestQueryIngestedAtAny)
	}
}

type CreateRequestBulkRetryRequestQueryIngestedAtAny struct {
	Gt  *time.Time `json:"gt,omitempty"`
	Gte *time.Time `json:"gte,omitempty"`
	Le  *time.Time `json:"le,omitempty"`
	Lte *time.Time `json:"lte,omitempty"`
	Any *bool      `json:"any,omitempty"`
}

// URL Encoded string of the JSON to match to the parsed query (JSON representation of the query)
type CreateRequestBulkRetryRequestQueryParsedQuery struct {
	typeName                                         string
	String                                           string
	CreateRequestBulkRetryRequestQueryParsedQueryOne *CreateRequestBulkRetryRequestQueryParsedQueryOne
}

func NewCreateRequestBulkRetryRequestQueryParsedQueryFromString(value string) *CreateRequestBulkRetryRequestQueryParsedQuery {
	return &CreateRequestBulkRetryRequestQueryParsedQuery{typeName: "string", String: value}
}

func NewCreateRequestBulkRetryRequestQueryParsedQueryFromCreateRequestBulkRetryRequestQueryParsedQueryOne(value *CreateRequestBulkRetryRequestQueryParsedQueryOne) *CreateRequestBulkRetryRequestQueryParsedQuery {
	return &CreateRequestBulkRetryRequestQueryParsedQuery{typeName: "createRequestBulkRetryRequestQueryParsedQueryOne", CreateRequestBulkRetryRequestQueryParsedQueryOne: value}
}

func (c *CreateRequestBulkRetryRequestQueryParsedQuery) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	valueCreateRequestBulkRetryRequestQueryParsedQueryOne := new(CreateRequestBulkRetryRequestQueryParsedQueryOne)
	if err := json.Unmarshal(data, &valueCreateRequestBulkRetryRequestQueryParsedQueryOne); err == nil {
		c.typeName = "createRequestBulkRetryRequestQueryParsedQueryOne"
		c.CreateRequestBulkRetryRequestQueryParsedQueryOne = valueCreateRequestBulkRetryRequestQueryParsedQueryOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateRequestBulkRetryRequestQueryParsedQuery) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "createRequestBulkRetryRequestQueryParsedQueryOne":
		return json.Marshal(c.CreateRequestBulkRetryRequestQueryParsedQueryOne)
	}
}

type CreateRequestBulkRetryRequestQueryParsedQueryVisitor interface {
	VisitString(string) error
	VisitCreateRequestBulkRetryRequestQueryParsedQueryOne(*CreateRequestBulkRetryRequestQueryParsedQueryOne) error
}

func (c *CreateRequestBulkRetryRequestQueryParsedQuery) Accept(visitor CreateRequestBulkRetryRequestQueryParsedQueryVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "createRequestBulkRetryRequestQueryParsedQueryOne":
		return visitor.VisitCreateRequestBulkRetryRequestQueryParsedQueryOne(c.CreateRequestBulkRetryRequestQueryParsedQueryOne)
	}
}

type CreateRequestBulkRetryRequestQueryParsedQueryOne struct {
}

// Filter by rejection cause
type CreateRequestBulkRetryRequestQueryRejectionCause struct {
	typeName                  string
	RequestRejectionCause     RequestRejectionCause
	RequestRejectionCauseList []RequestRejectionCause
}

func NewCreateRequestBulkRetryRequestQueryRejectionCauseFromRequestRejectionCause(value RequestRejectionCause) *CreateRequestBulkRetryRequestQueryRejectionCause {
	return &CreateRequestBulkRetryRequestQueryRejectionCause{typeName: "requestRejectionCause", RequestRejectionCause: value}
}

func NewCreateRequestBulkRetryRequestQueryRejectionCauseFromRequestRejectionCauseList(value []RequestRejectionCause) *CreateRequestBulkRetryRequestQueryRejectionCause {
	return &CreateRequestBulkRetryRequestQueryRejectionCause{typeName: "requestRejectionCauseList", RequestRejectionCauseList: value}
}

func (c *CreateRequestBulkRetryRequestQueryRejectionCause) UnmarshalJSON(data []byte) error {
	var valueRequestRejectionCause RequestRejectionCause
	if err := json.Unmarshal(data, &valueRequestRejectionCause); err == nil {
		c.typeName = "requestRejectionCause"
		c.RequestRejectionCause = valueRequestRejectionCause
		return nil
	}
	var valueRequestRejectionCauseList []RequestRejectionCause
	if err := json.Unmarshal(data, &valueRequestRejectionCauseList); err == nil {
		c.typeName = "requestRejectionCauseList"
		c.RequestRejectionCauseList = valueRequestRejectionCauseList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateRequestBulkRetryRequestQueryRejectionCause) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "requestRejectionCause":
		return json.Marshal(c.RequestRejectionCause)
	case "requestRejectionCauseList":
		return json.Marshal(c.RequestRejectionCauseList)
	}
}

type CreateRequestBulkRetryRequestQueryRejectionCauseVisitor interface {
	VisitRequestRejectionCause(RequestRejectionCause) error
	VisitRequestRejectionCauseList([]RequestRejectionCause) error
}

func (c *CreateRequestBulkRetryRequestQueryRejectionCause) Accept(visitor CreateRequestBulkRetryRequestQueryRejectionCauseVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "requestRejectionCause":
		return visitor.VisitRequestRejectionCause(c.RequestRejectionCause)
	case "requestRejectionCauseList":
		return visitor.VisitRequestRejectionCauseList(c.RequestRejectionCauseList)
	}
}

// Filter by source IDs
type CreateRequestBulkRetryRequestQuerySourceId struct {
	typeName string
	// Source ID <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewCreateRequestBulkRetryRequestQuerySourceIdFromString(value string) *CreateRequestBulkRetryRequestQuerySourceId {
	return &CreateRequestBulkRetryRequestQuerySourceId{typeName: "string", String: value}
}

func NewCreateRequestBulkRetryRequestQuerySourceIdFromStringList(value []string) *CreateRequestBulkRetryRequestQuerySourceId {
	return &CreateRequestBulkRetryRequestQuerySourceId{typeName: "stringList", StringList: value}
}

func (c *CreateRequestBulkRetryRequestQuerySourceId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		c.typeName = "stringList"
		c.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateRequestBulkRetryRequestQuerySourceId) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "stringList":
		return json.Marshal(c.StringList)
	}
}

type CreateRequestBulkRetryRequestQuerySourceIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (c *CreateRequestBulkRetryRequestQuerySourceId) Accept(visitor CreateRequestBulkRetryRequestQuerySourceIdVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "stringList":
		return visitor.VisitStringList(c.StringList)
	}
}

// Filter by status
type CreateRequestBulkRetryRequestQueryStatus uint

const (
	CreateRequestBulkRetryRequestQueryStatusAccepted CreateRequestBulkRetryRequestQueryStatus = iota + 1
	CreateRequestBulkRetryRequestQueryStatusRejected
)

func (c CreateRequestBulkRetryRequestQueryStatus) String() string {
	switch c {
	default:
		return strconv.Itoa(int(c))
	case CreateRequestBulkRetryRequestQueryStatusAccepted:
		return "accepted"
	case CreateRequestBulkRetryRequestQueryStatusRejected:
		return "rejected"
	}
}

func (c CreateRequestBulkRetryRequestQueryStatus) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", c.String())), nil
}

func (c *CreateRequestBulkRetryRequestQueryStatus) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "accepted":
		value := CreateRequestBulkRetryRequestQueryStatusAccepted
		*c = value
	case "rejected":
		value := CreateRequestBulkRetryRequestQueryStatusRejected
		*c = value
	}
	return nil
}

type CreateTransformationRequestEnvValue struct {
	typeName string
	String   string
	Double   float64
}

func NewCreateTransformationRequestEnvValueFromString(value string) *CreateTransformationRequestEnvValue {
	return &CreateTransformationRequestEnvValue{typeName: "string", String: value}
}

func NewCreateTransformationRequestEnvValueFromDouble(value float64) *CreateTransformationRequestEnvValue {
	return &CreateTransformationRequestEnvValue{typeName: "double", Double: value}
}

func (c *CreateTransformationRequestEnvValue) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		c.typeName = "string"
		c.String = valueString
		return nil
	}
	var valueDouble float64
	if err := json.Unmarshal(data, &valueDouble); err == nil {
		c.typeName = "double"
		c.Double = valueDouble
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateTransformationRequestEnvValue) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return json.Marshal(c.String)
	case "double":
		return json.Marshal(c.Double)
	}
}

type CreateTransformationRequestEnvValueVisitor interface {
	VisitString(string) error
	VisitDouble(float64) error
}

func (c *CreateTransformationRequestEnvValue) Accept(visitor CreateTransformationRequestEnvValueVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "string":
		return visitor.VisitString(c.String)
	case "double":
		return visitor.VisitDouble(c.Double)
	}
}

// Custom Signature
type CustomSignature struct {
	Config *DestinationAuthMethodCustomSignatureConfig `json:"config,omitempty"`
	type_  string
}

func (c *CustomSignature) Type() string {
	return c.type_
}

func (c *CustomSignature) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomSignature
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomSignature(value)
	c.type_ = "CUSTOM_SIGNATURE"
	return nil
}

func (c *CustomSignature) MarshalJSON() ([]byte, error) {
	type embed CustomSignature
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "CUSTOM_SIGNATURE",
	}
	return json.Marshal(marshaler)
}

type DelayRule struct {
	// Delay to introduce in MS
	Delay int `json:"delay"`
	type_ string
}

func (d *DelayRule) Type() string {
	return d.type_
}

func (d *DelayRule) UnmarshalJSON(data []byte) error {
	type unmarshaler DelayRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DelayRule(value)
	d.type_ = "delay"
	return nil
}

func (d *DelayRule) MarshalJSON() ([]byte, error) {
	type embed DelayRule
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*d),
		Type:  "delay",
	}
	return json.Marshal(marshaler)
}

type DeleteCustomDomainSchema struct {
	// The custom hostname ID
	Id string `json:"id"`
}

type DeleteDestinationResponse struct {
	// ID of the destination
	Id string `json:"id"`
}

type DeleteSourceResponse struct {
	// ID of the source
	Id string `json:"id"`
}

type DeletedBookmarkResponse struct {
	// Bookmark ID
	Id string `json:"id"`
}

type DeletedIntegration struct {
	Id string `json:"id"`
}

type DeletedIssueTriggerResponse struct {
	Id string `json:"id"`
}

// Delivery issue
type DeliveryIssue struct {
	// Issue ID
	Id string `json:"id"`
	// ID of the workspace
	TeamId string      `json:"team_id"`
	Status IssueStatus `json:"status,omitempty"`
	// ISO timestamp for when the issue was last opened
	OpenedAt time.Time `json:"opened_at"`
	// ISO timestamp for when the issue was first opened
	FirstSeenAt time.Time `json:"first_seen_at"`
	// ISO timestamp for when the issue last occured
	LastSeenAt time.Time `json:"last_seen_at"`
	// ID of the team member who last updated the issue status
	LastUpdatedBy *string `json:"last_updated_by,omitempty"`
	// ISO timestamp for when the issue was dismissed
	DismissedAt    *time.Time `json:"dismissed_at,omitempty"`
	AutoResolvedAt *time.Time `json:"auto_resolved_at,omitempty"`
	MergedWith     *string    `json:"merged_with,omitempty"`
	// ISO timestamp for when the issue was last updated
	UpdatedAt string `json:"updated_at"`
	// ISO timestamp for when the issue was created
	CreatedAt       string                        `json:"created_at"`
	AggregationKeys *DeliveryIssueAggregationKeys `json:"aggregation_keys,omitempty"`
	Reference       *DeliveryIssueReference       `json:"reference,omitempty"`
	type_           string
}

func (d *DeliveryIssue) Type() string {
	return d.type_
}

func (d *DeliveryIssue) UnmarshalJSON(data []byte) error {
	type unmarshaler DeliveryIssue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeliveryIssue(value)
	d.type_ = "delivery"
	return nil
}

func (d *DeliveryIssue) MarshalJSON() ([]byte, error) {
	type embed DeliveryIssue
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*d),
		Type:  "delivery",
	}
	return json.Marshal(marshaler)
}

// Keys used as the aggregation keys a 'delivery' type issue
type DeliveryIssueAggregationKeys struct {
	WebhookId      []string            `json:"webhook_id,omitempty"`
	ResponseStatus []float64           `json:"response_status,omitempty"`
	ErrorCode      []AttemptErrorCodes `json:"error_code,omitempty"`
}

// Delivery issue data
type DeliveryIssueData struct {
	TriggerEvent   *Event        `json:"trigger_event,omitempty"`
	TriggerAttempt *EventAttempt `json:"trigger_attempt,omitempty"`
}

// Reference to the event and attempt an issue is being created for.
type DeliveryIssueReference struct {
	EventId   string `json:"event_id"`
	AttemptId string `json:"attempt_id"`
}

// Delivery issue
type DeliveryIssueWithData struct {
	// Issue ID
	Id string `json:"id"`
	// ID of the workspace
	TeamId string      `json:"team_id"`
	Status IssueStatus `json:"status,omitempty"`
	// ISO timestamp for when the issue was last opened
	OpenedAt time.Time `json:"opened_at"`
	// ISO timestamp for when the issue was first opened
	FirstSeenAt time.Time `json:"first_seen_at"`
	// ISO timestamp for when the issue last occured
	LastSeenAt time.Time `json:"last_seen_at"`
	// ID of the team member who last updated the issue status
	LastUpdatedBy *string `json:"last_updated_by,omitempty"`
	// ISO timestamp for when the issue was dismissed
	DismissedAt    *time.Time `json:"dismissed_at,omitempty"`
	AutoResolvedAt *time.Time `json:"auto_resolved_at,omitempty"`
	MergedWith     *string    `json:"merged_with,omitempty"`
	// ISO timestamp for when the issue was last updated
	UpdatedAt string `json:"updated_at"`
	// ISO timestamp for when the issue was created
	CreatedAt       string                        `json:"created_at"`
	AggregationKeys *DeliveryIssueAggregationKeys `json:"aggregation_keys,omitempty"`
	Reference       *DeliveryIssueReference       `json:"reference,omitempty"`
	Data            *DeliveryIssueData            `json:"data,omitempty"`
	type_           string
}

func (d *DeliveryIssueWithData) Type() string {
	return d.type_
}

func (d *DeliveryIssueWithData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeliveryIssueWithData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeliveryIssueWithData(value)
	d.type_ = "delivery"
	return nil
}

func (d *DeliveryIssueWithData) MarshalJSON() ([]byte, error) {
	type embed DeliveryIssueWithData
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*d),
		Type:  "delivery",
	}
	return json.Marshal(marshaler)
}

// Associated [Destination](#destination-object) object
type Destination struct {
	// ID of the destination
	Id string `json:"id"`
	// A unique, human-friendly name for the destination
	Name string `json:"name"`
	// Description of the destination
	Description *string `json:"description,omitempty"`
	// ID of the workspace
	TeamId                 string `json:"team_id"`
	PathForwardingDisabled *bool  `json:"path_forwarding_disabled,omitempty"`
	// HTTP endpoint of the destination
	Url *string `json:"url,omitempty"`
	// Path for the CLI destination
	CliPath *string `json:"cli_path,omitempty"`
	// Limit event attempts to receive per period. Max value is workspace plan's max attempts thoughput.
	RateLimit       *int                         `json:"rate_limit,omitempty"`
	RateLimitPeriod *DestinationRateLimitPeriod  `json:"rate_limit_period,omitempty"`
	HttpMethod      *DestinationHttpMethod       `json:"http_method,omitempty"`
	AuthMethod      *DestinationAuthMethodConfig `json:"auth_method,omitempty"`
	// Date the destination was archived
	ArchivedAt *time.Time `json:"archived_at,omitempty"`
	// Date the destination was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the destination was created
	CreatedAt time.Time `json:"created_at"`
}

// API key config for the destination's auth method
type DestinationAuthMethodApiKeyConfig struct {
	// Key for the API key auth
	Key string `json:"key"`
	// API key for the API key auth
	ApiKey string `json:"api_key"`
	// Whether the API key should be sent as a header or a query parameter
	To *DestinationAuthMethodApiKeyConfigTo `json:"to,omitempty"`
}

// Whether the API key should be sent as a header or a query parameter
type DestinationAuthMethodApiKeyConfigTo uint

const (
	DestinationAuthMethodApiKeyConfigToHeader DestinationAuthMethodApiKeyConfigTo = iota + 1
	DestinationAuthMethodApiKeyConfigToQuery
)

func (d DestinationAuthMethodApiKeyConfigTo) String() string {
	switch d {
	default:
		return strconv.Itoa(int(d))
	case DestinationAuthMethodApiKeyConfigToHeader:
		return "header"
	case DestinationAuthMethodApiKeyConfigToQuery:
		return "query"
	}
}

func (d DestinationAuthMethodApiKeyConfigTo) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", d.String())), nil
}

func (d *DestinationAuthMethodApiKeyConfigTo) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "header":
		value := DestinationAuthMethodApiKeyConfigToHeader
		*d = value
	case "query":
		value := DestinationAuthMethodApiKeyConfigToQuery
		*d = value
	}
	return nil
}

// Basic auth config for the destination's auth method
type DestinationAuthMethodBasicAuthConfig struct {
	// Username for basic auth
	Username string `json:"username"`
	// Password for basic auth
	Password string `json:"password"`
}

// Bearer token config for the destination's auth method
type DestinationAuthMethodBearerTokenConfig struct {
	// Token for the bearer token auth
	Token string `json:"token"`
}

// Config for the destination's auth method
type DestinationAuthMethodConfig struct {
	typeName          string
	HookdeckSignature *HookdeckSignature
	BasicAuth         *BasicAuth
	ApiKey            *ApiKey
	BearerToken       *BearerToken
	CustomSignature   *CustomSignature
}

func NewDestinationAuthMethodConfigFromHookdeckSignature(value *HookdeckSignature) *DestinationAuthMethodConfig {
	return &DestinationAuthMethodConfig{typeName: "hookdeckSignature", HookdeckSignature: value}
}

func NewDestinationAuthMethodConfigFromBasicAuth(value *BasicAuth) *DestinationAuthMethodConfig {
	return &DestinationAuthMethodConfig{typeName: "basicAuth", BasicAuth: value}
}

func NewDestinationAuthMethodConfigFromApiKey(value *ApiKey) *DestinationAuthMethodConfig {
	return &DestinationAuthMethodConfig{typeName: "apiKey", ApiKey: value}
}

func NewDestinationAuthMethodConfigFromBearerToken(value *BearerToken) *DestinationAuthMethodConfig {
	return &DestinationAuthMethodConfig{typeName: "bearerToken", BearerToken: value}
}

func NewDestinationAuthMethodConfigFromCustomSignature(value *CustomSignature) *DestinationAuthMethodConfig {
	return &DestinationAuthMethodConfig{typeName: "customSignature", CustomSignature: value}
}

func (d *DestinationAuthMethodConfig) UnmarshalJSON(data []byte) error {
	valueHookdeckSignature := new(HookdeckSignature)
	if err := json.Unmarshal(data, &valueHookdeckSignature); err == nil {
		d.typeName = "hookdeckSignature"
		d.HookdeckSignature = valueHookdeckSignature
		return nil
	}
	valueBasicAuth := new(BasicAuth)
	if err := json.Unmarshal(data, &valueBasicAuth); err == nil {
		d.typeName = "basicAuth"
		d.BasicAuth = valueBasicAuth
		return nil
	}
	valueApiKey := new(ApiKey)
	if err := json.Unmarshal(data, &valueApiKey); err == nil {
		d.typeName = "apiKey"
		d.ApiKey = valueApiKey
		return nil
	}
	valueBearerToken := new(BearerToken)
	if err := json.Unmarshal(data, &valueBearerToken); err == nil {
		d.typeName = "bearerToken"
		d.BearerToken = valueBearerToken
		return nil
	}
	valueCustomSignature := new(CustomSignature)
	if err := json.Unmarshal(data, &valueCustomSignature); err == nil {
		d.typeName = "customSignature"
		d.CustomSignature = valueCustomSignature
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DestinationAuthMethodConfig) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "hookdeckSignature":
		return json.Marshal(d.HookdeckSignature)
	case "basicAuth":
		return json.Marshal(d.BasicAuth)
	case "apiKey":
		return json.Marshal(d.ApiKey)
	case "bearerToken":
		return json.Marshal(d.BearerToken)
	case "customSignature":
		return json.Marshal(d.CustomSignature)
	}
}

type DestinationAuthMethodConfigVisitor interface {
	VisitHookdeckSignature(*HookdeckSignature) error
	VisitBasicAuth(*BasicAuth) error
	VisitApiKey(*ApiKey) error
	VisitBearerToken(*BearerToken) error
	VisitCustomSignature(*CustomSignature) error
}

func (d *DestinationAuthMethodConfig) Accept(visitor DestinationAuthMethodConfigVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "hookdeckSignature":
		return visitor.VisitHookdeckSignature(d.HookdeckSignature)
	case "basicAuth":
		return visitor.VisitBasicAuth(d.BasicAuth)
	case "apiKey":
		return visitor.VisitApiKey(d.ApiKey)
	case "bearerToken":
		return visitor.VisitBearerToken(d.BearerToken)
	case "customSignature":
		return visitor.VisitCustomSignature(d.CustomSignature)
	}
}

// Custom signature config for the destination's auth method
type DestinationAuthMethodCustomSignatureConfig struct {
	// Key for the custom signature auth
	Key string `json:"key"`
	// Signing secret for the custom signature auth. If left empty a secret will be generated for you.
	SigningSecret *string `json:"signing_secret,omitempty"`
}

// Empty config for the destination's auth method
type DestinationAuthMethodSignatureConfig struct {
}

// HTTP method used on requests sent to the destination, overrides the method used on requests sent to the source.
type DestinationHttpMethod uint

const (
	DestinationHttpMethodGet DestinationHttpMethod = iota + 1
	DestinationHttpMethodPost
	DestinationHttpMethodPut
	DestinationHttpMethodPatch
	DestinationHttpMethodDelete
)

func (d DestinationHttpMethod) String() string {
	switch d {
	default:
		return strconv.Itoa(int(d))
	case DestinationHttpMethodGet:
		return "GET"
	case DestinationHttpMethodPost:
		return "POST"
	case DestinationHttpMethodPut:
		return "PUT"
	case DestinationHttpMethodPatch:
		return "PATCH"
	case DestinationHttpMethodDelete:
		return "DELETE"
	}
}

func (d DestinationHttpMethod) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", d.String())), nil
}

func (d *DestinationHttpMethod) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "GET":
		value := DestinationHttpMethodGet
		*d = value
	case "POST":
		value := DestinationHttpMethodPost
		*d = value
	case "PUT":
		value := DestinationHttpMethodPut
		*d = value
	case "PATCH":
		value := DestinationHttpMethodPatch
		*d = value
	case "DELETE":
		value := DestinationHttpMethodDelete
		*d = value
	}
	return nil
}

type DestinationPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Destination  `json:"models,omitempty"`
}

// Period to rate limit attempts
type DestinationRateLimitPeriod uint

const (
	DestinationRateLimitPeriodSecond DestinationRateLimitPeriod = iota + 1
	DestinationRateLimitPeriodMinute
	DestinationRateLimitPeriodHour
)

func (d DestinationRateLimitPeriod) String() string {
	switch d {
	default:
		return strconv.Itoa(int(d))
	case DestinationRateLimitPeriodSecond:
		return "second"
	case DestinationRateLimitPeriodMinute:
		return "minute"
	case DestinationRateLimitPeriodHour:
		return "hour"
	}
}

func (d DestinationRateLimitPeriod) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", d.String())), nil
}

func (d *DestinationRateLimitPeriod) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "second":
		value := DestinationRateLimitPeriodSecond
		*d = value
	case "minute":
		value := DestinationRateLimitPeriodMinute
		*d = value
	case "hour":
		value := DestinationRateLimitPeriodHour
		*d = value
	}
	return nil
}

type DetachedIntegrationFromSource struct {
}

type Event struct {
	// ID of the event
	Id string `json:"id"`
	// ID of the workspace
	TeamId string `json:"team_id"`
	// ID of the associated connection
	WebhookId string `json:"webhook_id"`
	// ID of the associated source
	SourceId string `json:"source_id"`
	// ID of the associated destination
	DestinationId string `json:"destination_id"`
	// ID of the event data
	EventDataId string `json:"event_data_id"`
	// ID of the request that created the event
	RequestId string `json:"request_id"`
	// Number of delivery attempts made
	Attempts int `json:"attempts"`
	// Date of the most recently attempted retry
	LastAttemptAt *time.Time `json:"last_attempt_at,omitempty"`
	// Date of the next scheduled retry
	NextAttemptAt *time.Time `json:"next_attempt_at,omitempty"`
	// Event status
	ResponseStatus *int               `json:"response_status,omitempty"`
	ErrorCode      *AttemptErrorCodes `json:"error_code,omitempty"`
	Status         EventStatus        `json:"status,omitempty"`
	// Date of the latest successful attempt
	SuccessfulAt *time.Time `json:"successful_at,omitempty"`
	// ID of the CLI the event is sent to
	CliId *string `json:"cli_id,omitempty"`
	// Date the event was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the event was created
	CreatedAt time.Time       `json:"created_at"`
	Data      *ShortEventData `json:"data,omitempty"`
}

type EventArray = []*Event

type EventAttempt struct {
	// Attempt ID
	Id string `json:"id"`
	// Team ID
	TeamId string `json:"team_id"`
	// Event ID
	EventId string `json:"event_id"`
	// Attempt's HTTP response code
	ResponseStatus *int `json:"response_status,omitempty"`
	// Sequential number of attempts (up to and including this one) made for the associated event
	AttemptNumber *int               `json:"attempt_number,omitempty"`
	Trigger       *AttemptTrigger    `json:"trigger,omitempty"`
	ErrorCode     *AttemptErrorCodes `json:"error_code,omitempty"`
	Body          *EventAttemptBody  `json:"body,omitempty"`
	// URL of the destination where delivery was attempted
	RequestedUrl *string `json:"requested_url,omitempty"`
	// HTTP method used to deliver the attempt
	HttpMethod *EventAttemptHttpMethod `json:"http_method,omitempty"`
	// ID of associated bulk retry
	BulkRetryId *string       `json:"bulk_retry_id,omitempty"`
	Status      AttemptStatus `json:"status,omitempty"`
	// Date the attempt was successful
	SuccessfulAt *time.Time `json:"successful_at,omitempty"`
	// Date the attempt was delivered
	DeliveredAt *time.Time `json:"delivered_at,omitempty"`
	// Date the destination responded to this attempt
	RespondedAt *time.Time `json:"responded_at,omitempty"`
	// Time elapsed between attempt initiation and final delivery (in ms)
	DeliveryLatency *int `json:"delivery_latency,omitempty"`
	// Time elapsed between attempt initiation and a response from the destination (in ms)
	ResponseLatency *int `json:"response_latency,omitempty"`
	// Date the attempt was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the attempt was created
	CreatedAt time.Time     `json:"created_at"`
	State     *AttemptState `json:"state,omitempty"`
	// Date the attempt was archived
	ArchivedAt    *string `json:"archived_at,omitempty"`
	DestinationId *string `json:"destination_id,omitempty"`
}

type EventAttemptBody struct {
	typeName string
	// Response body from the destination
	EventAttemptBodyZeroOptional *EventAttemptBodyZero
	// Response body from the destination
	StringOptional *string
}

func NewEventAttemptBodyFromEventAttemptBodyZeroOptional(value *EventAttemptBodyZero) *EventAttemptBody {
	return &EventAttemptBody{typeName: "eventAttemptBodyZeroOptional", EventAttemptBodyZeroOptional: value}
}

func NewEventAttemptBodyFromStringOptional(value *string) *EventAttemptBody {
	return &EventAttemptBody{typeName: "stringOptional", StringOptional: value}
}

func (e *EventAttemptBody) UnmarshalJSON(data []byte) error {
	var valueEventAttemptBodyZeroOptional *EventAttemptBodyZero
	if err := json.Unmarshal(data, &valueEventAttemptBodyZeroOptional); err == nil {
		e.typeName = "eventAttemptBodyZeroOptional"
		e.EventAttemptBodyZeroOptional = valueEventAttemptBodyZeroOptional
		return nil
	}
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		e.typeName = "stringOptional"
		e.StringOptional = valueStringOptional
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventAttemptBody) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "eventAttemptBodyZeroOptional":
		return json.Marshal(e.EventAttemptBodyZeroOptional)
	case "stringOptional":
		return json.Marshal(e.StringOptional)
	}
}

type EventAttemptBodyVisitor interface {
	VisitEventAttemptBodyZeroOptional(*EventAttemptBodyZero) error
	VisitStringOptional(*string) error
}

func (e *EventAttemptBody) Accept(visitor EventAttemptBodyVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "eventAttemptBodyZeroOptional":
		return visitor.VisitEventAttemptBodyZeroOptional(e.EventAttemptBodyZeroOptional)
	case "stringOptional":
		return visitor.VisitStringOptional(e.StringOptional)
	}
}

// Response body from the destination
type EventAttemptBodyZero struct {
}

// HTTP method used to deliver the attempt
type EventAttemptHttpMethod uint

const (
	EventAttemptHttpMethodGet EventAttemptHttpMethod = iota + 1
	EventAttemptHttpMethodPost
	EventAttemptHttpMethodPut
	EventAttemptHttpMethodPatch
	EventAttemptHttpMethodDelete
)

func (e EventAttemptHttpMethod) String() string {
	switch e {
	default:
		return strconv.Itoa(int(e))
	case EventAttemptHttpMethodGet:
		return "GET"
	case EventAttemptHttpMethodPost:
		return "POST"
	case EventAttemptHttpMethodPut:
		return "PUT"
	case EventAttemptHttpMethodPatch:
		return "PATCH"
	case EventAttemptHttpMethodDelete:
		return "DELETE"
	}
}

func (e EventAttemptHttpMethod) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", e.String())), nil
}

func (e *EventAttemptHttpMethod) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "GET":
		value := EventAttemptHttpMethodGet
		*e = value
	case "POST":
		value := EventAttemptHttpMethodPost
		*e = value
	case "PUT":
		value := EventAttemptHttpMethodPut
		*e = value
	case "PATCH":
		value := EventAttemptHttpMethodPatch
		*e = value
	case "DELETE":
		value := EventAttemptHttpMethodDelete
		*e = value
	}
	return nil
}

type EventAttemptPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*EventAttempt `json:"models,omitempty"`
}

type EventPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Event        `json:"models,omitempty"`
}

type EventStatus uint

const (
	EventStatusScheduled EventStatus = iota + 1
	EventStatusQueued
	EventStatusHold
	EventStatusSuccessful
	EventStatusFailed
)

func (e EventStatus) String() string {
	switch e {
	default:
		return strconv.Itoa(int(e))
	case EventStatusScheduled:
		return "SCHEDULED"
	case EventStatusQueued:
		return "QUEUED"
	case EventStatusHold:
		return "HOLD"
	case EventStatusSuccessful:
		return "SUCCESSFUL"
	case EventStatusFailed:
		return "FAILED"
	}
}

func (e EventStatus) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", e.String())), nil
}

func (e *EventStatus) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "SCHEDULED":
		value := EventStatusScheduled
		*e = value
	case "QUEUED":
		value := EventStatusQueued
		*e = value
	case "HOLD":
		value := EventStatusHold
		*e = value
	case "SUCCESSFUL":
		value := EventStatusSuccessful
		*e = value
	case "FAILED":
		value := EventStatusFailed
		*e = value
	}
	return nil
}

type FilterRule struct {
	Headers *ConnectionFilterProperty `json:"headers,omitempty"`
	Body    *ConnectionFilterProperty `json:"body,omitempty"`
	Query   *ConnectionFilterProperty `json:"query,omitempty"`
	Path    *ConnectionFilterProperty `json:"path,omitempty"`
	type_   string
}

func (f *FilterRule) Type() string {
	return f.type_
}

func (f *FilterRule) UnmarshalJSON(data []byte) error {
	type unmarshaler FilterRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FilterRule(value)
	f.type_ = "filter"
	return nil
}

func (f *FilterRule) MarshalJSON() ([]byte, error) {
	type embed FilterRule
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*f),
		Type:  "filter",
	}
	return json.Marshal(marshaler)
}

type FilteredMeta uint

const (
	FilteredMetaBody FilteredMeta = iota + 1
	FilteredMetaHeaders
	FilteredMetaPath
	FilteredMetaQuery
)

func (f FilteredMeta) String() string {
	switch f {
	default:
		return strconv.Itoa(int(f))
	case FilteredMetaBody:
		return "body"
	case FilteredMetaHeaders:
		return "headers"
	case FilteredMetaPath:
		return "path"
	case FilteredMetaQuery:
		return "query"
	}
}

func (f FilteredMeta) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", f.String())), nil
}

func (f *FilteredMeta) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "body":
		value := FilteredMetaBody
		*f = value
	case "headers":
		value := FilteredMetaHeaders
		*f = value
	case "path":
		value := FilteredMetaPath
		*f = value
	case "query":
		value := FilteredMetaQuery
		*f = value
	}
	return nil
}

type GenerateEventBulkRetryPlanResponse struct {
	// Number of batches required to complete the bulk retry
	EstimatedBatch *int `json:"estimated_batch,omitempty"`
	// Number of estimated events to be retried
	EstimatedCount *int `json:"estimated_count,omitempty"`
	// Progression of the batch operations, values 0 - 1
	Progress *float64 `json:"progress,omitempty"`
}

type GenerateIgnoredEventBulkRetryPlanResponse struct {
	// Number of batches required to complete the bulk retry
	EstimatedBatch *int `json:"estimated_batch,omitempty"`
	// Number of estimated events to be retried
	EstimatedCount *int `json:"estimated_count,omitempty"`
	// Progression of the batch operations, values 0 - 1
	Progress *float64 `json:"progress,omitempty"`
}

type GenerateRequestBulkRetryPlanResponse struct {
	// Number of batches required to complete the bulk retry
	EstimatedBatch *int `json:"estimated_batch,omitempty"`
	// Number of estimated events to be retried
	EstimatedCount *int `json:"estimated_count,omitempty"`
	// Progression of the batch operations, values 0 - 1
	Progress *float64 `json:"progress,omitempty"`
}

type GetAttemptsRequestDir uint

const (
	GetAttemptsRequestDirAsc GetAttemptsRequestDir = iota + 1
	GetAttemptsRequestDirDesc
)

func (g GetAttemptsRequestDir) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GetAttemptsRequestDirAsc:
		return "asc"
	case GetAttemptsRequestDirDesc:
		return "desc"
	}
}

func (g GetAttemptsRequestDir) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GetAttemptsRequestDir) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "asc":
		value := GetAttemptsRequestDirAsc
		*g = value
	case "desc":
		value := GetAttemptsRequestDirDesc
		*g = value
	}
	return nil
}

type GetBookmarksRequestDir uint

const (
	GetBookmarksRequestDirAsc GetBookmarksRequestDir = iota + 1
	GetBookmarksRequestDirDesc
)

func (g GetBookmarksRequestDir) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GetBookmarksRequestDirAsc:
		return "asc"
	case GetBookmarksRequestDirDesc:
		return "desc"
	}
}

func (g GetBookmarksRequestDir) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GetBookmarksRequestDir) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "asc":
		value := GetBookmarksRequestDirAsc
		*g = value
	case "desc":
		value := GetBookmarksRequestDirDesc
		*g = value
	}
	return nil
}

type GetConnectionsRequestDir uint

const (
	GetConnectionsRequestDirAsc GetConnectionsRequestDir = iota + 1
	GetConnectionsRequestDirDesc
)

func (g GetConnectionsRequestDir) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GetConnectionsRequestDirAsc:
		return "asc"
	case GetConnectionsRequestDirDesc:
		return "desc"
	}
}

func (g GetConnectionsRequestDir) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GetConnectionsRequestDir) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "asc":
		value := GetConnectionsRequestDirAsc
		*g = value
	case "desc":
		value := GetConnectionsRequestDirDesc
		*g = value
	}
	return nil
}

type GetConnectionsRequestOrderBy uint

const (
	GetConnectionsRequestOrderByCreatedAt GetConnectionsRequestOrderBy = iota + 1
	GetConnectionsRequestOrderByUpdatedAt
	GetConnectionsRequestOrderBySourcesUpdatedAt
	GetConnectionsRequestOrderBySourcesCreatedAt
	GetConnectionsRequestOrderByDestinationsUpdatedAt
	GetConnectionsRequestOrderByDestinationsCreatedAt
)

func (g GetConnectionsRequestOrderBy) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GetConnectionsRequestOrderByCreatedAt:
		return "created_at"
	case GetConnectionsRequestOrderByUpdatedAt:
		return "updated_at"
	case GetConnectionsRequestOrderBySourcesUpdatedAt:
		return "sources.updated_at"
	case GetConnectionsRequestOrderBySourcesCreatedAt:
		return "sources.created_at"
	case GetConnectionsRequestOrderByDestinationsUpdatedAt:
		return "destinations.updated_at"
	case GetConnectionsRequestOrderByDestinationsCreatedAt:
		return "destinations.created_at"
	}
}

func (g GetConnectionsRequestOrderBy) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GetConnectionsRequestOrderBy) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "created_at":
		value := GetConnectionsRequestOrderByCreatedAt
		*g = value
	case "updated_at":
		value := GetConnectionsRequestOrderByUpdatedAt
		*g = value
	case "sources.updated_at":
		value := GetConnectionsRequestOrderBySourcesUpdatedAt
		*g = value
	case "sources.created_at":
		value := GetConnectionsRequestOrderBySourcesCreatedAt
		*g = value
	case "destinations.updated_at":
		value := GetConnectionsRequestOrderByDestinationsUpdatedAt
		*g = value
	case "destinations.created_at":
		value := GetConnectionsRequestOrderByDestinationsCreatedAt
		*g = value
	}
	return nil
}

type GetDestinationsRequestDir uint

const (
	GetDestinationsRequestDirAsc GetDestinationsRequestDir = iota + 1
	GetDestinationsRequestDirDesc
)

func (g GetDestinationsRequestDir) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GetDestinationsRequestDirAsc:
		return "asc"
	case GetDestinationsRequestDirDesc:
		return "desc"
	}
}

func (g GetDestinationsRequestDir) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GetDestinationsRequestDir) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "asc":
		value := GetDestinationsRequestDirAsc
		*g = value
	case "desc":
		value := GetDestinationsRequestDirDesc
		*g = value
	}
	return nil
}

type GetEventBulkRetriesRequestDir uint

const (
	GetEventBulkRetriesRequestDirAsc GetEventBulkRetriesRequestDir = iota + 1
	GetEventBulkRetriesRequestDirDesc
)

func (g GetEventBulkRetriesRequestDir) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GetEventBulkRetriesRequestDirAsc:
		return "asc"
	case GetEventBulkRetriesRequestDirDesc:
		return "desc"
	}
}

func (g GetEventBulkRetriesRequestDir) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GetEventBulkRetriesRequestDir) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "asc":
		value := GetEventBulkRetriesRequestDirAsc
		*g = value
	case "desc":
		value := GetEventBulkRetriesRequestDirDesc
		*g = value
	}
	return nil
}

// Sort direction
type GetEventsRequestDir uint

const (
	GetEventsRequestDirAsc GetEventsRequestDir = iota + 1
	GetEventsRequestDirDesc
)

func (g GetEventsRequestDir) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GetEventsRequestDirAsc:
		return "asc"
	case GetEventsRequestDirDesc:
		return "desc"
	}
}

func (g GetEventsRequestDir) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GetEventsRequestDir) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "asc":
		value := GetEventsRequestDirAsc
		*g = value
	case "desc":
		value := GetEventsRequestDirDesc
		*g = value
	}
	return nil
}

// Sort key
type GetEventsRequestOrderBy uint

const (
	GetEventsRequestOrderByLastAttemptAt GetEventsRequestOrderBy = iota + 1
	GetEventsRequestOrderByCreatedAt
)

func (g GetEventsRequestOrderBy) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GetEventsRequestOrderByLastAttemptAt:
		return "last_attempt_at"
	case GetEventsRequestOrderByCreatedAt:
		return "created_at"
	}
}

func (g GetEventsRequestOrderBy) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GetEventsRequestOrderBy) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "last_attempt_at":
		value := GetEventsRequestOrderByLastAttemptAt
		*g = value
	case "created_at":
		value := GetEventsRequestOrderByCreatedAt
		*g = value
	}
	return nil
}

type GetIgnoredEventBulkRetriesRequestDir uint

const (
	GetIgnoredEventBulkRetriesRequestDirAsc GetIgnoredEventBulkRetriesRequestDir = iota + 1
	GetIgnoredEventBulkRetriesRequestDirDesc
)

func (g GetIgnoredEventBulkRetriesRequestDir) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GetIgnoredEventBulkRetriesRequestDirAsc:
		return "asc"
	case GetIgnoredEventBulkRetriesRequestDirDesc:
		return "desc"
	}
}

func (g GetIgnoredEventBulkRetriesRequestDir) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GetIgnoredEventBulkRetriesRequestDir) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "asc":
		value := GetIgnoredEventBulkRetriesRequestDirAsc
		*g = value
	case "desc":
		value := GetIgnoredEventBulkRetriesRequestDirDesc
		*g = value
	}
	return nil
}

type GetIssueCountRequestDir uint

const (
	GetIssueCountRequestDirAsc GetIssueCountRequestDir = iota + 1
	GetIssueCountRequestDirDesc
)

func (g GetIssueCountRequestDir) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GetIssueCountRequestDirAsc:
		return "asc"
	case GetIssueCountRequestDirDesc:
		return "desc"
	}
}

func (g GetIssueCountRequestDir) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GetIssueCountRequestDir) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "asc":
		value := GetIssueCountRequestDirAsc
		*g = value
	case "desc":
		value := GetIssueCountRequestDirDesc
		*g = value
	}
	return nil
}

type GetIssueCountRequestOrderBy uint

const (
	GetIssueCountRequestOrderByCreatedAt GetIssueCountRequestOrderBy = iota + 1
	GetIssueCountRequestOrderByFirstSeenAt
	GetIssueCountRequestOrderByLastSeenAt
	GetIssueCountRequestOrderByOpenedAt
	GetIssueCountRequestOrderByStatus
)

func (g GetIssueCountRequestOrderBy) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GetIssueCountRequestOrderByCreatedAt:
		return "created_at"
	case GetIssueCountRequestOrderByFirstSeenAt:
		return "first_seen_at"
	case GetIssueCountRequestOrderByLastSeenAt:
		return "last_seen_at"
	case GetIssueCountRequestOrderByOpenedAt:
		return "opened_at"
	case GetIssueCountRequestOrderByStatus:
		return "status"
	}
}

func (g GetIssueCountRequestOrderBy) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GetIssueCountRequestOrderBy) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "created_at":
		value := GetIssueCountRequestOrderByCreatedAt
		*g = value
	case "first_seen_at":
		value := GetIssueCountRequestOrderByFirstSeenAt
		*g = value
	case "last_seen_at":
		value := GetIssueCountRequestOrderByLastSeenAt
		*g = value
	case "opened_at":
		value := GetIssueCountRequestOrderByOpenedAt
		*g = value
	case "status":
		value := GetIssueCountRequestOrderByStatus
		*g = value
	}
	return nil
}

// Issue status
type GetIssueCountRequestStatus uint

const (
	GetIssueCountRequestStatusOpened GetIssueCountRequestStatus = iota + 1
	GetIssueCountRequestStatusIgnored
	GetIssueCountRequestStatusAcknowledged
	GetIssueCountRequestStatusResolved
)

func (g GetIssueCountRequestStatus) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GetIssueCountRequestStatusOpened:
		return "OPENED"
	case GetIssueCountRequestStatusIgnored:
		return "IGNORED"
	case GetIssueCountRequestStatusAcknowledged:
		return "ACKNOWLEDGED"
	case GetIssueCountRequestStatusResolved:
		return "RESOLVED"
	}
}

func (g GetIssueCountRequestStatus) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GetIssueCountRequestStatus) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "OPENED":
		value := GetIssueCountRequestStatusOpened
		*g = value
	case "IGNORED":
		value := GetIssueCountRequestStatusIgnored
		*g = value
	case "ACKNOWLEDGED":
		value := GetIssueCountRequestStatusAcknowledged
		*g = value
	case "RESOLVED":
		value := GetIssueCountRequestStatusResolved
		*g = value
	}
	return nil
}

// Issue type
type GetIssueCountRequestType uint

const (
	GetIssueCountRequestTypeDelivery GetIssueCountRequestType = iota + 1
	GetIssueCountRequestTypeTransformation
	GetIssueCountRequestTypeBackpressure
)

func (g GetIssueCountRequestType) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GetIssueCountRequestTypeDelivery:
		return "delivery"
	case GetIssueCountRequestTypeTransformation:
		return "transformation"
	case GetIssueCountRequestTypeBackpressure:
		return "backpressure"
	}
}

func (g GetIssueCountRequestType) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GetIssueCountRequestType) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "delivery":
		value := GetIssueCountRequestTypeDelivery
		*g = value
	case "transformation":
		value := GetIssueCountRequestTypeTransformation
		*g = value
	case "backpressure":
		value := GetIssueCountRequestTypeBackpressure
		*g = value
	}
	return nil
}

type GetIssueTriggersRequestDir uint

const (
	GetIssueTriggersRequestDirAsc GetIssueTriggersRequestDir = iota + 1
	GetIssueTriggersRequestDirDesc
)

func (g GetIssueTriggersRequestDir) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GetIssueTriggersRequestDirAsc:
		return "asc"
	case GetIssueTriggersRequestDirDesc:
		return "desc"
	}
}

func (g GetIssueTriggersRequestDir) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GetIssueTriggersRequestDir) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "asc":
		value := GetIssueTriggersRequestDirAsc
		*g = value
	case "desc":
		value := GetIssueTriggersRequestDirDesc
		*g = value
	}
	return nil
}

type GetIssueTriggersRequestOrderBy uint

const (
	GetIssueTriggersRequestOrderByCreatedAt GetIssueTriggersRequestOrderBy = iota + 1
	GetIssueTriggersRequestOrderByType
)

func (g GetIssueTriggersRequestOrderBy) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GetIssueTriggersRequestOrderByCreatedAt:
		return "created_at"
	case GetIssueTriggersRequestOrderByType:
		return "type"
	}
}

func (g GetIssueTriggersRequestOrderBy) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GetIssueTriggersRequestOrderBy) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "created_at":
		value := GetIssueTriggersRequestOrderByCreatedAt
		*g = value
	case "type":
		value := GetIssueTriggersRequestOrderByType
		*g = value
	}
	return nil
}

type GetIssuesRequestDir uint

const (
	GetIssuesRequestDirAsc GetIssuesRequestDir = iota + 1
	GetIssuesRequestDirDesc
)

func (g GetIssuesRequestDir) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GetIssuesRequestDirAsc:
		return "asc"
	case GetIssuesRequestDirDesc:
		return "desc"
	}
}

func (g GetIssuesRequestDir) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GetIssuesRequestDir) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "asc":
		value := GetIssuesRequestDirAsc
		*g = value
	case "desc":
		value := GetIssuesRequestDirDesc
		*g = value
	}
	return nil
}

type GetIssuesRequestOrderBy uint

const (
	GetIssuesRequestOrderByCreatedAt GetIssuesRequestOrderBy = iota + 1
	GetIssuesRequestOrderByFirstSeenAt
	GetIssuesRequestOrderByLastSeenAt
	GetIssuesRequestOrderByOpenedAt
	GetIssuesRequestOrderByStatus
)

func (g GetIssuesRequestOrderBy) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GetIssuesRequestOrderByCreatedAt:
		return "created_at"
	case GetIssuesRequestOrderByFirstSeenAt:
		return "first_seen_at"
	case GetIssuesRequestOrderByLastSeenAt:
		return "last_seen_at"
	case GetIssuesRequestOrderByOpenedAt:
		return "opened_at"
	case GetIssuesRequestOrderByStatus:
		return "status"
	}
}

func (g GetIssuesRequestOrderBy) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GetIssuesRequestOrderBy) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "created_at":
		value := GetIssuesRequestOrderByCreatedAt
		*g = value
	case "first_seen_at":
		value := GetIssuesRequestOrderByFirstSeenAt
		*g = value
	case "last_seen_at":
		value := GetIssuesRequestOrderByLastSeenAt
		*g = value
	case "opened_at":
		value := GetIssuesRequestOrderByOpenedAt
		*g = value
	case "status":
		value := GetIssuesRequestOrderByStatus
		*g = value
	}
	return nil
}

// Issue status
type GetIssuesRequestStatus uint

const (
	GetIssuesRequestStatusOpened GetIssuesRequestStatus = iota + 1
	GetIssuesRequestStatusIgnored
	GetIssuesRequestStatusAcknowledged
	GetIssuesRequestStatusResolved
)

func (g GetIssuesRequestStatus) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GetIssuesRequestStatusOpened:
		return "OPENED"
	case GetIssuesRequestStatusIgnored:
		return "IGNORED"
	case GetIssuesRequestStatusAcknowledged:
		return "ACKNOWLEDGED"
	case GetIssuesRequestStatusResolved:
		return "RESOLVED"
	}
}

func (g GetIssuesRequestStatus) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GetIssuesRequestStatus) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "OPENED":
		value := GetIssuesRequestStatusOpened
		*g = value
	case "IGNORED":
		value := GetIssuesRequestStatusIgnored
		*g = value
	case "ACKNOWLEDGED":
		value := GetIssuesRequestStatusAcknowledged
		*g = value
	case "RESOLVED":
		value := GetIssuesRequestStatusResolved
		*g = value
	}
	return nil
}

// Issue type
type GetIssuesRequestType uint

const (
	GetIssuesRequestTypeDelivery GetIssuesRequestType = iota + 1
	GetIssuesRequestTypeTransformation
	GetIssuesRequestTypeBackpressure
)

func (g GetIssuesRequestType) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GetIssuesRequestTypeDelivery:
		return "delivery"
	case GetIssuesRequestTypeTransformation:
		return "transformation"
	case GetIssuesRequestTypeBackpressure:
		return "backpressure"
	}
}

func (g GetIssuesRequestType) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GetIssuesRequestType) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "delivery":
		value := GetIssuesRequestTypeDelivery
		*g = value
	case "transformation":
		value := GetIssuesRequestTypeTransformation
		*g = value
	case "backpressure":
		value := GetIssuesRequestTypeBackpressure
		*g = value
	}
	return nil
}

type GetRequestBulkRetriesRequestDir uint

const (
	GetRequestBulkRetriesRequestDirAsc GetRequestBulkRetriesRequestDir = iota + 1
	GetRequestBulkRetriesRequestDirDesc
)

func (g GetRequestBulkRetriesRequestDir) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GetRequestBulkRetriesRequestDirAsc:
		return "asc"
	case GetRequestBulkRetriesRequestDirDesc:
		return "desc"
	}
}

func (g GetRequestBulkRetriesRequestDir) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GetRequestBulkRetriesRequestDir) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "asc":
		value := GetRequestBulkRetriesRequestDirAsc
		*g = value
	case "desc":
		value := GetRequestBulkRetriesRequestDirDesc
		*g = value
	}
	return nil
}

// Sort direction
type GetRequestEventsRequestDir uint

const (
	GetRequestEventsRequestDirAsc GetRequestEventsRequestDir = iota + 1
	GetRequestEventsRequestDirDesc
)

func (g GetRequestEventsRequestDir) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GetRequestEventsRequestDirAsc:
		return "asc"
	case GetRequestEventsRequestDirDesc:
		return "desc"
	}
}

func (g GetRequestEventsRequestDir) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GetRequestEventsRequestDir) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "asc":
		value := GetRequestEventsRequestDirAsc
		*g = value
	case "desc":
		value := GetRequestEventsRequestDirDesc
		*g = value
	}
	return nil
}

// Sort key
type GetRequestEventsRequestOrderBy uint

const (
	GetRequestEventsRequestOrderByLastAttemptAt GetRequestEventsRequestOrderBy = iota + 1
	GetRequestEventsRequestOrderByCreatedAt
)

func (g GetRequestEventsRequestOrderBy) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GetRequestEventsRequestOrderByLastAttemptAt:
		return "last_attempt_at"
	case GetRequestEventsRequestOrderByCreatedAt:
		return "created_at"
	}
}

func (g GetRequestEventsRequestOrderBy) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GetRequestEventsRequestOrderBy) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "last_attempt_at":
		value := GetRequestEventsRequestOrderByLastAttemptAt
		*g = value
	case "created_at":
		value := GetRequestEventsRequestOrderByCreatedAt
		*g = value
	}
	return nil
}

type GetRequestIgnoredEventsRequestDir uint

const (
	GetRequestIgnoredEventsRequestDirAsc GetRequestIgnoredEventsRequestDir = iota + 1
	GetRequestIgnoredEventsRequestDirDesc
)

func (g GetRequestIgnoredEventsRequestDir) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GetRequestIgnoredEventsRequestDirAsc:
		return "asc"
	case GetRequestIgnoredEventsRequestDirDesc:
		return "desc"
	}
}

func (g GetRequestIgnoredEventsRequestDir) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GetRequestIgnoredEventsRequestDir) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "asc":
		value := GetRequestIgnoredEventsRequestDirAsc
		*g = value
	case "desc":
		value := GetRequestIgnoredEventsRequestDirDesc
		*g = value
	}
	return nil
}

// Sort direction
type GetRequestsRequestDir uint

const (
	GetRequestsRequestDirAsc GetRequestsRequestDir = iota + 1
	GetRequestsRequestDirDesc
)

func (g GetRequestsRequestDir) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GetRequestsRequestDirAsc:
		return "asc"
	case GetRequestsRequestDirDesc:
		return "desc"
	}
}

func (g GetRequestsRequestDir) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GetRequestsRequestDir) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "asc":
		value := GetRequestsRequestDirAsc
		*g = value
	case "desc":
		value := GetRequestsRequestDirDesc
		*g = value
	}
	return nil
}

// Sort key
type GetRequestsRequestOrderBy uint

const (
	GetRequestsRequestOrderByIngestedAt GetRequestsRequestOrderBy = iota + 1
	GetRequestsRequestOrderByCreatedAt
)

func (g GetRequestsRequestOrderBy) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GetRequestsRequestOrderByIngestedAt:
		return "ingested_at"
	case GetRequestsRequestOrderByCreatedAt:
		return "created_at"
	}
}

func (g GetRequestsRequestOrderBy) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GetRequestsRequestOrderBy) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "ingested_at":
		value := GetRequestsRequestOrderByIngestedAt
		*g = value
	case "created_at":
		value := GetRequestsRequestOrderByCreatedAt
		*g = value
	}
	return nil
}

// Filter by status
type GetRequestsRequestStatus uint

const (
	GetRequestsRequestStatusAccepted GetRequestsRequestStatus = iota + 1
	GetRequestsRequestStatusRejected
)

func (g GetRequestsRequestStatus) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GetRequestsRequestStatusAccepted:
		return "accepted"
	case GetRequestsRequestStatusRejected:
		return "rejected"
	}
}

func (g GetRequestsRequestStatus) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GetRequestsRequestStatus) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "accepted":
		value := GetRequestsRequestStatusAccepted
		*g = value
	case "rejected":
		value := GetRequestsRequestStatusRejected
		*g = value
	}
	return nil
}

type GetSourcesRequestDir uint

const (
	GetSourcesRequestDirAsc GetSourcesRequestDir = iota + 1
	GetSourcesRequestDirDesc
)

func (g GetSourcesRequestDir) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GetSourcesRequestDirAsc:
		return "asc"
	case GetSourcesRequestDirDesc:
		return "desc"
	}
}

func (g GetSourcesRequestDir) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GetSourcesRequestDir) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "asc":
		value := GetSourcesRequestDirAsc
		*g = value
	case "desc":
		value := GetSourcesRequestDirDesc
		*g = value
	}
	return nil
}

type GetTransformationExecutionsRequestDir uint

const (
	GetTransformationExecutionsRequestDirAsc GetTransformationExecutionsRequestDir = iota + 1
	GetTransformationExecutionsRequestDirDesc
)

func (g GetTransformationExecutionsRequestDir) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GetTransformationExecutionsRequestDirAsc:
		return "asc"
	case GetTransformationExecutionsRequestDirDesc:
		return "desc"
	}
}

func (g GetTransformationExecutionsRequestDir) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GetTransformationExecutionsRequestDir) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "asc":
		value := GetTransformationExecutionsRequestDirAsc
		*g = value
	case "desc":
		value := GetTransformationExecutionsRequestDirDesc
		*g = value
	}
	return nil
}

type GetTransformationExecutionsRequestLogLevel uint

const (
	GetTransformationExecutionsRequestLogLevelDebug GetTransformationExecutionsRequestLogLevel = iota + 1
	GetTransformationExecutionsRequestLogLevelInfo
	GetTransformationExecutionsRequestLogLevelWarn
	GetTransformationExecutionsRequestLogLevelError
	GetTransformationExecutionsRequestLogLevelFatal
)

func (g GetTransformationExecutionsRequestLogLevel) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GetTransformationExecutionsRequestLogLevelDebug:
		return "debug"
	case GetTransformationExecutionsRequestLogLevelInfo:
		return "info"
	case GetTransformationExecutionsRequestLogLevelWarn:
		return "warn"
	case GetTransformationExecutionsRequestLogLevelError:
		return "error"
	case GetTransformationExecutionsRequestLogLevelFatal:
		return "fatal"
	}
}

func (g GetTransformationExecutionsRequestLogLevel) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GetTransformationExecutionsRequestLogLevel) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "debug":
		value := GetTransformationExecutionsRequestLogLevelDebug
		*g = value
	case "info":
		value := GetTransformationExecutionsRequestLogLevelInfo
		*g = value
	case "warn":
		value := GetTransformationExecutionsRequestLogLevelWarn
		*g = value
	case "error":
		value := GetTransformationExecutionsRequestLogLevelError
		*g = value
	case "fatal":
		value := GetTransformationExecutionsRequestLogLevelFatal
		*g = value
	}
	return nil
}

type GetTransformationsRequestDir uint

const (
	GetTransformationsRequestDirAsc GetTransformationsRequestDir = iota + 1
	GetTransformationsRequestDirDesc
)

func (g GetTransformationsRequestDir) String() string {
	switch g {
	default:
		return strconv.Itoa(int(g))
	case GetTransformationsRequestDirAsc:
		return "asc"
	case GetTransformationsRequestDirDesc:
		return "desc"
	}
}

func (g GetTransformationsRequestDir) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", g.String())), nil
}

func (g *GetTransformationsRequestDir) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "asc":
		value := GetTransformationsRequestDirAsc
		*g = value
	case "desc":
		value := GetTransformationsRequestDirDesc
		*g = value
	}
	return nil
}

type GitHub struct {
	Configs *GitHubConfigs `json:"configs,omitempty"`
	type_   string
}

func (g *GitHub) Type() string {
	return g.type_
}

func (g *GitHub) UnmarshalJSON(data []byte) error {
	type unmarshaler GitHub
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GitHub(value)
	g.type_ = "github"
	return nil
}

func (g *GitHub) MarshalJSON() ([]byte, error) {
	type embed GitHub
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
		Type:  "github",
	}
	return json.Marshal(marshaler)
}

// The verification configs for GitHub. Only included if the ?include=verification.configs query param is present
type GitHubConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type GitLab struct {
	Configs *GitLabConfigs `json:"configs,omitempty"`
	type_   string
}

func (g *GitLab) Type() string {
	return g.type_
}

func (g *GitLab) UnmarshalJSON(data []byte) error {
	type unmarshaler GitLab
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GitLab(value)
	g.type_ = "gitlab"
	return nil
}

func (g *GitLab) MarshalJSON() ([]byte, error) {
	type embed GitLab
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
		Type:  "gitlab",
	}
	return json.Marshal(marshaler)
}

// The verification configs for GitLab. Only included if the ?include=verification.configs query param is present
type GitLabConfigs struct {
	ApiKey string `json:"api_key"`
}

type HandledApiKeyIntegrationConfigs struct {
	ApiKey string `json:"api_key"`
}

type HandledHmacConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type Hmac struct {
	Configs *HmacConfigs `json:"configs,omitempty"`
	type_   string
}

func (h *Hmac) Type() string {
	return h.type_
}

func (h *Hmac) UnmarshalJSON(data []byte) error {
	type unmarshaler Hmac
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = Hmac(value)
	h.type_ = "hmac"
	return nil
}

func (h *Hmac) MarshalJSON() ([]byte, error) {
	type embed Hmac
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*h),
		Type:  "hmac",
	}
	return json.Marshal(marshaler)
}

type HmacAlgorithms uint

const (
	HmacAlgorithmsMd5 HmacAlgorithms = iota + 1
	HmacAlgorithmsSha1
	HmacAlgorithmsSha256
	HmacAlgorithmsSha512
)

func (h HmacAlgorithms) String() string {
	switch h {
	default:
		return strconv.Itoa(int(h))
	case HmacAlgorithmsMd5:
		return "md5"
	case HmacAlgorithmsSha1:
		return "sha1"
	case HmacAlgorithmsSha256:
		return "sha256"
	case HmacAlgorithmsSha512:
		return "sha512"
	}
}

func (h HmacAlgorithms) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", h.String())), nil
}

func (h *HmacAlgorithms) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "md5":
		value := HmacAlgorithmsMd5
		*h = value
	case "sha1":
		value := HmacAlgorithmsSha1
		*h = value
	case "sha256":
		value := HmacAlgorithmsSha256
		*h = value
	case "sha512":
		value := HmacAlgorithmsSha512
		*h = value
	}
	return nil
}

// The verification configs for HMAC. Only included if the ?include=verification.configs query param is present
type HmacConfigs struct {
	WebhookSecretKey string              `json:"webhook_secret_key"`
	Algorithm        HmacAlgorithms      `json:"algorithm,omitempty"`
	HeaderKey        string              `json:"header_key"`
	Encoding         HmacConfigsEncoding `json:"encoding,omitempty"`
}

type HmacConfigsEncoding uint

const (
	HmacConfigsEncodingBase64 HmacConfigsEncoding = iota + 1
	HmacConfigsEncodingHex
)

func (h HmacConfigsEncoding) String() string {
	switch h {
	default:
		return strconv.Itoa(int(h))
	case HmacConfigsEncodingBase64:
		return "base64"
	case HmacConfigsEncodingHex:
		return "hex"
	}
}

func (h HmacConfigsEncoding) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", h.String())), nil
}

func (h *HmacConfigsEncoding) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "base64":
		value := HmacConfigsEncodingBase64
		*h = value
	case "hex":
		value := HmacConfigsEncodingHex
		*h = value
	}
	return nil
}

type HmacIntegrationConfigs struct {
	WebhookSecretKey string                         `json:"webhook_secret_key"`
	Algorithm        HmacAlgorithms                 `json:"algorithm,omitempty"`
	HeaderKey        string                         `json:"header_key"`
	Encoding         HmacIntegrationConfigsEncoding `json:"encoding,omitempty"`
}

type HmacIntegrationConfigsEncoding uint

const (
	HmacIntegrationConfigsEncodingBase64 HmacIntegrationConfigsEncoding = iota + 1
	HmacIntegrationConfigsEncodingHex
)

func (h HmacIntegrationConfigsEncoding) String() string {
	switch h {
	default:
		return strconv.Itoa(int(h))
	case HmacIntegrationConfigsEncodingBase64:
		return "base64"
	case HmacIntegrationConfigsEncodingHex:
		return "hex"
	}
}

func (h HmacIntegrationConfigsEncoding) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", h.String())), nil
}

func (h *HmacIntegrationConfigsEncoding) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "base64":
		value := HmacIntegrationConfigsEncodingBase64
		*h = value
	case "hex":
		value := HmacIntegrationConfigsEncodingHex
		*h = value
	}
	return nil
}

// Hookdeck Signature
type HookdeckSignature struct {
	Config *DestinationAuthMethodSignatureConfig `json:"config,omitempty"`
	type_  string
}

func (h *HookdeckSignature) Type() string {
	return h.type_
}

func (h *HookdeckSignature) UnmarshalJSON(data []byte) error {
	type unmarshaler HookdeckSignature
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HookdeckSignature(value)
	h.type_ = "HOOKDECK_SIGNATURE"
	return nil
}

func (h *HookdeckSignature) MarshalJSON() ([]byte, error) {
	type embed HookdeckSignature
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*h),
		Type:  "HOOKDECK_SIGNATURE",
	}
	return json.Marshal(marshaler)
}

type IgnoredEvent struct {
	Id        string            `json:"id"`
	TeamId    string            `json:"team_id"`
	WebhookId string            `json:"webhook_id"`
	Cause     IgnoredEventCause `json:"cause,omitempty"`
	RequestId string            `json:"request_id"`
	Meta      *IgnoredEventMeta `json:"meta,omitempty"`
	UpdatedAt time.Time         `json:"updated_at"`
	CreatedAt time.Time         `json:"created_at"`
}

type IgnoredEventCause uint

const (
	IgnoredEventCauseArchived IgnoredEventCause = iota + 1
	IgnoredEventCauseFiltered
	IgnoredEventCauseTransformationFailed
	IgnoredEventCauseCliDisconnected
)

func (i IgnoredEventCause) String() string {
	switch i {
	default:
		return strconv.Itoa(int(i))
	case IgnoredEventCauseArchived:
		return "ARCHIVED"
	case IgnoredEventCauseFiltered:
		return "FILTERED"
	case IgnoredEventCauseTransformationFailed:
		return "TRANSFORMATION_FAILED"
	case IgnoredEventCauseCliDisconnected:
		return "CLI_DISCONNECTED"
	}
}

func (i IgnoredEventCause) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", i.String())), nil
}

func (i *IgnoredEventCause) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "ARCHIVED":
		value := IgnoredEventCauseArchived
		*i = value
	case "FILTERED":
		value := IgnoredEventCauseFiltered
		*i = value
	case "TRANSFORMATION_FAILED":
		value := IgnoredEventCauseTransformationFailed
		*i = value
	case "CLI_DISCONNECTED":
		value := IgnoredEventCauseCliDisconnected
		*i = value
	}
	return nil
}

type IgnoredEventMeta struct {
	typeName                 string
	FilteredMeta             FilteredMeta
	TransformationFailedMeta *TransformationFailedMeta
}

func NewIgnoredEventMetaFromFilteredMeta(value FilteredMeta) *IgnoredEventMeta {
	return &IgnoredEventMeta{typeName: "filteredMeta", FilteredMeta: value}
}

func NewIgnoredEventMetaFromTransformationFailedMeta(value *TransformationFailedMeta) *IgnoredEventMeta {
	return &IgnoredEventMeta{typeName: "transformationFailedMeta", TransformationFailedMeta: value}
}

func (i *IgnoredEventMeta) UnmarshalJSON(data []byte) error {
	var valueFilteredMeta FilteredMeta
	if err := json.Unmarshal(data, &valueFilteredMeta); err == nil {
		i.typeName = "filteredMeta"
		i.FilteredMeta = valueFilteredMeta
		return nil
	}
	valueTransformationFailedMeta := new(TransformationFailedMeta)
	if err := json.Unmarshal(data, &valueTransformationFailedMeta); err == nil {
		i.typeName = "transformationFailedMeta"
		i.TransformationFailedMeta = valueTransformationFailedMeta
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IgnoredEventMeta) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "filteredMeta":
		return json.Marshal(i.FilteredMeta)
	case "transformationFailedMeta":
		return json.Marshal(i.TransformationFailedMeta)
	}
}

type IgnoredEventMetaVisitor interface {
	VisitFilteredMeta(FilteredMeta) error
	VisitTransformationFailedMeta(*TransformationFailedMeta) error
}

func (i *IgnoredEventMeta) Accept(visitor IgnoredEventMetaVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "filteredMeta":
		return visitor.VisitFilteredMeta(i.FilteredMeta)
	case "transformationFailedMeta":
		return visitor.VisitTransformationFailedMeta(i.TransformationFailedMeta)
	}
}

type IgnoredEventPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*IgnoredEvent `json:"models,omitempty"`
}

type Integration struct {
	// ID of the integration
	Id string `json:"id"`
	// ID of the workspace
	TeamId string `json:"team_id"`
	// Label of the integration
	Label    string              `json:"label"`
	Provider IntegrationProvider `json:"provider,omitempty"`
	// List of features to enable (see features list below)
	Features []IntegrationFeature `json:"features,omitempty"`
	// Decrypted Key/Value object of the associated configuration for that provider
	Configs *IntegrationConfigs `json:"configs,omitempty"`
	// List of source IDs the integration is attached to
	Sources []string `json:"sources,omitempty"`
	// Date the integration was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the integration was created
	CreatedAt time.Time `json:"created_at"`
}

// Decrypted Key/Value object of the associated configuration for that provider
type IntegrationConfigs struct {
	typeName                        string
	HmacIntegrationConfigs          *HmacIntegrationConfigs
	ApiKeyIntegrationConfigs        *ApiKeyIntegrationConfigs
	HandledApiKeyIntegrationConfigs *HandledApiKeyIntegrationConfigs
	HandledHmacConfigs              *HandledHmacConfigs
	BasicAuthIntegrationConfigs     *BasicAuthIntegrationConfigs
	ShopifyIntegrationConfigs       *ShopifyIntegrationConfigs
	IntegrationConfigsSix           *IntegrationConfigsSix
}

func NewIntegrationConfigsFromHmacIntegrationConfigs(value *HmacIntegrationConfigs) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "hmacIntegrationConfigs", HmacIntegrationConfigs: value}
}

func NewIntegrationConfigsFromApiKeyIntegrationConfigs(value *ApiKeyIntegrationConfigs) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "apiKeyIntegrationConfigs", ApiKeyIntegrationConfigs: value}
}

func NewIntegrationConfigsFromHandledApiKeyIntegrationConfigs(value *HandledApiKeyIntegrationConfigs) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "handledApiKeyIntegrationConfigs", HandledApiKeyIntegrationConfigs: value}
}

func NewIntegrationConfigsFromHandledHmacConfigs(value *HandledHmacConfigs) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "handledHmacConfigs", HandledHmacConfigs: value}
}

func NewIntegrationConfigsFromBasicAuthIntegrationConfigs(value *BasicAuthIntegrationConfigs) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "basicAuthIntegrationConfigs", BasicAuthIntegrationConfigs: value}
}

func NewIntegrationConfigsFromShopifyIntegrationConfigs(value *ShopifyIntegrationConfigs) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "shopifyIntegrationConfigs", ShopifyIntegrationConfigs: value}
}

func NewIntegrationConfigsFromIntegrationConfigsSix(value *IntegrationConfigsSix) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "integrationConfigsSix", IntegrationConfigsSix: value}
}

func (i *IntegrationConfigs) UnmarshalJSON(data []byte) error {
	valueHmacIntegrationConfigs := new(HmacIntegrationConfigs)
	if err := json.Unmarshal(data, &valueHmacIntegrationConfigs); err == nil {
		i.typeName = "hmacIntegrationConfigs"
		i.HmacIntegrationConfigs = valueHmacIntegrationConfigs
		return nil
	}
	valueApiKeyIntegrationConfigs := new(ApiKeyIntegrationConfigs)
	if err := json.Unmarshal(data, &valueApiKeyIntegrationConfigs); err == nil {
		i.typeName = "apiKeyIntegrationConfigs"
		i.ApiKeyIntegrationConfigs = valueApiKeyIntegrationConfigs
		return nil
	}
	valueHandledApiKeyIntegrationConfigs := new(HandledApiKeyIntegrationConfigs)
	if err := json.Unmarshal(data, &valueHandledApiKeyIntegrationConfigs); err == nil {
		i.typeName = "handledApiKeyIntegrationConfigs"
		i.HandledApiKeyIntegrationConfigs = valueHandledApiKeyIntegrationConfigs
		return nil
	}
	valueHandledHmacConfigs := new(HandledHmacConfigs)
	if err := json.Unmarshal(data, &valueHandledHmacConfigs); err == nil {
		i.typeName = "handledHmacConfigs"
		i.HandledHmacConfigs = valueHandledHmacConfigs
		return nil
	}
	valueBasicAuthIntegrationConfigs := new(BasicAuthIntegrationConfigs)
	if err := json.Unmarshal(data, &valueBasicAuthIntegrationConfigs); err == nil {
		i.typeName = "basicAuthIntegrationConfigs"
		i.BasicAuthIntegrationConfigs = valueBasicAuthIntegrationConfigs
		return nil
	}
	valueShopifyIntegrationConfigs := new(ShopifyIntegrationConfigs)
	if err := json.Unmarshal(data, &valueShopifyIntegrationConfigs); err == nil {
		i.typeName = "shopifyIntegrationConfigs"
		i.ShopifyIntegrationConfigs = valueShopifyIntegrationConfigs
		return nil
	}
	valueIntegrationConfigsSix := new(IntegrationConfigsSix)
	if err := json.Unmarshal(data, &valueIntegrationConfigsSix); err == nil {
		i.typeName = "integrationConfigsSix"
		i.IntegrationConfigsSix = valueIntegrationConfigsSix
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IntegrationConfigs) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "hmacIntegrationConfigs":
		return json.Marshal(i.HmacIntegrationConfigs)
	case "apiKeyIntegrationConfigs":
		return json.Marshal(i.ApiKeyIntegrationConfigs)
	case "handledApiKeyIntegrationConfigs":
		return json.Marshal(i.HandledApiKeyIntegrationConfigs)
	case "handledHmacConfigs":
		return json.Marshal(i.HandledHmacConfigs)
	case "basicAuthIntegrationConfigs":
		return json.Marshal(i.BasicAuthIntegrationConfigs)
	case "shopifyIntegrationConfigs":
		return json.Marshal(i.ShopifyIntegrationConfigs)
	case "integrationConfigsSix":
		return json.Marshal(i.IntegrationConfigsSix)
	}
}

type IntegrationConfigsVisitor interface {
	VisitHmacIntegrationConfigs(*HmacIntegrationConfigs) error
	VisitApiKeyIntegrationConfigs(*ApiKeyIntegrationConfigs) error
	VisitHandledApiKeyIntegrationConfigs(*HandledApiKeyIntegrationConfigs) error
	VisitHandledHmacConfigs(*HandledHmacConfigs) error
	VisitBasicAuthIntegrationConfigs(*BasicAuthIntegrationConfigs) error
	VisitShopifyIntegrationConfigs(*ShopifyIntegrationConfigs) error
	VisitIntegrationConfigsSix(*IntegrationConfigsSix) error
}

func (i *IntegrationConfigs) Accept(visitor IntegrationConfigsVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "hmacIntegrationConfigs":
		return visitor.VisitHmacIntegrationConfigs(i.HmacIntegrationConfigs)
	case "apiKeyIntegrationConfigs":
		return visitor.VisitApiKeyIntegrationConfigs(i.ApiKeyIntegrationConfigs)
	case "handledApiKeyIntegrationConfigs":
		return visitor.VisitHandledApiKeyIntegrationConfigs(i.HandledApiKeyIntegrationConfigs)
	case "handledHmacConfigs":
		return visitor.VisitHandledHmacConfigs(i.HandledHmacConfigs)
	case "basicAuthIntegrationConfigs":
		return visitor.VisitBasicAuthIntegrationConfigs(i.BasicAuthIntegrationConfigs)
	case "shopifyIntegrationConfigs":
		return visitor.VisitShopifyIntegrationConfigs(i.ShopifyIntegrationConfigs)
	case "integrationConfigsSix":
		return visitor.VisitIntegrationConfigsSix(i.IntegrationConfigsSix)
	}
}

type IntegrationConfigsSix struct {
}

type IntegrationFeature uint

const (
	IntegrationFeatureVerification IntegrationFeature = iota + 1
	IntegrationFeatureHandshake
	IntegrationFeaturePolling
)

func (i IntegrationFeature) String() string {
	switch i {
	default:
		return strconv.Itoa(int(i))
	case IntegrationFeatureVerification:
		return "VERIFICATION"
	case IntegrationFeatureHandshake:
		return "HANDSHAKE"
	case IntegrationFeaturePolling:
		return "POLLING"
	}
}

func (i IntegrationFeature) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", i.String())), nil
}

func (i *IntegrationFeature) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "VERIFICATION":
		value := IntegrationFeatureVerification
		*i = value
	case "HANDSHAKE":
		value := IntegrationFeatureHandshake
		*i = value
	case "POLLING":
		value := IntegrationFeaturePolling
		*i = value
	}
	return nil
}

type IntegrationPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Integration  `json:"models,omitempty"`
}

type IntegrationProvider uint

const (
	IntegrationProviderHmac IntegrationProvider = iota + 1
	IntegrationProviderBasicAuth
	IntegrationProviderApiKey
	IntegrationProviderTwitter
	IntegrationProviderStripe
	IntegrationProviderRecharge
	IntegrationProviderGithub
	IntegrationProviderShopify
	IntegrationProviderPostmark
	IntegrationProviderTypeform
	IntegrationProviderXero
	IntegrationProviderSvix
	IntegrationProviderZoom
	IntegrationProviderAkeneo
	IntegrationProviderAdyen
	IntegrationProviderGitlab
	IntegrationProviderPropertyFinder
	IntegrationProviderWoocommerce
	IntegrationProviderOura
	IntegrationProviderCommercelayer
	IntegrationProviderMailgun
	IntegrationProviderPipedrive
	IntegrationProviderSendgrid
	IntegrationProviderWorkos
	IntegrationProviderSynctera
	IntegrationProviderAwsSns
	IntegrationProviderThreeDEye
)

func (i IntegrationProvider) String() string {
	switch i {
	default:
		return strconv.Itoa(int(i))
	case IntegrationProviderHmac:
		return "hmac"
	case IntegrationProviderBasicAuth:
		return "basic_auth"
	case IntegrationProviderApiKey:
		return "api_key"
	case IntegrationProviderTwitter:
		return "twitter"
	case IntegrationProviderStripe:
		return "stripe"
	case IntegrationProviderRecharge:
		return "recharge"
	case IntegrationProviderGithub:
		return "github"
	case IntegrationProviderShopify:
		return "shopify"
	case IntegrationProviderPostmark:
		return "postmark"
	case IntegrationProviderTypeform:
		return "typeform"
	case IntegrationProviderXero:
		return "xero"
	case IntegrationProviderSvix:
		return "svix"
	case IntegrationProviderZoom:
		return "zoom"
	case IntegrationProviderAkeneo:
		return "akeneo"
	case IntegrationProviderAdyen:
		return "adyen"
	case IntegrationProviderGitlab:
		return "gitlab"
	case IntegrationProviderPropertyFinder:
		return "property-finder"
	case IntegrationProviderWoocommerce:
		return "woocommerce"
	case IntegrationProviderOura:
		return "oura"
	case IntegrationProviderCommercelayer:
		return "commercelayer"
	case IntegrationProviderMailgun:
		return "mailgun"
	case IntegrationProviderPipedrive:
		return "pipedrive"
	case IntegrationProviderSendgrid:
		return "sendgrid"
	case IntegrationProviderWorkos:
		return "workos"
	case IntegrationProviderSynctera:
		return "synctera"
	case IntegrationProviderAwsSns:
		return "aws_sns"
	case IntegrationProviderThreeDEye:
		return "three_d_eye"
	}
}

func (i IntegrationProvider) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", i.String())), nil
}

func (i *IntegrationProvider) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "hmac":
		value := IntegrationProviderHmac
		*i = value
	case "basic_auth":
		value := IntegrationProviderBasicAuth
		*i = value
	case "api_key":
		value := IntegrationProviderApiKey
		*i = value
	case "twitter":
		value := IntegrationProviderTwitter
		*i = value
	case "stripe":
		value := IntegrationProviderStripe
		*i = value
	case "recharge":
		value := IntegrationProviderRecharge
		*i = value
	case "github":
		value := IntegrationProviderGithub
		*i = value
	case "shopify":
		value := IntegrationProviderShopify
		*i = value
	case "postmark":
		value := IntegrationProviderPostmark
		*i = value
	case "typeform":
		value := IntegrationProviderTypeform
		*i = value
	case "xero":
		value := IntegrationProviderXero
		*i = value
	case "svix":
		value := IntegrationProviderSvix
		*i = value
	case "zoom":
		value := IntegrationProviderZoom
		*i = value
	case "akeneo":
		value := IntegrationProviderAkeneo
		*i = value
	case "adyen":
		value := IntegrationProviderAdyen
		*i = value
	case "gitlab":
		value := IntegrationProviderGitlab
		*i = value
	case "property-finder":
		value := IntegrationProviderPropertyFinder
		*i = value
	case "woocommerce":
		value := IntegrationProviderWoocommerce
		*i = value
	case "oura":
		value := IntegrationProviderOura
		*i = value
	case "commercelayer":
		value := IntegrationProviderCommercelayer
		*i = value
	case "mailgun":
		value := IntegrationProviderMailgun
		*i = value
	case "pipedrive":
		value := IntegrationProviderPipedrive
		*i = value
	case "sendgrid":
		value := IntegrationProviderSendgrid
		*i = value
	case "workos":
		value := IntegrationProviderWorkos
		*i = value
	case "synctera":
		value := IntegrationProviderSynctera
		*i = value
	case "aws_sns":
		value := IntegrationProviderAwsSns
		*i = value
	case "three_d_eye":
		value := IntegrationProviderThreeDEye
		*i = value
	}
	return nil
}

// Issue
type Issue struct {
	typeName            string
	DeliveryIssue       *DeliveryIssue
	TransformationIssue *TransformationIssue
}

func NewIssueFromDeliveryIssue(value *DeliveryIssue) *Issue {
	return &Issue{typeName: "deliveryIssue", DeliveryIssue: value}
}

func NewIssueFromTransformationIssue(value *TransformationIssue) *Issue {
	return &Issue{typeName: "transformationIssue", TransformationIssue: value}
}

func (i *Issue) UnmarshalJSON(data []byte) error {
	valueDeliveryIssue := new(DeliveryIssue)
	if err := json.Unmarshal(data, &valueDeliveryIssue); err == nil {
		i.typeName = "deliveryIssue"
		i.DeliveryIssue = valueDeliveryIssue
		return nil
	}
	valueTransformationIssue := new(TransformationIssue)
	if err := json.Unmarshal(data, &valueTransformationIssue); err == nil {
		i.typeName = "transformationIssue"
		i.TransformationIssue = valueTransformationIssue
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i Issue) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "deliveryIssue":
		return json.Marshal(i.DeliveryIssue)
	case "transformationIssue":
		return json.Marshal(i.TransformationIssue)
	}
}

type IssueVisitor interface {
	VisitDeliveryIssue(*DeliveryIssue) error
	VisitTransformationIssue(*TransformationIssue) error
}

func (i *Issue) Accept(visitor IssueVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "deliveryIssue":
		return visitor.VisitDeliveryIssue(i.DeliveryIssue)
	case "transformationIssue":
		return visitor.VisitTransformationIssue(i.TransformationIssue)
	}
}

type IssueCount struct {
	// Number of issues
	Count int `json:"count"`
}

// Issue status
type IssueStatus uint

const (
	IssueStatusOpened IssueStatus = iota + 1
	IssueStatusIgnored
	IssueStatusAcknowledged
	IssueStatusResolved
)

func (i IssueStatus) String() string {
	switch i {
	default:
		return strconv.Itoa(int(i))
	case IssueStatusOpened:
		return "OPENED"
	case IssueStatusIgnored:
		return "IGNORED"
	case IssueStatusAcknowledged:
		return "ACKNOWLEDGED"
	case IssueStatusResolved:
		return "RESOLVED"
	}
}

func (i IssueStatus) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", i.String())), nil
}

func (i *IssueStatus) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "OPENED":
		value := IssueStatusOpened
		*i = value
	case "IGNORED":
		value := IssueStatusIgnored
		*i = value
	case "ACKNOWLEDGED":
		value := IssueStatusAcknowledged
		*i = value
	case "RESOLVED":
		value := IssueStatusResolved
		*i = value
	}
	return nil
}

type IssueTrigger struct {
	// ID of the issue trigger
	Id string `json:"id"`
	// ID of the workspace
	TeamId *string `json:"team_id,omitempty"`
	// Optional unique name to use as reference when using the API
	Name     *string                `json:"name,omitempty"`
	Type     IssueType              `json:"type,omitempty"`
	Configs  *IssueTriggerReference `json:"configs,omitempty"`
	Channels *IssueTriggerChannels  `json:"channels,omitempty"`
	// ISO timestamp for when the issue trigger was disabled
	DisabledAt *time.Time `json:"disabled_at,omitempty"`
	// ISO timestamp for when the issue trigger was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// ISO timestamp for when the issue trigger was created
	CreatedAt time.Time `json:"created_at"`
	// ISO timestamp for when the issue trigger was deleted
	DeletedAt *time.Time `json:"deleted_at,omitempty"`
}

// Configurations for a 'Backpressure' issue trigger
type IssueTriggerBackpressureConfigs struct {
	Delay IssueTriggerBackpressureDelay `json:"delay"`
	// A pattern to match on the destination name or array of destination IDs. Use `*` as wildcard.
	Destinations *IssueTriggerBackpressureConfigsDestinations `json:"destinations,omitempty"`
}

// A pattern to match on the destination name or array of destination IDs. Use `*` as wildcard.
type IssueTriggerBackpressureConfigsDestinations struct {
	typeName   string
	String     string
	StringList []string
}

func NewIssueTriggerBackpressureConfigsDestinationsFromString(value string) *IssueTriggerBackpressureConfigsDestinations {
	return &IssueTriggerBackpressureConfigsDestinations{typeName: "string", String: value}
}

func NewIssueTriggerBackpressureConfigsDestinationsFromStringList(value []string) *IssueTriggerBackpressureConfigsDestinations {
	return &IssueTriggerBackpressureConfigsDestinations{typeName: "stringList", StringList: value}
}

func (i *IssueTriggerBackpressureConfigsDestinations) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		i.typeName = "stringList"
		i.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerBackpressureConfigsDestinations) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "stringList":
		return json.Marshal(i.StringList)
	}
}

type IssueTriggerBackpressureConfigsDestinationsVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (i *IssueTriggerBackpressureConfigsDestinations) Accept(visitor IssueTriggerBackpressureConfigsDestinationsVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "stringList":
		return visitor.VisitStringList(i.StringList)
	}
}

// The minimum delay (backpressure) to open the issue for min of 1 minute (60000) and max of 1 day (86400000)
type IssueTriggerBackpressureDelay = int

// Notification channels object for the specific channel type
type IssueTriggerChannels struct {
	Slack    *IssueTriggerSlackChannel       `json:"slack,omitempty"`
	Opsgenie *IssueTriggerIntegrationChannel `json:"opsgenie,omitempty"`
	Email    *IssueTriggerEmailChannel       `json:"email,omitempty"`
}

// Configurations for a 'delivery' issue trigger
type IssueTriggerDeliveryConfigs struct {
	Strategy IssueTriggerStrategy `json:"strategy,omitempty"`
	// A pattern to match on the connection name or array of connection IDs. Use `*` as wildcard.
	Connections *IssueTriggerDeliveryConfigsConnections `json:"connections,omitempty"`
}

// A pattern to match on the connection name or array of connection IDs. Use `*` as wildcard.
type IssueTriggerDeliveryConfigsConnections struct {
	typeName   string
	String     string
	StringList []string
}

func NewIssueTriggerDeliveryConfigsConnectionsFromString(value string) *IssueTriggerDeliveryConfigsConnections {
	return &IssueTriggerDeliveryConfigsConnections{typeName: "string", String: value}
}

func NewIssueTriggerDeliveryConfigsConnectionsFromStringList(value []string) *IssueTriggerDeliveryConfigsConnections {
	return &IssueTriggerDeliveryConfigsConnections{typeName: "stringList", StringList: value}
}

func (i *IssueTriggerDeliveryConfigsConnections) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		i.typeName = "stringList"
		i.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerDeliveryConfigsConnections) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "stringList":
		return json.Marshal(i.StringList)
	}
}

type IssueTriggerDeliveryConfigsConnectionsVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (i *IssueTriggerDeliveryConfigsConnections) Accept(visitor IssueTriggerDeliveryConfigsConnectionsVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "stringList":
		return visitor.VisitStringList(i.StringList)
	}
}

// Email channel for an issue trigger
type IssueTriggerEmailChannel struct {
}

// Integration channel for an issue trigger
type IssueTriggerIntegrationChannel struct {
}

type IssueTriggerPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*IssueTrigger `json:"models,omitempty"`
}

// Configuration object for the specific issue type selected
type IssueTriggerReference struct {
	typeName                          string
	IssueTriggerDeliveryConfigs       *IssueTriggerDeliveryConfigs
	IssueTriggerTransformationConfigs *IssueTriggerTransformationConfigs
	IssueTriggerBackpressureConfigs   *IssueTriggerBackpressureConfigs
}

func NewIssueTriggerReferenceFromIssueTriggerDeliveryConfigs(value *IssueTriggerDeliveryConfigs) *IssueTriggerReference {
	return &IssueTriggerReference{typeName: "issueTriggerDeliveryConfigs", IssueTriggerDeliveryConfigs: value}
}

func NewIssueTriggerReferenceFromIssueTriggerTransformationConfigs(value *IssueTriggerTransformationConfigs) *IssueTriggerReference {
	return &IssueTriggerReference{typeName: "issueTriggerTransformationConfigs", IssueTriggerTransformationConfigs: value}
}

func NewIssueTriggerReferenceFromIssueTriggerBackpressureConfigs(value *IssueTriggerBackpressureConfigs) *IssueTriggerReference {
	return &IssueTriggerReference{typeName: "issueTriggerBackpressureConfigs", IssueTriggerBackpressureConfigs: value}
}

func (i *IssueTriggerReference) UnmarshalJSON(data []byte) error {
	valueIssueTriggerDeliveryConfigs := new(IssueTriggerDeliveryConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerDeliveryConfigs); err == nil {
		i.typeName = "issueTriggerDeliveryConfigs"
		i.IssueTriggerDeliveryConfigs = valueIssueTriggerDeliveryConfigs
		return nil
	}
	valueIssueTriggerTransformationConfigs := new(IssueTriggerTransformationConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerTransformationConfigs); err == nil {
		i.typeName = "issueTriggerTransformationConfigs"
		i.IssueTriggerTransformationConfigs = valueIssueTriggerTransformationConfigs
		return nil
	}
	valueIssueTriggerBackpressureConfigs := new(IssueTriggerBackpressureConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerBackpressureConfigs); err == nil {
		i.typeName = "issueTriggerBackpressureConfigs"
		i.IssueTriggerBackpressureConfigs = valueIssueTriggerBackpressureConfigs
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerReference) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueTriggerDeliveryConfigs":
		return json.Marshal(i.IssueTriggerDeliveryConfigs)
	case "issueTriggerTransformationConfigs":
		return json.Marshal(i.IssueTriggerTransformationConfigs)
	case "issueTriggerBackpressureConfigs":
		return json.Marshal(i.IssueTriggerBackpressureConfigs)
	}
}

type IssueTriggerReferenceVisitor interface {
	VisitIssueTriggerDeliveryConfigs(*IssueTriggerDeliveryConfigs) error
	VisitIssueTriggerTransformationConfigs(*IssueTriggerTransformationConfigs) error
	VisitIssueTriggerBackpressureConfigs(*IssueTriggerBackpressureConfigs) error
}

func (i *IssueTriggerReference) Accept(visitor IssueTriggerReferenceVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueTriggerDeliveryConfigs":
		return visitor.VisitIssueTriggerDeliveryConfigs(i.IssueTriggerDeliveryConfigs)
	case "issueTriggerTransformationConfigs":
		return visitor.VisitIssueTriggerTransformationConfigs(i.IssueTriggerTransformationConfigs)
	case "issueTriggerBackpressureConfigs":
		return visitor.VisitIssueTriggerBackpressureConfigs(i.IssueTriggerBackpressureConfigs)
	}
}

// Slack channel for an issue trigger
type IssueTriggerSlackChannel struct {
	// Channel name
	ChannelName string `json:"channel_name"`
}

// The strategy uses to open the issue
type IssueTriggerStrategy uint

const (
	IssueTriggerStrategyFirstAttempt IssueTriggerStrategy = iota + 1
	IssueTriggerStrategyFinalAttempt
)

func (i IssueTriggerStrategy) String() string {
	switch i {
	default:
		return strconv.Itoa(int(i))
	case IssueTriggerStrategyFirstAttempt:
		return "first_attempt"
	case IssueTriggerStrategyFinalAttempt:
		return "final_attempt"
	}
}

func (i IssueTriggerStrategy) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", i.String())), nil
}

func (i *IssueTriggerStrategy) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "first_attempt":
		value := IssueTriggerStrategyFirstAttempt
		*i = value
	case "final_attempt":
		value := IssueTriggerStrategyFinalAttempt
		*i = value
	}
	return nil
}

// Configurations for a 'Transformation' issue trigger
type IssueTriggerTransformationConfigs struct {
	LogLevel TransformationExecutionLogLevel `json:"log_level,omitempty"`
	// A pattern to match on the transformation name or array of transformation IDs. Use `*` as wildcard.
	Transformations *IssueTriggerTransformationConfigsTransformations `json:"transformations,omitempty"`
}

// A pattern to match on the transformation name or array of transformation IDs. Use `*` as wildcard.
type IssueTriggerTransformationConfigsTransformations struct {
	typeName   string
	String     string
	StringList []string
}

func NewIssueTriggerTransformationConfigsTransformationsFromString(value string) *IssueTriggerTransformationConfigsTransformations {
	return &IssueTriggerTransformationConfigsTransformations{typeName: "string", String: value}
}

func NewIssueTriggerTransformationConfigsTransformationsFromStringList(value []string) *IssueTriggerTransformationConfigsTransformations {
	return &IssueTriggerTransformationConfigsTransformations{typeName: "stringList", StringList: value}
}

func (i *IssueTriggerTransformationConfigsTransformations) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		i.typeName = "stringList"
		i.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerTransformationConfigsTransformations) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "stringList":
		return json.Marshal(i.StringList)
	}
}

type IssueTriggerTransformationConfigsTransformationsVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (i *IssueTriggerTransformationConfigsTransformations) Accept(visitor IssueTriggerTransformationConfigsTransformationsVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "stringList":
		return visitor.VisitStringList(i.StringList)
	}
}

// Issue type
type IssueType uint

const (
	IssueTypeDelivery IssueType = iota + 1
	IssueTypeTransformation
	IssueTypeBackpressure
)

func (i IssueType) String() string {
	switch i {
	default:
		return strconv.Itoa(int(i))
	case IssueTypeDelivery:
		return "delivery"
	case IssueTypeTransformation:
		return "transformation"
	case IssueTypeBackpressure:
		return "backpressure"
	}
}

func (i IssueType) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", i.String())), nil
}

func (i *IssueType) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "delivery":
		value := IssueTypeDelivery
		*i = value
	case "transformation":
		value := IssueTypeTransformation
		*i = value
	case "backpressure":
		value := IssueTypeBackpressure
		*i = value
	}
	return nil
}

type IssueWithData struct {
	typeName                    string
	DeliveryIssueWithData       *DeliveryIssueWithData
	TransformationIssueWithData *TransformationIssueWithData
}

func NewIssueWithDataFromDeliveryIssueWithData(value *DeliveryIssueWithData) *IssueWithData {
	return &IssueWithData{typeName: "deliveryIssueWithData", DeliveryIssueWithData: value}
}

func NewIssueWithDataFromTransformationIssueWithData(value *TransformationIssueWithData) *IssueWithData {
	return &IssueWithData{typeName: "transformationIssueWithData", TransformationIssueWithData: value}
}

func (i *IssueWithData) UnmarshalJSON(data []byte) error {
	valueDeliveryIssueWithData := new(DeliveryIssueWithData)
	if err := json.Unmarshal(data, &valueDeliveryIssueWithData); err == nil {
		i.typeName = "deliveryIssueWithData"
		i.DeliveryIssueWithData = valueDeliveryIssueWithData
		return nil
	}
	valueTransformationIssueWithData := new(TransformationIssueWithData)
	if err := json.Unmarshal(data, &valueTransformationIssueWithData); err == nil {
		i.typeName = "transformationIssueWithData"
		i.TransformationIssueWithData = valueTransformationIssueWithData
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueWithData) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "deliveryIssueWithData":
		return json.Marshal(i.DeliveryIssueWithData)
	case "transformationIssueWithData":
		return json.Marshal(i.TransformationIssueWithData)
	}
}

type IssueWithDataVisitor interface {
	VisitDeliveryIssueWithData(*DeliveryIssueWithData) error
	VisitTransformationIssueWithData(*TransformationIssueWithData) error
}

func (i *IssueWithData) Accept(visitor IssueWithDataVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "deliveryIssueWithData":
		return visitor.VisitDeliveryIssueWithData(i.DeliveryIssueWithData)
	case "transformationIssueWithData":
		return visitor.VisitTransformationIssueWithData(i.TransformationIssueWithData)
	}
}

type IssueWithDataPaginatedResult struct {
	Pagination *SeekPagination  `json:"pagination,omitempty"`
	Count      *int             `json:"count,omitempty"`
	Models     []*IssueWithData `json:"models,omitempty"`
}

type ListCustomDomainSchema = []*ListCustomDomainSchemaItem

type ListCustomDomainSchemaItem struct {
	Id                    *string                                          `json:"id,omitempty"`
	Hostname              *string                                          `json:"hostname,omitempty"`
	Status                *string                                          `json:"status,omitempty"`
	Ssl                   *ListCustomDomainSchemaItemSsl                   `json:"ssl,omitempty"`
	VerificationErrors    []string                                         `json:"verification_errors,omitempty"`
	OwnershipVerification *ListCustomDomainSchemaItemOwnershipVerification `json:"ownership_verification,omitempty"`
	CreatedAt             *string                                          `json:"created_at,omitempty"`
}

type ListCustomDomainSchemaItemOwnershipVerification struct {
	Type  *string `json:"type,omitempty"`
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

type ListCustomDomainSchemaItemSsl struct {
	Id                   *string                                                  `json:"id,omitempty"`
	Type                 *string                                                  `json:"type,omitempty"`
	Method               *string                                                  `json:"method,omitempty"`
	Status               *string                                                  `json:"status,omitempty"`
	TxtName              *string                                                  `json:"txt_name,omitempty"`
	TxtValue             *string                                                  `json:"txt_value,omitempty"`
	ValidationRecords    []*ListCustomDomainSchemaItemSslValidationRecordsItem    `json:"validation_records,omitempty"`
	DcvDelegationRecords []*ListCustomDomainSchemaItemSslDcvDelegationRecordsItem `json:"dcv_delegation_records,omitempty"`
	Settings             *ListCustomDomainSchemaItemSslSettings                   `json:"settings,omitempty"`
	BundleMethod         *string                                                  `json:"bundle_method,omitempty"`
	Wildcard             *bool                                                    `json:"wildcard,omitempty"`
	CertificateAuthority *string                                                  `json:"certificate_authority,omitempty"`
}

type ListCustomDomainSchemaItemSslDcvDelegationRecordsItem struct {
	Cname       *string `json:"cname,omitempty"`
	CnameTarget *string `json:"cname_target,omitempty"`
}

type ListCustomDomainSchemaItemSslSettings struct {
	MinTlsVersion *string `json:"min_tls_version,omitempty"`
}

type ListCustomDomainSchemaItemSslValidationRecordsItem struct {
	Status   *string `json:"status,omitempty"`
	TxtName  *string `json:"txt_name,omitempty"`
	TxtValue *string `json:"txt_value,omitempty"`
}

type Mailgun struct {
	Configs *MailgunConfigs `json:"configs,omitempty"`
	type_   string
}

func (m *Mailgun) Type() string {
	return m.type_
}

func (m *Mailgun) UnmarshalJSON(data []byte) error {
	type unmarshaler Mailgun
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Mailgun(value)
	m.type_ = "mailgun"
	return nil
}

func (m *Mailgun) MarshalJSON() ([]byte, error) {
	type embed Mailgun
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*m),
		Type:  "mailgun",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Mailgun. Only included if the ?include=verification.configs query param is present
type MailgunConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type OrderByDirection uint

const (
	OrderByDirectionasc OrderByDirection = iota + 1
	OrderByDirectiondesc
	OrderByDirectionASC
	OrderByDirectionDESC
)

func (o OrderByDirection) String() string {
	switch o {
	default:
		return strconv.Itoa(int(o))
	case OrderByDirectionasc:
		return "asc"
	case OrderByDirectiondesc:
		return "desc"
	case OrderByDirectionASC:
		return "ASC"
	case OrderByDirectionDESC:
		return "DESC"
	}
}

func (o OrderByDirection) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", o.String())), nil
}

func (o *OrderByDirection) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "asc":
		value := OrderByDirectionasc
		*o = value
	case "desc":
		value := OrderByDirectiondesc
		*o = value
	case "ASC":
		value := OrderByDirectionASC
		*o = value
	case "DESC":
		value := OrderByDirectionDESC
		*o = value
	}
	return nil
}

type Oura struct {
	Configs *OuraConfigs `json:"configs,omitempty"`
	type_   string
}

func (o *Oura) Type() string {
	return o.type_
}

func (o *Oura) UnmarshalJSON(data []byte) error {
	type unmarshaler Oura
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = Oura(value)
	o.type_ = "oura"
	return nil
}

func (o *Oura) MarshalJSON() ([]byte, error) {
	type embed Oura
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*o),
		Type:  "oura",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Oura. Only included if the ?include=verification.configs query param is present
type OuraConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type Pipedrive struct {
	Configs *PipedriveConfigs `json:"configs,omitempty"`
	type_   string
}

func (p *Pipedrive) Type() string {
	return p.type_
}

func (p *Pipedrive) UnmarshalJSON(data []byte) error {
	type unmarshaler Pipedrive
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Pipedrive(value)
	p.type_ = "pipedrive"
	return nil
}

func (p *Pipedrive) MarshalJSON() ([]byte, error) {
	type embed Pipedrive
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*p),
		Type:  "pipedrive",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Pipedrive. Only included if the ?include=verification.configs query param is present
type PipedriveConfigs struct {
	Name     string `json:"name"`
	Password string `json:"password"`
}

type Postmark struct {
	Configs *PostmarkConfigs `json:"configs,omitempty"`
	type_   string
}

func (p *Postmark) Type() string {
	return p.type_
}

func (p *Postmark) UnmarshalJSON(data []byte) error {
	type unmarshaler Postmark
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Postmark(value)
	p.type_ = "postmark"
	return nil
}

func (p *Postmark) MarshalJSON() ([]byte, error) {
	type embed Postmark
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*p),
		Type:  "postmark",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Postmark. Only included if the ?include=verification.configs query param is present
type PostmarkConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type PropertyFinder struct {
	Configs *PropertyFinderConfigs `json:"configs,omitempty"`
	type_   string
}

func (p *PropertyFinder) Type() string {
	return p.type_
}

func (p *PropertyFinder) UnmarshalJSON(data []byte) error {
	type unmarshaler PropertyFinder
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PropertyFinder(value)
	p.type_ = "property-finder"
	return nil
}

func (p *PropertyFinder) MarshalJSON() ([]byte, error) {
	type embed PropertyFinder
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*p),
		Type:  "property-finder",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Property Finder. Only included if the ?include=verification.configs query param is present
type PropertyFinderConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type RawBody struct {
	Body string `json:"body"`
}

type Recharge struct {
	Configs *RechargeConfigs `json:"configs,omitempty"`
	type_   string
}

func (r *Recharge) Type() string {
	return r.type_
}

func (r *Recharge) UnmarshalJSON(data []byte) error {
	type unmarshaler Recharge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Recharge(value)
	r.type_ = "recharge"
	return nil
}

func (r *Recharge) MarshalJSON() ([]byte, error) {
	type embed Recharge
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
		Type:  "recharge",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Recharge. Only included if the ?include=verification.configs query param is present
type RechargeConfigs struct {
	WebhookSecretKey string                  `json:"webhook_secret_key"`
	Algorithm        HmacAlgorithms          `json:"algorithm,omitempty"`
	HeaderKey        string                  `json:"header_key"`
	Encoding         RechargeConfigsEncoding `json:"encoding,omitempty"`
}

type RechargeConfigsEncoding uint

const (
	RechargeConfigsEncodingBase64 RechargeConfigsEncoding = iota + 1
	RechargeConfigsEncodingHex
)

func (r RechargeConfigsEncoding) String() string {
	switch r {
	default:
		return strconv.Itoa(int(r))
	case RechargeConfigsEncodingBase64:
		return "base64"
	case RechargeConfigsEncodingHex:
		return "hex"
	}
}

func (r RechargeConfigsEncoding) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", r.String())), nil
}

func (r *RechargeConfigsEncoding) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "base64":
		value := RechargeConfigsEncodingBase64
		*r = value
	case "hex":
		value := RechargeConfigsEncodingHex
		*r = value
	}
	return nil
}

type Request struct {
	// ID of the request
	Id string `json:"id"`
	// ID of the workspace
	TeamId string `json:"team_id"`
	// Whether or not the request was verified when received
	Verified *bool `json:"verified,omitempty"`
	// ID of the request data
	OriginalEventDataId *string               `json:"original_event_data_id,omitempty"`
	RejectionCause      RequestRejectionCause `json:"rejection_cause,omitempty"`
	// The priority attributed to the request when received
	IngestPriority *RequestIngestPriority `json:"ingest_priority,omitempty"`
	// The time the request was originally received
	IngestedAt *time.Time `json:"ingested_at,omitempty"`
	// ID of the associated source
	SourceId string `json:"source_id"`
	// The count of events created from this request (CLI events not included)
	EventsCount *int `json:"events_count,omitempty"`
	// The count of CLI events created from this request
	CliEventsCount *int `json:"cli_events_count,omitempty"`
	IgnoredCount   *int `json:"ignored_count,omitempty"`
	// Date the event was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the event was created
	CreatedAt time.Time       `json:"created_at"`
	Data      *ShortEventData `json:"data,omitempty"`
}

// The priority attributed to the request when received
type RequestIngestPriority uint

const (
	RequestIngestPriorityNormal RequestIngestPriority = iota + 1
	RequestIngestPriorityLow
)

func (r RequestIngestPriority) String() string {
	switch r {
	default:
		return strconv.Itoa(int(r))
	case RequestIngestPriorityNormal:
		return "NORMAL"
	case RequestIngestPriorityLow:
		return "LOW"
	}
}

func (r RequestIngestPriority) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", r.String())), nil
}

func (r *RequestIngestPriority) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "NORMAL":
		value := RequestIngestPriorityNormal
		*r = value
	case "LOW":
		value := RequestIngestPriorityLow
		*r = value
	}
	return nil
}

type RequestPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Request      `json:"models,omitempty"`
}

type RequestRejectionCause uint

const (
	RequestRejectionCauseSourceArchived RequestRejectionCause = iota + 1
	RequestRejectionCauseNoWebhook
	RequestRejectionCauseVerificationFailed
	RequestRejectionCauseUnsupportedHttpMethod
	RequestRejectionCauseUnsupportedContentType
	RequestRejectionCauseUnparsableJson
	RequestRejectionCausePayloadTooLarge
	RequestRejectionCauseIngestionFatal
	RequestRejectionCauseUnknown
)

func (r RequestRejectionCause) String() string {
	switch r {
	default:
		return strconv.Itoa(int(r))
	case RequestRejectionCauseSourceArchived:
		return "SOURCE_ARCHIVED"
	case RequestRejectionCauseNoWebhook:
		return "NO_WEBHOOK"
	case RequestRejectionCauseVerificationFailed:
		return "VERIFICATION_FAILED"
	case RequestRejectionCauseUnsupportedHttpMethod:
		return "UNSUPPORTED_HTTP_METHOD"
	case RequestRejectionCauseUnsupportedContentType:
		return "UNSUPPORTED_CONTENT_TYPE"
	case RequestRejectionCauseUnparsableJson:
		return "UNPARSABLE_JSON"
	case RequestRejectionCausePayloadTooLarge:
		return "PAYLOAD_TOO_LARGE"
	case RequestRejectionCauseIngestionFatal:
		return "INGESTION_FATAL"
	case RequestRejectionCauseUnknown:
		return "UNKNOWN"
	}
}

func (r RequestRejectionCause) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", r.String())), nil
}

func (r *RequestRejectionCause) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "SOURCE_ARCHIVED":
		value := RequestRejectionCauseSourceArchived
		*r = value
	case "NO_WEBHOOK":
		value := RequestRejectionCauseNoWebhook
		*r = value
	case "VERIFICATION_FAILED":
		value := RequestRejectionCauseVerificationFailed
		*r = value
	case "UNSUPPORTED_HTTP_METHOD":
		value := RequestRejectionCauseUnsupportedHttpMethod
		*r = value
	case "UNSUPPORTED_CONTENT_TYPE":
		value := RequestRejectionCauseUnsupportedContentType
		*r = value
	case "UNPARSABLE_JSON":
		value := RequestRejectionCauseUnparsableJson
		*r = value
	case "PAYLOAD_TOO_LARGE":
		value := RequestRejectionCausePayloadTooLarge
		*r = value
	case "INGESTION_FATAL":
		value := RequestRejectionCauseIngestionFatal
		*r = value
	case "UNKNOWN":
		value := RequestRejectionCauseUnknown
		*r = value
	}
	return nil
}

type RetriedEvent struct {
	Event   *Event        `json:"event,omitempty"`
	Attempt *EventAttempt `json:"attempt,omitempty"`
}

type RetryRequest struct {
	Request *Request `json:"request,omitempty"`
	Events  []*Event `json:"events,omitempty"`
}

type RetryRule struct {
	Strategy RetryStrategy `json:"strategy,omitempty"`
	// Time in MS between each retry
	Interval *int `json:"interval,omitempty"`
	// Maximum number of retries to attempt
	Count *int `json:"count,omitempty"`
	type_ string
}

func (r *RetryRule) Type() string {
	return r.type_
}

func (r *RetryRule) UnmarshalJSON(data []byte) error {
	type unmarshaler RetryRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetryRule(value)
	r.type_ = "retry"
	return nil
}

func (r *RetryRule) MarshalJSON() ([]byte, error) {
	type embed RetryRule
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
		Type:  "retry",
	}
	return json.Marshal(marshaler)
}

// Algorithm to use when calculating delay between retries
type RetryStrategy uint

const (
	RetryStrategyLinear RetryStrategy = iota + 1
	RetryStrategyExponential
)

func (r RetryStrategy) String() string {
	switch r {
	default:
		return strconv.Itoa(int(r))
	case RetryStrategyLinear:
		return "linear"
	case RetryStrategyExponential:
		return "exponential"
	}
}

func (r RetryStrategy) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", r.String())), nil
}

func (r *RetryStrategy) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "linear":
		value := RetryStrategyLinear
		*r = value
	case "exponential":
		value := RetryStrategyExponential
		*r = value
	}
	return nil
}

type Rule struct {
	typeName      string
	RetryRule     *RetryRule
	FilterRule    *FilterRule
	TransformRule *TransformRule
	DelayRule     *DelayRule
}

func NewRuleFromRetryRule(value *RetryRule) *Rule {
	return &Rule{typeName: "retryRule", RetryRule: value}
}

func NewRuleFromFilterRule(value *FilterRule) *Rule {
	return &Rule{typeName: "filterRule", FilterRule: value}
}

func NewRuleFromTransformRule(value *TransformRule) *Rule {
	return &Rule{typeName: "transformRule", TransformRule: value}
}

func NewRuleFromDelayRule(value *DelayRule) *Rule {
	return &Rule{typeName: "delayRule", DelayRule: value}
}

func (r *Rule) UnmarshalJSON(data []byte) error {
	valueRetryRule := new(RetryRule)
	if err := json.Unmarshal(data, &valueRetryRule); err == nil {
		r.typeName = "retryRule"
		r.RetryRule = valueRetryRule
		return nil
	}
	valueFilterRule := new(FilterRule)
	if err := json.Unmarshal(data, &valueFilterRule); err == nil {
		r.typeName = "filterRule"
		r.FilterRule = valueFilterRule
		return nil
	}
	valueTransformRule := new(TransformRule)
	if err := json.Unmarshal(data, &valueTransformRule); err == nil {
		r.typeName = "transformRule"
		r.TransformRule = valueTransformRule
		return nil
	}
	valueDelayRule := new(DelayRule)
	if err := json.Unmarshal(data, &valueDelayRule); err == nil {
		r.typeName = "delayRule"
		r.DelayRule = valueDelayRule
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r Rule) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "retryRule":
		return json.Marshal(r.RetryRule)
	case "filterRule":
		return json.Marshal(r.FilterRule)
	case "transformRule":
		return json.Marshal(r.TransformRule)
	case "delayRule":
		return json.Marshal(r.DelayRule)
	}
}

type RuleVisitor interface {
	VisitRetryRule(*RetryRule) error
	VisitFilterRule(*FilterRule) error
	VisitTransformRule(*TransformRule) error
	VisitDelayRule(*DelayRule) error
}

func (r *Rule) Accept(visitor RuleVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "retryRule":
		return visitor.VisitRetryRule(r.RetryRule)
	case "filterRule":
		return visitor.VisitFilterRule(r.FilterRule)
	case "transformRule":
		return visitor.VisitTransformRule(r.TransformRule)
	case "delayRule":
		return visitor.VisitDelayRule(r.DelayRule)
	}
}

type SeekPagination struct {
	OrderBy *SeekPaginationOrderBy `json:"order_by,omitempty"`
	Dir     *SeekPaginationDir     `json:"dir,omitempty"`
	Limit   *int                   `json:"limit,omitempty"`
	Prev    *string                `json:"prev,omitempty"`
	Next    *string                `json:"next,omitempty"`
}

type SeekPaginationDir struct {
	typeName             string
	OrderByDirection     OrderByDirection
	OrderByDirectionList []OrderByDirection
}

func NewSeekPaginationDirFromOrderByDirection(value OrderByDirection) *SeekPaginationDir {
	return &SeekPaginationDir{typeName: "orderByDirection", OrderByDirection: value}
}

func NewSeekPaginationDirFromOrderByDirectionList(value []OrderByDirection) *SeekPaginationDir {
	return &SeekPaginationDir{typeName: "orderByDirectionList", OrderByDirectionList: value}
}

func (s *SeekPaginationDir) UnmarshalJSON(data []byte) error {
	var valueOrderByDirection OrderByDirection
	if err := json.Unmarshal(data, &valueOrderByDirection); err == nil {
		s.typeName = "orderByDirection"
		s.OrderByDirection = valueOrderByDirection
		return nil
	}
	var valueOrderByDirectionList []OrderByDirection
	if err := json.Unmarshal(data, &valueOrderByDirectionList); err == nil {
		s.typeName = "orderByDirectionList"
		s.OrderByDirectionList = valueOrderByDirectionList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SeekPaginationDir) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "orderByDirection":
		return json.Marshal(s.OrderByDirection)
	case "orderByDirectionList":
		return json.Marshal(s.OrderByDirectionList)
	}
}

type SeekPaginationDirVisitor interface {
	VisitOrderByDirection(OrderByDirection) error
	VisitOrderByDirectionList([]OrderByDirection) error
}

func (s *SeekPaginationDir) Accept(visitor SeekPaginationDirVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "orderByDirection":
		return visitor.VisitOrderByDirection(s.OrderByDirection)
	case "orderByDirectionList":
		return visitor.VisitOrderByDirectionList(s.OrderByDirectionList)
	}
}

type SeekPaginationOrderBy struct {
	typeName   string
	String     string
	StringList []string
}

func NewSeekPaginationOrderByFromString(value string) *SeekPaginationOrderBy {
	return &SeekPaginationOrderBy{typeName: "string", String: value}
}

func NewSeekPaginationOrderByFromStringList(value []string) *SeekPaginationOrderBy {
	return &SeekPaginationOrderBy{typeName: "stringList", StringList: value}
}

func (s *SeekPaginationOrderBy) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typeName = "string"
		s.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		s.typeName = "stringList"
		s.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SeekPaginationOrderBy) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return json.Marshal(s.String)
	case "stringList":
		return json.Marshal(s.StringList)
	}
}

type SeekPaginationOrderByVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (s *SeekPaginationOrderBy) Accept(visitor SeekPaginationOrderByVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return visitor.VisitString(s.String)
	case "stringList":
		return visitor.VisitStringList(s.StringList)
	}
}

type SendGrid struct {
	Configs *SendGridConfigs `json:"configs,omitempty"`
	type_   string
}

func (s *SendGrid) Type() string {
	return s.type_
}

func (s *SendGrid) UnmarshalJSON(data []byte) error {
	type unmarshaler SendGrid
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SendGrid(value)
	s.type_ = "sendgrid"
	return nil
}

func (s *SendGrid) MarshalJSON() ([]byte, error) {
	type embed SendGrid
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "sendgrid",
	}
	return json.Marshal(marshaler)
}

// The verification configs for SendGrid. Only included if the ?include=verification.configs query param is present
type SendGridConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type Shopify struct {
	Configs *ShopifyConfigs `json:"configs,omitempty"`
	type_   string
}

func (s *Shopify) Type() string {
	return s.type_
}

func (s *Shopify) UnmarshalJSON(data []byte) error {
	type unmarshaler Shopify
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Shopify(value)
	s.type_ = "shopify"
	return nil
}

func (s *Shopify) MarshalJSON() ([]byte, error) {
	type embed Shopify
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "shopify",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Shopify. Only included if the ?include=verification.configs query param is present
type ShopifyConfigs struct {
	WebhookSecretKey string                         `json:"webhook_secret_key"`
	RateLimitPeriod  *ShopifyConfigsRateLimitPeriod `json:"rate_limit_period,omitempty"`
	RateLimit        *float64                       `json:"rate_limit,omitempty"`
	ApiKey           *string                        `json:"api_key,omitempty"`
	ApiSecret        *string                        `json:"api_secret,omitempty"`
	Shop             *string                        `json:"shop,omitempty"`
}

type ShopifyConfigsRateLimitPeriod uint

const (
	ShopifyConfigsRateLimitPeriodMinute ShopifyConfigsRateLimitPeriod = iota + 1
	ShopifyConfigsRateLimitPeriodSecond
)

func (s ShopifyConfigsRateLimitPeriod) String() string {
	switch s {
	default:
		return strconv.Itoa(int(s))
	case ShopifyConfigsRateLimitPeriodMinute:
		return "minute"
	case ShopifyConfigsRateLimitPeriodSecond:
		return "second"
	}
}

func (s ShopifyConfigsRateLimitPeriod) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", s.String())), nil
}

func (s *ShopifyConfigsRateLimitPeriod) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "minute":
		value := ShopifyConfigsRateLimitPeriodMinute
		*s = value
	case "second":
		value := ShopifyConfigsRateLimitPeriodSecond
		*s = value
	}
	return nil
}

type ShopifyIntegrationConfigs struct {
	WebhookSecretKey string                                    `json:"webhook_secret_key"`
	RateLimitPeriod  *ShopifyIntegrationConfigsRateLimitPeriod `json:"rate_limit_period,omitempty"`
	RateLimit        *float64                                  `json:"rate_limit,omitempty"`
	ApiKey           *string                                   `json:"api_key,omitempty"`
	ApiSecret        *string                                   `json:"api_secret,omitempty"`
	Shop             *string                                   `json:"shop,omitempty"`
}

type ShopifyIntegrationConfigsRateLimitPeriod uint

const (
	ShopifyIntegrationConfigsRateLimitPeriodMinute ShopifyIntegrationConfigsRateLimitPeriod = iota + 1
	ShopifyIntegrationConfigsRateLimitPeriodSecond
)

func (s ShopifyIntegrationConfigsRateLimitPeriod) String() string {
	switch s {
	default:
		return strconv.Itoa(int(s))
	case ShopifyIntegrationConfigsRateLimitPeriodMinute:
		return "minute"
	case ShopifyIntegrationConfigsRateLimitPeriodSecond:
		return "second"
	}
}

func (s ShopifyIntegrationConfigsRateLimitPeriod) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", s.String())), nil
}

func (s *ShopifyIntegrationConfigsRateLimitPeriod) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "minute":
		value := ShopifyIntegrationConfigsRateLimitPeriodMinute
		*s = value
	case "second":
		value := ShopifyIntegrationConfigsRateLimitPeriodSecond
		*s = value
	}
	return nil
}

// Request data
type ShortEventData struct {
	// Request path
	Path string `json:"path"`
	// Raw query param string
	Query *string `json:"query,omitempty"`
	// JSON representation of query params
	ParsedQuery *ShortEventDataParsedQuery `json:"parsed_query,omitempty"`
	// JSON representation of the headers
	Headers *ShortEventDataHeaders `json:"headers,omitempty"`
	// JSON or string representation of the body
	Body *ShortEventDataBody `json:"body,omitempty"`
	// Whether the payload is considered large payload and not searchable
	IsLargePayload *bool `json:"is_large_payload,omitempty"`
}

// JSON or string representation of the body
type ShortEventDataBody struct {
	typeName              string
	String                string
	ShortEventDataBodyOne *ShortEventDataBodyOne
	UnknownList           []any
}

func NewShortEventDataBodyFromString(value string) *ShortEventDataBody {
	return &ShortEventDataBody{typeName: "string", String: value}
}

func NewShortEventDataBodyFromShortEventDataBodyOne(value *ShortEventDataBodyOne) *ShortEventDataBody {
	return &ShortEventDataBody{typeName: "shortEventDataBodyOne", ShortEventDataBodyOne: value}
}

func NewShortEventDataBodyFromUnknownList(value []any) *ShortEventDataBody {
	return &ShortEventDataBody{typeName: "unknownList", UnknownList: value}
}

func (s *ShortEventDataBody) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typeName = "string"
		s.String = valueString
		return nil
	}
	valueShortEventDataBodyOne := new(ShortEventDataBodyOne)
	if err := json.Unmarshal(data, &valueShortEventDataBodyOne); err == nil {
		s.typeName = "shortEventDataBodyOne"
		s.ShortEventDataBodyOne = valueShortEventDataBodyOne
		return nil
	}
	var valueUnknownList []any
	if err := json.Unmarshal(data, &valueUnknownList); err == nil {
		s.typeName = "unknownList"
		s.UnknownList = valueUnknownList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ShortEventDataBody) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return json.Marshal(s.String)
	case "shortEventDataBodyOne":
		return json.Marshal(s.ShortEventDataBodyOne)
	case "unknownList":
		return json.Marshal(s.UnknownList)
	}
}

type ShortEventDataBodyVisitor interface {
	VisitString(string) error
	VisitShortEventDataBodyOne(*ShortEventDataBodyOne) error
	VisitUnknownList([]any) error
}

func (s *ShortEventDataBody) Accept(visitor ShortEventDataBodyVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return visitor.VisitString(s.String)
	case "shortEventDataBodyOne":
		return visitor.VisitShortEventDataBodyOne(s.ShortEventDataBodyOne)
	case "unknownList":
		return visitor.VisitUnknownList(s.UnknownList)
	}
}

type ShortEventDataBodyOne struct {
}

// JSON representation of the headers
type ShortEventDataHeaders struct {
	typeName                string
	String                  string
	StringStringOptionalMap map[string]*string
}

func NewShortEventDataHeadersFromString(value string) *ShortEventDataHeaders {
	return &ShortEventDataHeaders{typeName: "string", String: value}
}

func NewShortEventDataHeadersFromStringStringOptionalMap(value map[string]*string) *ShortEventDataHeaders {
	return &ShortEventDataHeaders{typeName: "stringStringOptionalMap", StringStringOptionalMap: value}
}

func (s *ShortEventDataHeaders) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typeName = "string"
		s.String = valueString
		return nil
	}
	var valueStringStringOptionalMap map[string]*string
	if err := json.Unmarshal(data, &valueStringStringOptionalMap); err == nil {
		s.typeName = "stringStringOptionalMap"
		s.StringStringOptionalMap = valueStringStringOptionalMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ShortEventDataHeaders) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return json.Marshal(s.String)
	case "stringStringOptionalMap":
		return json.Marshal(s.StringStringOptionalMap)
	}
}

type ShortEventDataHeadersVisitor interface {
	VisitString(string) error
	VisitStringStringOptionalMap(map[string]*string) error
}

func (s *ShortEventDataHeaders) Accept(visitor ShortEventDataHeadersVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return visitor.VisitString(s.String)
	case "stringStringOptionalMap":
		return visitor.VisitStringStringOptionalMap(s.StringStringOptionalMap)
	}
}

// JSON representation of query params
type ShortEventDataParsedQuery struct {
	typeName                     string
	StringOptional               *string
	ShortEventDataParsedQueryOne *ShortEventDataParsedQueryOne
}

func NewShortEventDataParsedQueryFromStringOptional(value *string) *ShortEventDataParsedQuery {
	return &ShortEventDataParsedQuery{typeName: "stringOptional", StringOptional: value}
}

func NewShortEventDataParsedQueryFromShortEventDataParsedQueryOne(value *ShortEventDataParsedQueryOne) *ShortEventDataParsedQuery {
	return &ShortEventDataParsedQuery{typeName: "shortEventDataParsedQueryOne", ShortEventDataParsedQueryOne: value}
}

func (s *ShortEventDataParsedQuery) UnmarshalJSON(data []byte) error {
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		s.typeName = "stringOptional"
		s.StringOptional = valueStringOptional
		return nil
	}
	valueShortEventDataParsedQueryOne := new(ShortEventDataParsedQueryOne)
	if err := json.Unmarshal(data, &valueShortEventDataParsedQueryOne); err == nil {
		s.typeName = "shortEventDataParsedQueryOne"
		s.ShortEventDataParsedQueryOne = valueShortEventDataParsedQueryOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ShortEventDataParsedQuery) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "stringOptional":
		return json.Marshal(s.StringOptional)
	case "shortEventDataParsedQueryOne":
		return json.Marshal(s.ShortEventDataParsedQueryOne)
	}
}

type ShortEventDataParsedQueryVisitor interface {
	VisitStringOptional(*string) error
	VisitShortEventDataParsedQueryOne(*ShortEventDataParsedQueryOne) error
}

func (s *ShortEventDataParsedQuery) Accept(visitor ShortEventDataParsedQueryVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "stringOptional":
		return visitor.VisitStringOptional(s.StringOptional)
	case "shortEventDataParsedQueryOne":
		return visitor.VisitShortEventDataParsedQueryOne(s.ShortEventDataParsedQueryOne)
	}
}

type ShortEventDataParsedQueryOne struct {
}

// Associated [Source](#source-object) object
type Source struct {
	// ID of the source
	Id string `json:"id"`
	// Name for the source
	Name string `json:"name"`
	// Description of the source
	Description *string `json:"description,omitempty"`
	// ID of the workspace
	TeamId string `json:"team_id"`
	// A unique URL that must be supplied to your webhook's provider
	Url                string                   `json:"url"`
	Verification       *VerificationConfig      `json:"verification,omitempty"`
	AllowedHttpMethods *SourceAllowedHttpMethod `json:"allowed_http_methods,omitempty"`
	CustomResponse     *SourceCustomResponse    `json:"custom_response,omitempty"`
	// Date the source was archived
	ArchivedAt *time.Time `json:"archived_at,omitempty"`
	// Date the source was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the source was created
	CreatedAt time.Time `json:"created_at"`
}

// List of allowed HTTP methods. Defaults to PUT, POST, PATCH, DELETE.
type SourceAllowedHttpMethod = []SourceAllowedHttpMethodItem

type SourceAllowedHttpMethodItem uint

const (
	SourceAllowedHttpMethodItemGet SourceAllowedHttpMethodItem = iota + 1
	SourceAllowedHttpMethodItemPost
	SourceAllowedHttpMethodItemPut
	SourceAllowedHttpMethodItemPatch
	SourceAllowedHttpMethodItemDelete
)

func (s SourceAllowedHttpMethodItem) String() string {
	switch s {
	default:
		return strconv.Itoa(int(s))
	case SourceAllowedHttpMethodItemGet:
		return "GET"
	case SourceAllowedHttpMethodItemPost:
		return "POST"
	case SourceAllowedHttpMethodItemPut:
		return "PUT"
	case SourceAllowedHttpMethodItemPatch:
		return "PATCH"
	case SourceAllowedHttpMethodItemDelete:
		return "DELETE"
	}
}

func (s SourceAllowedHttpMethodItem) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", s.String())), nil
}

func (s *SourceAllowedHttpMethodItem) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "GET":
		value := SourceAllowedHttpMethodItemGet
		*s = value
	case "POST":
		value := SourceAllowedHttpMethodItemPost
		*s = value
	case "PUT":
		value := SourceAllowedHttpMethodItemPut
		*s = value
	case "PATCH":
		value := SourceAllowedHttpMethodItemPatch
		*s = value
	case "DELETE":
		value := SourceAllowedHttpMethodItemDelete
		*s = value
	}
	return nil
}

// Custom response object
type SourceCustomResponse struct {
	ContentType SourceCustomResponseContentType `json:"content_type,omitempty"`
	// Body of the custom response <span style="white-space: nowrap">`<= 1000 characters`</span>
	Body string `json:"body"`
}

// Content type of the custom response
type SourceCustomResponseContentType uint

const (
	SourceCustomResponseContentTypeJson SourceCustomResponseContentType = iota + 1
	SourceCustomResponseContentTypeText
	SourceCustomResponseContentTypeXml
)

func (s SourceCustomResponseContentType) String() string {
	switch s {
	default:
		return strconv.Itoa(int(s))
	case SourceCustomResponseContentTypeJson:
		return "json"
	case SourceCustomResponseContentTypeText:
		return "text"
	case SourceCustomResponseContentTypeXml:
		return "xml"
	}
}

func (s SourceCustomResponseContentType) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", s.String())), nil
}

func (s *SourceCustomResponseContentType) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "json":
		value := SourceCustomResponseContentTypeJson
		*s = value
	case "text":
		value := SourceCustomResponseContentTypeText
		*s = value
	case "xml":
		value := SourceCustomResponseContentTypeXml
		*s = value
	}
	return nil
}

type SourcePaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Source       `json:"models,omitempty"`
}

type Stripe struct {
	Configs *StripeConfigs `json:"configs,omitempty"`
	type_   string
}

func (s *Stripe) Type() string {
	return s.type_
}

func (s *Stripe) UnmarshalJSON(data []byte) error {
	type unmarshaler Stripe
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Stripe(value)
	s.type_ = "stripe"
	return nil
}

func (s *Stripe) MarshalJSON() ([]byte, error) {
	type embed Stripe
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "stripe",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Stripe. Only included if the ?include=verification.configs query param is present
type StripeConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type Svix struct {
	Configs *SvixConfigs `json:"configs,omitempty"`
	type_   string
}

func (s *Svix) Type() string {
	return s.type_
}

func (s *Svix) UnmarshalJSON(data []byte) error {
	type unmarshaler Svix
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Svix(value)
	s.type_ = "svix"
	return nil
}

func (s *Svix) MarshalJSON() ([]byte, error) {
	type embed Svix
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "svix",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Svix. Only included if the ?include=verification.configs query param is present
type SvixConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type Synctera struct {
	Configs *SyncteraConfigs `json:"configs,omitempty"`
	type_   string
}

func (s *Synctera) Type() string {
	return s.type_
}

func (s *Synctera) UnmarshalJSON(data []byte) error {
	type unmarshaler Synctera
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Synctera(value)
	s.type_ = "synctera"
	return nil
}

func (s *Synctera) MarshalJSON() ([]byte, error) {
	type embed Synctera
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*s),
		Type:  "synctera",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Synctera. Only included if the ?include=verification.configs query param is present
type SyncteraConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

// Key-value environment variables to be passed to the transformation
type TestTransformationRequestEnv struct {
}

// Request input to use for the transformation execution
type TestTransformationRequestRequest struct {
	// Headers of the request
	Headers map[string]string `json:"headers,omitempty"`
	// Body of the request
	Body *TestTransformationRequestRequestBody `json:"body,omitempty"`
	// Path of the request
	Path *string `json:"path,omitempty"`
	// String representation of the query params of the request
	Query *string `json:"query,omitempty"`
	// JSON representation of the query params
	ParsedQuery *TestTransformationRequestRequestParsedQuery `json:"parsed_query,omitempty"`
}

// Body of the request
type TestTransformationRequestRequestBody struct {
	typeName                                 string
	TestTransformationRequestRequestBodyZero *TestTransformationRequestRequestBodyZero
	String                                   string
}

func NewTestTransformationRequestRequestBodyFromTestTransformationRequestRequestBodyZero(value *TestTransformationRequestRequestBodyZero) *TestTransformationRequestRequestBody {
	return &TestTransformationRequestRequestBody{typeName: "testTransformationRequestRequestBodyZero", TestTransformationRequestRequestBodyZero: value}
}

func NewTestTransformationRequestRequestBodyFromString(value string) *TestTransformationRequestRequestBody {
	return &TestTransformationRequestRequestBody{typeName: "string", String: value}
}

func (t *TestTransformationRequestRequestBody) UnmarshalJSON(data []byte) error {
	valueTestTransformationRequestRequestBodyZero := new(TestTransformationRequestRequestBodyZero)
	if err := json.Unmarshal(data, &valueTestTransformationRequestRequestBodyZero); err == nil {
		t.typeName = "testTransformationRequestRequestBodyZero"
		t.TestTransformationRequestRequestBodyZero = valueTestTransformationRequestRequestBodyZero
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TestTransformationRequestRequestBody) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "testTransformationRequestRequestBodyZero":
		return json.Marshal(t.TestTransformationRequestRequestBodyZero)
	case "string":
		return json.Marshal(t.String)
	}
}

type TestTransformationRequestRequestBodyVisitor interface {
	VisitTestTransformationRequestRequestBodyZero(*TestTransformationRequestRequestBodyZero) error
	VisitString(string) error
}

func (t *TestTransformationRequestRequestBody) Accept(visitor TestTransformationRequestRequestBodyVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "testTransformationRequestRequestBodyZero":
		return visitor.VisitTestTransformationRequestRequestBodyZero(t.TestTransformationRequestRequestBodyZero)
	case "string":
		return visitor.VisitString(t.String)
	}
}

type TestTransformationRequestRequestBodyZero struct {
}

// JSON representation of the query params
type TestTransformationRequestRequestParsedQuery struct {
}

type ThreeDEye struct {
	Configs *ThreeDEyeConfigs `json:"configs,omitempty"`
	type_   string
}

func (t *ThreeDEye) Type() string {
	return t.type_
}

func (t *ThreeDEye) UnmarshalJSON(data []byte) error {
	type unmarshaler ThreeDEye
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ThreeDEye(value)
	t.type_ = "three_d_eye"
	return nil
}

func (t *ThreeDEye) MarshalJSON() ([]byte, error) {
	type embed ThreeDEye
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "three_d_eye",
	}
	return json.Marshal(marshaler)
}

// The verification configs for 3dEye. Only included if the ?include=verification.configs query param is present
type ThreeDEyeConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type ToggleWebhookNotifications struct {
	Enabled  bool          `json:"enabled"`
	Topics   []TopicsValue `json:"topics,omitempty"`
	SourceId string        `json:"source_id"`
}

// Supported topics
type TopicsValue uint

const (
	TopicsValueIssueOpened TopicsValue = iota + 1
	TopicsValueIssueUpdated
	TopicsValueDeprecatedAttemptFailed
	TopicsValueEventSuccessful
)

func (t TopicsValue) String() string {
	switch t {
	default:
		return strconv.Itoa(int(t))
	case TopicsValueIssueOpened:
		return "issue.opened"
	case TopicsValueIssueUpdated:
		return "issue.updated"
	case TopicsValueDeprecatedAttemptFailed:
		return "deprecated.attempt-failed"
	case TopicsValueEventSuccessful:
		return "event.successful"
	}
}

func (t TopicsValue) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", t.String())), nil
}

func (t *TopicsValue) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "issue.opened":
		value := TopicsValueIssueOpened
		*t = value
	case "issue.updated":
		value := TopicsValueIssueUpdated
		*t = value
	case "deprecated.attempt-failed":
		value := TopicsValueDeprecatedAttemptFailed
		*t = value
	case "event.successful":
		value := TopicsValueEventSuccessful
		*t = value
	}
	return nil
}

type TransformFull struct {
	// ID of the attached transformation object. Optional input, always set once the rule is defined
	TransformationId *string `json:"transformation_id,omitempty"`
	// You can optionally define a new transformation while creating a transform rule
	Transformation *TransformFullTransformation `json:"transformation,omitempty"`
	type_          string
}

func (t *TransformFull) Type() string {
	return t.type_
}

func (t *TransformFull) UnmarshalJSON(data []byte) error {
	type unmarshaler TransformFull
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransformFull(value)
	t.type_ = "transform"
	return nil
}

func (t *TransformFull) MarshalJSON() ([]byte, error) {
	type embed TransformFull
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "transform",
	}
	return json.Marshal(marshaler)
}

// You can optionally define a new transformation while creating a transform rule
type TransformFullTransformation struct {
	// The unique name of the transformation
	Name string `json:"name"`
	// A string representation of your JavaScript (ES6) code to run
	Code string `json:"code"`
	// A key-value object of environment variables to encrypt and expose to your transformation code
	Env map[string]*string `json:"env,omitempty"`
}

type TransformReference struct {
	// ID of the attached transformation object. Optional input, always set once the rule is defined
	TransformationId string `json:"transformation_id"`
	type_            string
}

func (t *TransformReference) Type() string {
	return t.type_
}

func (t *TransformReference) UnmarshalJSON(data []byte) error {
	type unmarshaler TransformReference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransformReference(value)
	t.type_ = "transform"
	return nil
}

func (t *TransformReference) MarshalJSON() ([]byte, error) {
	type embed TransformReference
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "transform",
	}
	return json.Marshal(marshaler)
}

type TransformRule struct {
	typeName           string
	TransformReference *TransformReference
	TransformFull      *TransformFull
}

func NewTransformRuleFromTransformReference(value *TransformReference) *TransformRule {
	return &TransformRule{typeName: "transformReference", TransformReference: value}
}

func NewTransformRuleFromTransformFull(value *TransformFull) *TransformRule {
	return &TransformRule{typeName: "transformFull", TransformFull: value}
}

func (t *TransformRule) UnmarshalJSON(data []byte) error {
	valueTransformReference := new(TransformReference)
	if err := json.Unmarshal(data, &valueTransformReference); err == nil {
		t.typeName = "transformReference"
		t.TransformReference = valueTransformReference
		return nil
	}
	valueTransformFull := new(TransformFull)
	if err := json.Unmarshal(data, &valueTransformFull); err == nil {
		t.typeName = "transformFull"
		t.TransformFull = valueTransformFull
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransformRule) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transformReference":
		return json.Marshal(t.TransformReference)
	case "transformFull":
		return json.Marshal(t.TransformFull)
	}
}

type TransformRuleVisitor interface {
	VisitTransformReference(*TransformReference) error
	VisitTransformFull(*TransformFull) error
}

func (t *TransformRule) Accept(visitor TransformRuleVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transformReference":
		return visitor.VisitTransformReference(t.TransformReference)
	case "transformFull":
		return visitor.VisitTransformFull(t.TransformFull)
	}
}

type Transformation struct {
	// ID of the transformation
	Id string `json:"id"`
	// ID of the workspace
	TeamId string `json:"team_id"`
	// A unique, human-friendly name for the transformation
	Name string `json:"name"`
	// JavaScript code to be executed
	Code         string  `json:"code"`
	EncryptedEnv *string `json:"encrypted_env,omitempty"`
	Iv           *string `json:"iv,omitempty"`
	// Key-value environment variables to be passed to the transformation
	Env map[string]*string `json:"env,omitempty"`
	// Date the transformation was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the transformation was created
	CreatedAt time.Time `json:"created_at"`
}

type TransformationExecution struct {
	Id                     string                          `json:"id"`
	TransformedEventDataId string                          `json:"transformed_event_data_id"`
	OriginalEventDataId    string                          `json:"original_event_data_id"`
	TransformationId       string                          `json:"transformation_id"`
	TeamId                 string                          `json:"team_id"`
	WebhookId              string                          `json:"webhook_id"`
	LogLevel               TransformationExecutionLogLevel `json:"log_level,omitempty"`
	Logs                   []*ConsoleLine                  `json:"logs,omitempty"`
	UpdatedAt              time.Time                       `json:"updated_at"`
	CreatedAt              time.Time                       `json:"created_at"`
	OriginalEventData      *ShortEventData                 `json:"original_event_data,omitempty"`
	TransformedEventData   *ShortEventData                 `json:"transformed_event_data,omitempty"`
	IssueId                *string                         `json:"issue_id,omitempty"`
}

// The minimum log level to open the issue on
type TransformationExecutionLogLevel uint

const (
	TransformationExecutionLogLevelDebug TransformationExecutionLogLevel = iota + 1
	TransformationExecutionLogLevelInfo
	TransformationExecutionLogLevelWarn
	TransformationExecutionLogLevelError
	TransformationExecutionLogLevelFatal
)

func (t TransformationExecutionLogLevel) String() string {
	switch t {
	default:
		return strconv.Itoa(int(t))
	case TransformationExecutionLogLevelDebug:
		return "debug"
	case TransformationExecutionLogLevelInfo:
		return "info"
	case TransformationExecutionLogLevelWarn:
		return "warn"
	case TransformationExecutionLogLevelError:
		return "error"
	case TransformationExecutionLogLevelFatal:
		return "fatal"
	}
}

func (t TransformationExecutionLogLevel) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", t.String())), nil
}

func (t *TransformationExecutionLogLevel) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "debug":
		value := TransformationExecutionLogLevelDebug
		*t = value
	case "info":
		value := TransformationExecutionLogLevelInfo
		*t = value
	case "warn":
		value := TransformationExecutionLogLevelWarn
		*t = value
	case "error":
		value := TransformationExecutionLogLevelError
		*t = value
	case "fatal":
		value := TransformationExecutionLogLevelFatal
		*t = value
	}
	return nil
}

type TransformationExecutionPaginatedResult struct {
	Pagination *SeekPagination            `json:"pagination,omitempty"`
	Count      *int                       `json:"count,omitempty"`
	Models     []*TransformationExecution `json:"models,omitempty"`
}

type TransformationExecutorOutput struct {
	RequestId        *string                              `json:"request_id,omitempty"`
	TransformationId *string                              `json:"transformation_id,omitempty"`
	ExecutionId      *string                              `json:"execution_id,omitempty"`
	LogLevel         TransformationExecutionLogLevel      `json:"log_level,omitempty"`
	Request          *TransformationExecutorOutputRequest `json:"request,omitempty"`
	Console          []*ConsoleLine                       `json:"console,omitempty"`
}

type TransformationExecutorOutputRequest struct {
	Headers     *TransformationExecutorOutputRequestHeaders     `json:"headers,omitempty"`
	Path        string                                          `json:"path"`
	Query       *TransformationExecutorOutputRequestQuery       `json:"query,omitempty"`
	ParsedQuery *TransformationExecutorOutputRequestParsedQuery `json:"parsed_query,omitempty"`
	Body        *TransformationExecutorOutputRequestBody        `json:"body,omitempty"`
}

type TransformationExecutorOutputRequestBody struct {
	typeName                                   string
	StringOptional                             *string
	TransformationExecutorOutputRequestBodyOne *TransformationExecutorOutputRequestBodyOne
}

func NewTransformationExecutorOutputRequestBodyFromStringOptional(value *string) *TransformationExecutorOutputRequestBody {
	return &TransformationExecutorOutputRequestBody{typeName: "stringOptional", StringOptional: value}
}

func NewTransformationExecutorOutputRequestBodyFromTransformationExecutorOutputRequestBodyOne(value *TransformationExecutorOutputRequestBodyOne) *TransformationExecutorOutputRequestBody {
	return &TransformationExecutorOutputRequestBody{typeName: "transformationExecutorOutputRequestBodyOne", TransformationExecutorOutputRequestBodyOne: value}
}

func (t *TransformationExecutorOutputRequestBody) UnmarshalJSON(data []byte) error {
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		t.typeName = "stringOptional"
		t.StringOptional = valueStringOptional
		return nil
	}
	valueTransformationExecutorOutputRequestBodyOne := new(TransformationExecutorOutputRequestBodyOne)
	if err := json.Unmarshal(data, &valueTransformationExecutorOutputRequestBodyOne); err == nil {
		t.typeName = "transformationExecutorOutputRequestBodyOne"
		t.TransformationExecutorOutputRequestBodyOne = valueTransformationExecutorOutputRequestBodyOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransformationExecutorOutputRequestBody) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "stringOptional":
		return json.Marshal(t.StringOptional)
	case "transformationExecutorOutputRequestBodyOne":
		return json.Marshal(t.TransformationExecutorOutputRequestBodyOne)
	}
}

type TransformationExecutorOutputRequestBodyVisitor interface {
	VisitStringOptional(*string) error
	VisitTransformationExecutorOutputRequestBodyOne(*TransformationExecutorOutputRequestBodyOne) error
}

func (t *TransformationExecutorOutputRequestBody) Accept(visitor TransformationExecutorOutputRequestBodyVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "stringOptional":
		return visitor.VisitStringOptional(t.StringOptional)
	case "transformationExecutorOutputRequestBodyOne":
		return visitor.VisitTransformationExecutorOutputRequestBodyOne(t.TransformationExecutorOutputRequestBodyOne)
	}
}

type TransformationExecutorOutputRequestBodyOne struct {
}

type TransformationExecutorOutputRequestHeaders struct {
	typeName         string
	String           string
	StringUnknownMap map[string]any
}

func NewTransformationExecutorOutputRequestHeadersFromString(value string) *TransformationExecutorOutputRequestHeaders {
	return &TransformationExecutorOutputRequestHeaders{typeName: "string", String: value}
}

func NewTransformationExecutorOutputRequestHeadersFromStringUnknownMap(value map[string]any) *TransformationExecutorOutputRequestHeaders {
	return &TransformationExecutorOutputRequestHeaders{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func (t *TransformationExecutorOutputRequestHeaders) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	var valueStringUnknownMap map[string]any
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		t.typeName = "stringUnknownMap"
		t.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransformationExecutorOutputRequestHeaders) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "stringUnknownMap":
		return json.Marshal(t.StringUnknownMap)
	}
}

type TransformationExecutorOutputRequestHeadersVisitor interface {
	VisitString(string) error
	VisitStringUnknownMap(map[string]any) error
}

func (t *TransformationExecutorOutputRequestHeaders) Accept(visitor TransformationExecutorOutputRequestHeadersVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(t.StringUnknownMap)
	}
}

type TransformationExecutorOutputRequestParsedQuery struct {
	typeName                                          string
	StringOptional                                    *string
	TransformationExecutorOutputRequestParsedQueryOne *TransformationExecutorOutputRequestParsedQueryOne
}

func NewTransformationExecutorOutputRequestParsedQueryFromStringOptional(value *string) *TransformationExecutorOutputRequestParsedQuery {
	return &TransformationExecutorOutputRequestParsedQuery{typeName: "stringOptional", StringOptional: value}
}

func NewTransformationExecutorOutputRequestParsedQueryFromTransformationExecutorOutputRequestParsedQueryOne(value *TransformationExecutorOutputRequestParsedQueryOne) *TransformationExecutorOutputRequestParsedQuery {
	return &TransformationExecutorOutputRequestParsedQuery{typeName: "transformationExecutorOutputRequestParsedQueryOne", TransformationExecutorOutputRequestParsedQueryOne: value}
}

func (t *TransformationExecutorOutputRequestParsedQuery) UnmarshalJSON(data []byte) error {
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		t.typeName = "stringOptional"
		t.StringOptional = valueStringOptional
		return nil
	}
	valueTransformationExecutorOutputRequestParsedQueryOne := new(TransformationExecutorOutputRequestParsedQueryOne)
	if err := json.Unmarshal(data, &valueTransformationExecutorOutputRequestParsedQueryOne); err == nil {
		t.typeName = "transformationExecutorOutputRequestParsedQueryOne"
		t.TransformationExecutorOutputRequestParsedQueryOne = valueTransformationExecutorOutputRequestParsedQueryOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransformationExecutorOutputRequestParsedQuery) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "stringOptional":
		return json.Marshal(t.StringOptional)
	case "transformationExecutorOutputRequestParsedQueryOne":
		return json.Marshal(t.TransformationExecutorOutputRequestParsedQueryOne)
	}
}

type TransformationExecutorOutputRequestParsedQueryVisitor interface {
	VisitStringOptional(*string) error
	VisitTransformationExecutorOutputRequestParsedQueryOne(*TransformationExecutorOutputRequestParsedQueryOne) error
}

func (t *TransformationExecutorOutputRequestParsedQuery) Accept(visitor TransformationExecutorOutputRequestParsedQueryVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "stringOptional":
		return visitor.VisitStringOptional(t.StringOptional)
	case "transformationExecutorOutputRequestParsedQueryOne":
		return visitor.VisitTransformationExecutorOutputRequestParsedQueryOne(t.TransformationExecutorOutputRequestParsedQueryOne)
	}
}

type TransformationExecutorOutputRequestParsedQueryOne struct {
}

type TransformationExecutorOutputRequestQuery struct {
	typeName                                             string
	TransformationExecutorOutputRequestQueryZeroOptional *TransformationExecutorOutputRequestQueryZero
	String                                               string
}

func NewTransformationExecutorOutputRequestQueryFromTransformationExecutorOutputRequestQueryZeroOptional(value *TransformationExecutorOutputRequestQueryZero) *TransformationExecutorOutputRequestQuery {
	return &TransformationExecutorOutputRequestQuery{typeName: "transformationExecutorOutputRequestQueryZeroOptional", TransformationExecutorOutputRequestQueryZeroOptional: value}
}

func NewTransformationExecutorOutputRequestQueryFromString(value string) *TransformationExecutorOutputRequestQuery {
	return &TransformationExecutorOutputRequestQuery{typeName: "string", String: value}
}

func (t *TransformationExecutorOutputRequestQuery) UnmarshalJSON(data []byte) error {
	var valueTransformationExecutorOutputRequestQueryZeroOptional *TransformationExecutorOutputRequestQueryZero
	if err := json.Unmarshal(data, &valueTransformationExecutorOutputRequestQueryZeroOptional); err == nil {
		t.typeName = "transformationExecutorOutputRequestQueryZeroOptional"
		t.TransformationExecutorOutputRequestQueryZeroOptional = valueTransformationExecutorOutputRequestQueryZeroOptional
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransformationExecutorOutputRequestQuery) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transformationExecutorOutputRequestQueryZeroOptional":
		return json.Marshal(t.TransformationExecutorOutputRequestQueryZeroOptional)
	case "string":
		return json.Marshal(t.String)
	}
}

type TransformationExecutorOutputRequestQueryVisitor interface {
	VisitTransformationExecutorOutputRequestQueryZeroOptional(*TransformationExecutorOutputRequestQueryZero) error
	VisitString(string) error
}

func (t *TransformationExecutorOutputRequestQuery) Accept(visitor TransformationExecutorOutputRequestQueryVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transformationExecutorOutputRequestQueryZeroOptional":
		return visitor.VisitTransformationExecutorOutputRequestQueryZeroOptional(t.TransformationExecutorOutputRequestQueryZeroOptional)
	case "string":
		return visitor.VisitString(t.String)
	}
}

type TransformationExecutorOutputRequestQueryZero struct {
}

type TransformationFailedMeta struct {
	TransformationId string `json:"transformation_id"`
}

// Transformation issue
type TransformationIssue struct {
	// Issue ID
	Id string `json:"id"`
	// ID of the workspace
	TeamId string      `json:"team_id"`
	Status IssueStatus `json:"status,omitempty"`
	// ISO timestamp for when the issue was last opened
	OpenedAt time.Time `json:"opened_at"`
	// ISO timestamp for when the issue was first opened
	FirstSeenAt time.Time `json:"first_seen_at"`
	// ISO timestamp for when the issue last occured
	LastSeenAt time.Time `json:"last_seen_at"`
	// ID of the team member who last updated the issue status
	LastUpdatedBy *string `json:"last_updated_by,omitempty"`
	// ISO timestamp for when the issue was dismissed
	DismissedAt    *time.Time `json:"dismissed_at,omitempty"`
	AutoResolvedAt *time.Time `json:"auto_resolved_at,omitempty"`
	MergedWith     *string    `json:"merged_with,omitempty"`
	// ISO timestamp for when the issue was last updated
	UpdatedAt string `json:"updated_at"`
	// ISO timestamp for when the issue was created
	CreatedAt       string                              `json:"created_at"`
	AggregationKeys *TransformationIssueAggregationKeys `json:"aggregation_keys,omitempty"`
	Reference       *TransformationIssueReference       `json:"reference,omitempty"`
	type_           string
}

func (t *TransformationIssue) Type() string {
	return t.type_
}

func (t *TransformationIssue) UnmarshalJSON(data []byte) error {
	type unmarshaler TransformationIssue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransformationIssue(value)
	t.type_ = "transformation"
	return nil
}

func (t *TransformationIssue) MarshalJSON() ([]byte, error) {
	type embed TransformationIssue
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "transformation",
	}
	return json.Marshal(marshaler)
}

// Keys used as the aggregation keys a 'transformation' type issue
type TransformationIssueAggregationKeys struct {
	TransformationId []string                        `json:"transformation_id,omitempty"`
	LogLevel         TransformationExecutionLogLevel `json:"log_level,omitempty"`
}

// Transformation issue data
type TransformationIssueData struct {
	TransformationExecution *TransformationExecution `json:"transformation_execution,omitempty"`
	TriggerAttempt          *EventAttempt            `json:"trigger_attempt,omitempty"`
}

// Reference to the event request transformation an issue is being created for.
type TransformationIssueReference struct {
	TransformationExecutionId string `json:"transformation_execution_id"`
	// Deprecated but still found on historical issues
	TriggerEventRequestTransformationId *string `json:"trigger_event_request_transformation_id,omitempty"`
}

// Transformation issue
type TransformationIssueWithData struct {
	// Issue ID
	Id string `json:"id"`
	// ID of the workspace
	TeamId string      `json:"team_id"`
	Status IssueStatus `json:"status,omitempty"`
	// ISO timestamp for when the issue was last opened
	OpenedAt time.Time `json:"opened_at"`
	// ISO timestamp for when the issue was first opened
	FirstSeenAt time.Time `json:"first_seen_at"`
	// ISO timestamp for when the issue last occured
	LastSeenAt time.Time `json:"last_seen_at"`
	// ID of the team member who last updated the issue status
	LastUpdatedBy *string `json:"last_updated_by,omitempty"`
	// ISO timestamp for when the issue was dismissed
	DismissedAt    *time.Time `json:"dismissed_at,omitempty"`
	AutoResolvedAt *time.Time `json:"auto_resolved_at,omitempty"`
	MergedWith     *string    `json:"merged_with,omitempty"`
	// ISO timestamp for when the issue was last updated
	UpdatedAt string `json:"updated_at"`
	// ISO timestamp for when the issue was created
	CreatedAt       string                              `json:"created_at"`
	AggregationKeys *TransformationIssueAggregationKeys `json:"aggregation_keys,omitempty"`
	Reference       *TransformationIssueReference       `json:"reference,omitempty"`
	Data            *TransformationIssueData            `json:"data,omitempty"`
	type_           string
}

func (t *TransformationIssueWithData) Type() string {
	return t.type_
}

func (t *TransformationIssueWithData) UnmarshalJSON(data []byte) error {
	type unmarshaler TransformationIssueWithData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransformationIssueWithData(value)
	t.type_ = "transformation"
	return nil
}

func (t *TransformationIssueWithData) MarshalJSON() ([]byte, error) {
	type embed TransformationIssueWithData
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "transformation",
	}
	return json.Marshal(marshaler)
}

type TransformationPaginatedResult struct {
	Pagination *SeekPagination   `json:"pagination,omitempty"`
	Count      *int              `json:"count,omitempty"`
	Models     []*Transformation `json:"models,omitempty"`
}

// Bookmark target
type TriggerBookmarkRequestTarget uint

const (
	TriggerBookmarkRequestTargetHttp TriggerBookmarkRequestTarget = iota + 1
	TriggerBookmarkRequestTargetCli
)

func (t TriggerBookmarkRequestTarget) String() string {
	switch t {
	default:
		return strconv.Itoa(int(t))
	case TriggerBookmarkRequestTargetHttp:
		return "http"
	case TriggerBookmarkRequestTargetCli:
		return "cli"
	}
}

func (t TriggerBookmarkRequestTarget) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", t.String())), nil
}

func (t *TriggerBookmarkRequestTarget) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "http":
		value := TriggerBookmarkRequestTargetHttp
		*t = value
	case "cli":
		value := TriggerBookmarkRequestTargetCli
		*t = value
	}
	return nil
}

type Twitter struct {
	Configs *TwitterConfigs `json:"configs,omitempty"`
	type_   string
}

func (t *Twitter) Type() string {
	return t.type_
}

func (t *Twitter) UnmarshalJSON(data []byte) error {
	type unmarshaler Twitter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Twitter(value)
	t.type_ = "twitter"
	return nil
}

func (t *Twitter) MarshalJSON() ([]byte, error) {
	type embed Twitter
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "twitter",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Twitter. Only included if the ?include=verification.configs query param is present
type TwitterConfigs struct {
	ApiKey string `json:"api_key"`
}

type Typeform struct {
	Configs *TypeformConfigs `json:"configs,omitempty"`
	type_   string
}

func (t *Typeform) Type() string {
	return t.type_
}

func (t *Typeform) UnmarshalJSON(data []byte) error {
	type unmarshaler Typeform
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Typeform(value)
	t.type_ = "typeform"
	return nil
}

func (t *Typeform) MarshalJSON() ([]byte, error) {
	type embed Typeform
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "typeform",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Typeform. Only included if the ?include=verification.configs query param is present
type TypeformConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

// Period to rate limit attempts
type UpdateDestinationRequestRateLimitPeriod uint

const (
	UpdateDestinationRequestRateLimitPeriodSecond UpdateDestinationRequestRateLimitPeriod = iota + 1
	UpdateDestinationRequestRateLimitPeriodMinute
	UpdateDestinationRequestRateLimitPeriodHour
)

func (u UpdateDestinationRequestRateLimitPeriod) String() string {
	switch u {
	default:
		return strconv.Itoa(int(u))
	case UpdateDestinationRequestRateLimitPeriodSecond:
		return "second"
	case UpdateDestinationRequestRateLimitPeriodMinute:
		return "minute"
	case UpdateDestinationRequestRateLimitPeriodHour:
		return "hour"
	}
}

func (u UpdateDestinationRequestRateLimitPeriod) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", u.String())), nil
}

func (u *UpdateDestinationRequestRateLimitPeriod) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "second":
		value := UpdateDestinationRequestRateLimitPeriodSecond
		*u = value
	case "minute":
		value := UpdateDestinationRequestRateLimitPeriodMinute
		*u = value
	case "hour":
		value := UpdateDestinationRequestRateLimitPeriodHour
		*u = value
	}
	return nil
}

// Decrypted Key/Value object of the associated configuration for that provider
type UpdateIntegrationRequestConfigs struct {
	typeName                           string
	HmacIntegrationConfigs             *HmacIntegrationConfigs
	ApiKeyIntegrationConfigs           *ApiKeyIntegrationConfigs
	HandledApiKeyIntegrationConfigs    *HandledApiKeyIntegrationConfigs
	HandledHmacConfigs                 *HandledHmacConfigs
	BasicAuthIntegrationConfigs        *BasicAuthIntegrationConfigs
	ShopifyIntegrationConfigs          *ShopifyIntegrationConfigs
	UpdateIntegrationRequestConfigsSix *UpdateIntegrationRequestConfigsSix
}

func NewUpdateIntegrationRequestConfigsFromHmacIntegrationConfigs(value *HmacIntegrationConfigs) *UpdateIntegrationRequestConfigs {
	return &UpdateIntegrationRequestConfigs{typeName: "hmacIntegrationConfigs", HmacIntegrationConfigs: value}
}

func NewUpdateIntegrationRequestConfigsFromApiKeyIntegrationConfigs(value *ApiKeyIntegrationConfigs) *UpdateIntegrationRequestConfigs {
	return &UpdateIntegrationRequestConfigs{typeName: "apiKeyIntegrationConfigs", ApiKeyIntegrationConfigs: value}
}

func NewUpdateIntegrationRequestConfigsFromHandledApiKeyIntegrationConfigs(value *HandledApiKeyIntegrationConfigs) *UpdateIntegrationRequestConfigs {
	return &UpdateIntegrationRequestConfigs{typeName: "handledApiKeyIntegrationConfigs", HandledApiKeyIntegrationConfigs: value}
}

func NewUpdateIntegrationRequestConfigsFromHandledHmacConfigs(value *HandledHmacConfigs) *UpdateIntegrationRequestConfigs {
	return &UpdateIntegrationRequestConfigs{typeName: "handledHmacConfigs", HandledHmacConfigs: value}
}

func NewUpdateIntegrationRequestConfigsFromBasicAuthIntegrationConfigs(value *BasicAuthIntegrationConfigs) *UpdateIntegrationRequestConfigs {
	return &UpdateIntegrationRequestConfigs{typeName: "basicAuthIntegrationConfigs", BasicAuthIntegrationConfigs: value}
}

func NewUpdateIntegrationRequestConfigsFromShopifyIntegrationConfigs(value *ShopifyIntegrationConfigs) *UpdateIntegrationRequestConfigs {
	return &UpdateIntegrationRequestConfigs{typeName: "shopifyIntegrationConfigs", ShopifyIntegrationConfigs: value}
}

func NewUpdateIntegrationRequestConfigsFromUpdateIntegrationRequestConfigsSix(value *UpdateIntegrationRequestConfigsSix) *UpdateIntegrationRequestConfigs {
	return &UpdateIntegrationRequestConfigs{typeName: "updateIntegrationRequestConfigsSix", UpdateIntegrationRequestConfigsSix: value}
}

func (u *UpdateIntegrationRequestConfigs) UnmarshalJSON(data []byte) error {
	valueHmacIntegrationConfigs := new(HmacIntegrationConfigs)
	if err := json.Unmarshal(data, &valueHmacIntegrationConfigs); err == nil {
		u.typeName = "hmacIntegrationConfigs"
		u.HmacIntegrationConfigs = valueHmacIntegrationConfigs
		return nil
	}
	valueApiKeyIntegrationConfigs := new(ApiKeyIntegrationConfigs)
	if err := json.Unmarshal(data, &valueApiKeyIntegrationConfigs); err == nil {
		u.typeName = "apiKeyIntegrationConfigs"
		u.ApiKeyIntegrationConfigs = valueApiKeyIntegrationConfigs
		return nil
	}
	valueHandledApiKeyIntegrationConfigs := new(HandledApiKeyIntegrationConfigs)
	if err := json.Unmarshal(data, &valueHandledApiKeyIntegrationConfigs); err == nil {
		u.typeName = "handledApiKeyIntegrationConfigs"
		u.HandledApiKeyIntegrationConfigs = valueHandledApiKeyIntegrationConfigs
		return nil
	}
	valueHandledHmacConfigs := new(HandledHmacConfigs)
	if err := json.Unmarshal(data, &valueHandledHmacConfigs); err == nil {
		u.typeName = "handledHmacConfigs"
		u.HandledHmacConfigs = valueHandledHmacConfigs
		return nil
	}
	valueBasicAuthIntegrationConfigs := new(BasicAuthIntegrationConfigs)
	if err := json.Unmarshal(data, &valueBasicAuthIntegrationConfigs); err == nil {
		u.typeName = "basicAuthIntegrationConfigs"
		u.BasicAuthIntegrationConfigs = valueBasicAuthIntegrationConfigs
		return nil
	}
	valueShopifyIntegrationConfigs := new(ShopifyIntegrationConfigs)
	if err := json.Unmarshal(data, &valueShopifyIntegrationConfigs); err == nil {
		u.typeName = "shopifyIntegrationConfigs"
		u.ShopifyIntegrationConfigs = valueShopifyIntegrationConfigs
		return nil
	}
	valueUpdateIntegrationRequestConfigsSix := new(UpdateIntegrationRequestConfigsSix)
	if err := json.Unmarshal(data, &valueUpdateIntegrationRequestConfigsSix); err == nil {
		u.typeName = "updateIntegrationRequestConfigsSix"
		u.UpdateIntegrationRequestConfigsSix = valueUpdateIntegrationRequestConfigsSix
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateIntegrationRequestConfigs) MarshalJSON() ([]byte, error) {
	switch u.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "hmacIntegrationConfigs":
		return json.Marshal(u.HmacIntegrationConfigs)
	case "apiKeyIntegrationConfigs":
		return json.Marshal(u.ApiKeyIntegrationConfigs)
	case "handledApiKeyIntegrationConfigs":
		return json.Marshal(u.HandledApiKeyIntegrationConfigs)
	case "handledHmacConfigs":
		return json.Marshal(u.HandledHmacConfigs)
	case "basicAuthIntegrationConfigs":
		return json.Marshal(u.BasicAuthIntegrationConfigs)
	case "shopifyIntegrationConfigs":
		return json.Marshal(u.ShopifyIntegrationConfigs)
	case "updateIntegrationRequestConfigsSix":
		return json.Marshal(u.UpdateIntegrationRequestConfigsSix)
	}
}

type UpdateIntegrationRequestConfigsVisitor interface {
	VisitHmacIntegrationConfigs(*HmacIntegrationConfigs) error
	VisitApiKeyIntegrationConfigs(*ApiKeyIntegrationConfigs) error
	VisitHandledApiKeyIntegrationConfigs(*HandledApiKeyIntegrationConfigs) error
	VisitHandledHmacConfigs(*HandledHmacConfigs) error
	VisitBasicAuthIntegrationConfigs(*BasicAuthIntegrationConfigs) error
	VisitShopifyIntegrationConfigs(*ShopifyIntegrationConfigs) error
	VisitUpdateIntegrationRequestConfigsSix(*UpdateIntegrationRequestConfigsSix) error
}

func (u *UpdateIntegrationRequestConfigs) Accept(visitor UpdateIntegrationRequestConfigsVisitor) error {
	switch u.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "hmacIntegrationConfigs":
		return visitor.VisitHmacIntegrationConfigs(u.HmacIntegrationConfigs)
	case "apiKeyIntegrationConfigs":
		return visitor.VisitApiKeyIntegrationConfigs(u.ApiKeyIntegrationConfigs)
	case "handledApiKeyIntegrationConfigs":
		return visitor.VisitHandledApiKeyIntegrationConfigs(u.HandledApiKeyIntegrationConfigs)
	case "handledHmacConfigs":
		return visitor.VisitHandledHmacConfigs(u.HandledHmacConfigs)
	case "basicAuthIntegrationConfigs":
		return visitor.VisitBasicAuthIntegrationConfigs(u.BasicAuthIntegrationConfigs)
	case "shopifyIntegrationConfigs":
		return visitor.VisitShopifyIntegrationConfigs(u.ShopifyIntegrationConfigs)
	case "updateIntegrationRequestConfigsSix":
		return visitor.VisitUpdateIntegrationRequestConfigsSix(u.UpdateIntegrationRequestConfigsSix)
	}
}

type UpdateIntegrationRequestConfigsSix struct {
}

// New status
type UpdateIssueRequestStatus uint

const (
	UpdateIssueRequestStatusOpened UpdateIssueRequestStatus = iota + 1
	UpdateIssueRequestStatusIgnored
	UpdateIssueRequestStatusAcknowledged
	UpdateIssueRequestStatusResolved
)

func (u UpdateIssueRequestStatus) String() string {
	switch u {
	default:
		return strconv.Itoa(int(u))
	case UpdateIssueRequestStatusOpened:
		return "OPENED"
	case UpdateIssueRequestStatusIgnored:
		return "IGNORED"
	case UpdateIssueRequestStatusAcknowledged:
		return "ACKNOWLEDGED"
	case UpdateIssueRequestStatusResolved:
		return "RESOLVED"
	}
}

func (u UpdateIssueRequestStatus) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", u.String())), nil
}

func (u *UpdateIssueRequestStatus) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "OPENED":
		value := UpdateIssueRequestStatusOpened
		*u = value
	case "IGNORED":
		value := UpdateIssueRequestStatusIgnored
		*u = value
	case "ACKNOWLEDGED":
		value := UpdateIssueRequestStatusAcknowledged
		*u = value
	case "RESOLVED":
		value := UpdateIssueRequestStatusResolved
		*u = value
	}
	return nil
}

// Configuration object for the specific issue type selected
type UpdateIssueTriggerRequestConfigs struct {
	typeName                          string
	IssueTriggerDeliveryConfigs       *IssueTriggerDeliveryConfigs
	IssueTriggerTransformationConfigs *IssueTriggerTransformationConfigs
	IssueTriggerBackpressureConfigs   *IssueTriggerBackpressureConfigs
}

func NewUpdateIssueTriggerRequestConfigsFromIssueTriggerDeliveryConfigs(value *IssueTriggerDeliveryConfigs) *UpdateIssueTriggerRequestConfigs {
	return &UpdateIssueTriggerRequestConfigs{typeName: "issueTriggerDeliveryConfigs", IssueTriggerDeliveryConfigs: value}
}

func NewUpdateIssueTriggerRequestConfigsFromIssueTriggerTransformationConfigs(value *IssueTriggerTransformationConfigs) *UpdateIssueTriggerRequestConfigs {
	return &UpdateIssueTriggerRequestConfigs{typeName: "issueTriggerTransformationConfigs", IssueTriggerTransformationConfigs: value}
}

func NewUpdateIssueTriggerRequestConfigsFromIssueTriggerBackpressureConfigs(value *IssueTriggerBackpressureConfigs) *UpdateIssueTriggerRequestConfigs {
	return &UpdateIssueTriggerRequestConfigs{typeName: "issueTriggerBackpressureConfigs", IssueTriggerBackpressureConfigs: value}
}

func (u *UpdateIssueTriggerRequestConfigs) UnmarshalJSON(data []byte) error {
	valueIssueTriggerDeliveryConfigs := new(IssueTriggerDeliveryConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerDeliveryConfigs); err == nil {
		u.typeName = "issueTriggerDeliveryConfigs"
		u.IssueTriggerDeliveryConfigs = valueIssueTriggerDeliveryConfigs
		return nil
	}
	valueIssueTriggerTransformationConfigs := new(IssueTriggerTransformationConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerTransformationConfigs); err == nil {
		u.typeName = "issueTriggerTransformationConfigs"
		u.IssueTriggerTransformationConfigs = valueIssueTriggerTransformationConfigs
		return nil
	}
	valueIssueTriggerBackpressureConfigs := new(IssueTriggerBackpressureConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerBackpressureConfigs); err == nil {
		u.typeName = "issueTriggerBackpressureConfigs"
		u.IssueTriggerBackpressureConfigs = valueIssueTriggerBackpressureConfigs
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateIssueTriggerRequestConfigs) MarshalJSON() ([]byte, error) {
	switch u.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "issueTriggerDeliveryConfigs":
		return json.Marshal(u.IssueTriggerDeliveryConfigs)
	case "issueTriggerTransformationConfigs":
		return json.Marshal(u.IssueTriggerTransformationConfigs)
	case "issueTriggerBackpressureConfigs":
		return json.Marshal(u.IssueTriggerBackpressureConfigs)
	}
}

type UpdateIssueTriggerRequestConfigsVisitor interface {
	VisitIssueTriggerDeliveryConfigs(*IssueTriggerDeliveryConfigs) error
	VisitIssueTriggerTransformationConfigs(*IssueTriggerTransformationConfigs) error
	VisitIssueTriggerBackpressureConfigs(*IssueTriggerBackpressureConfigs) error
}

func (u *UpdateIssueTriggerRequestConfigs) Accept(visitor UpdateIssueTriggerRequestConfigsVisitor) error {
	switch u.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "issueTriggerDeliveryConfigs":
		return visitor.VisitIssueTriggerDeliveryConfigs(u.IssueTriggerDeliveryConfigs)
	case "issueTriggerTransformationConfigs":
		return visitor.VisitIssueTriggerTransformationConfigs(u.IssueTriggerTransformationConfigs)
	case "issueTriggerBackpressureConfigs":
		return visitor.VisitIssueTriggerBackpressureConfigs(u.IssueTriggerBackpressureConfigs)
	}
}

type UpdateTransformationRequestEnvValue struct {
	typeName string
	String   string
	Double   float64
}

func NewUpdateTransformationRequestEnvValueFromString(value string) *UpdateTransformationRequestEnvValue {
	return &UpdateTransformationRequestEnvValue{typeName: "string", String: value}
}

func NewUpdateTransformationRequestEnvValueFromDouble(value float64) *UpdateTransformationRequestEnvValue {
	return &UpdateTransformationRequestEnvValue{typeName: "double", Double: value}
}

func (u *UpdateTransformationRequestEnvValue) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		u.typeName = "string"
		u.String = valueString
		return nil
	}
	var valueDouble float64
	if err := json.Unmarshal(data, &valueDouble); err == nil {
		u.typeName = "double"
		u.Double = valueDouble
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateTransformationRequestEnvValue) MarshalJSON() ([]byte, error) {
	switch u.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "string":
		return json.Marshal(u.String)
	case "double":
		return json.Marshal(u.Double)
	}
}

type UpdateTransformationRequestEnvValueVisitor interface {
	VisitString(string) error
	VisitDouble(float64) error
}

func (u *UpdateTransformationRequestEnvValue) Accept(visitor UpdateTransformationRequestEnvValueVisitor) error {
	switch u.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "string":
		return visitor.VisitString(u.String)
	case "double":
		return visitor.VisitDouble(u.Double)
	}
}

// Destination input object
type UpsertConnectionRequestDestination struct {
	// Name for the destination <span style="white-space: nowrap">`<= 155 characters`</span>
	Name string `json:"name"`
	// Description for the destination
	Description *string `json:"description,omitempty"`
	// Endpoint of the destination
	Url *string `json:"url,omitempty"`
	// Path for the CLI destination
	CliPath *string `json:"cli_path,omitempty"`
	// Period to rate limit attempts
	RateLimitPeriod *UpsertConnectionRequestDestinationRateLimitPeriod `json:"rate_limit_period,omitempty"`
	// Limit event attempts to receive per period
	RateLimit              *int                         `json:"rate_limit,omitempty"`
	HttpMethod             *DestinationHttpMethod       `json:"http_method,omitempty"`
	AuthMethod             *DestinationAuthMethodConfig `json:"auth_method,omitempty"`
	PathForwardingDisabled *bool                        `json:"path_forwarding_disabled,omitempty"`
}

// Period to rate limit attempts
type UpsertConnectionRequestDestinationRateLimitPeriod uint

const (
	UpsertConnectionRequestDestinationRateLimitPeriodSecond UpsertConnectionRequestDestinationRateLimitPeriod = iota + 1
	UpsertConnectionRequestDestinationRateLimitPeriodMinute
	UpsertConnectionRequestDestinationRateLimitPeriodHour
)

func (u UpsertConnectionRequestDestinationRateLimitPeriod) String() string {
	switch u {
	default:
		return strconv.Itoa(int(u))
	case UpsertConnectionRequestDestinationRateLimitPeriodSecond:
		return "second"
	case UpsertConnectionRequestDestinationRateLimitPeriodMinute:
		return "minute"
	case UpsertConnectionRequestDestinationRateLimitPeriodHour:
		return "hour"
	}
}

func (u UpsertConnectionRequestDestinationRateLimitPeriod) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", u.String())), nil
}

func (u *UpsertConnectionRequestDestinationRateLimitPeriod) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "second":
		value := UpsertConnectionRequestDestinationRateLimitPeriodSecond
		*u = value
	case "minute":
		value := UpsertConnectionRequestDestinationRateLimitPeriodMinute
		*u = value
	case "hour":
		value := UpsertConnectionRequestDestinationRateLimitPeriodHour
		*u = value
	}
	return nil
}

// Source input object
type UpsertConnectionRequestSource struct {
	// A unique name for the source <span style="white-space: nowrap">`<= 155 characters`</span>
	Name string `json:"name"`
	// Description for the source
	Description        *string                  `json:"description,omitempty"`
	AllowedHttpMethods *SourceAllowedHttpMethod `json:"allowed_http_methods,omitempty"`
	CustomResponse     *SourceCustomResponse    `json:"custom_response,omitempty"`
	Verification       *VerificationConfig      `json:"verification,omitempty"`
}

// Period to rate limit attempts
type UpsertDestinationRequestRateLimitPeriod uint

const (
	UpsertDestinationRequestRateLimitPeriodSecond UpsertDestinationRequestRateLimitPeriod = iota + 1
	UpsertDestinationRequestRateLimitPeriodMinute
	UpsertDestinationRequestRateLimitPeriodHour
)

func (u UpsertDestinationRequestRateLimitPeriod) String() string {
	switch u {
	default:
		return strconv.Itoa(int(u))
	case UpsertDestinationRequestRateLimitPeriodSecond:
		return "second"
	case UpsertDestinationRequestRateLimitPeriodMinute:
		return "minute"
	case UpsertDestinationRequestRateLimitPeriodHour:
		return "hour"
	}
}

func (u UpsertDestinationRequestRateLimitPeriod) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", u.String())), nil
}

func (u *UpsertDestinationRequestRateLimitPeriod) UnmarshalJSON(data []byte) error {
	var raw string
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	switch raw {
	case "second":
		value := UpsertDestinationRequestRateLimitPeriodSecond
		*u = value
	case "minute":
		value := UpsertDestinationRequestRateLimitPeriodMinute
		*u = value
	case "hour":
		value := UpsertDestinationRequestRateLimitPeriodHour
		*u = value
	}
	return nil
}

// Configuration object for the specific issue type selected
type UpsertIssueTriggerRequestConfigs struct {
	typeName                          string
	IssueTriggerDeliveryConfigs       *IssueTriggerDeliveryConfigs
	IssueTriggerTransformationConfigs *IssueTriggerTransformationConfigs
	IssueTriggerBackpressureConfigs   *IssueTriggerBackpressureConfigs
}

func NewUpsertIssueTriggerRequestConfigsFromIssueTriggerDeliveryConfigs(value *IssueTriggerDeliveryConfigs) *UpsertIssueTriggerRequestConfigs {
	return &UpsertIssueTriggerRequestConfigs{typeName: "issueTriggerDeliveryConfigs", IssueTriggerDeliveryConfigs: value}
}

func NewUpsertIssueTriggerRequestConfigsFromIssueTriggerTransformationConfigs(value *IssueTriggerTransformationConfigs) *UpsertIssueTriggerRequestConfigs {
	return &UpsertIssueTriggerRequestConfigs{typeName: "issueTriggerTransformationConfigs", IssueTriggerTransformationConfigs: value}
}

func NewUpsertIssueTriggerRequestConfigsFromIssueTriggerBackpressureConfigs(value *IssueTriggerBackpressureConfigs) *UpsertIssueTriggerRequestConfigs {
	return &UpsertIssueTriggerRequestConfigs{typeName: "issueTriggerBackpressureConfigs", IssueTriggerBackpressureConfigs: value}
}

func (u *UpsertIssueTriggerRequestConfigs) UnmarshalJSON(data []byte) error {
	valueIssueTriggerDeliveryConfigs := new(IssueTriggerDeliveryConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerDeliveryConfigs); err == nil {
		u.typeName = "issueTriggerDeliveryConfigs"
		u.IssueTriggerDeliveryConfigs = valueIssueTriggerDeliveryConfigs
		return nil
	}
	valueIssueTriggerTransformationConfigs := new(IssueTriggerTransformationConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerTransformationConfigs); err == nil {
		u.typeName = "issueTriggerTransformationConfigs"
		u.IssueTriggerTransformationConfigs = valueIssueTriggerTransformationConfigs
		return nil
	}
	valueIssueTriggerBackpressureConfigs := new(IssueTriggerBackpressureConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerBackpressureConfigs); err == nil {
		u.typeName = "issueTriggerBackpressureConfigs"
		u.IssueTriggerBackpressureConfigs = valueIssueTriggerBackpressureConfigs
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpsertIssueTriggerRequestConfigs) MarshalJSON() ([]byte, error) {
	switch u.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "issueTriggerDeliveryConfigs":
		return json.Marshal(u.IssueTriggerDeliveryConfigs)
	case "issueTriggerTransformationConfigs":
		return json.Marshal(u.IssueTriggerTransformationConfigs)
	case "issueTriggerBackpressureConfigs":
		return json.Marshal(u.IssueTriggerBackpressureConfigs)
	}
}

type UpsertIssueTriggerRequestConfigsVisitor interface {
	VisitIssueTriggerDeliveryConfigs(*IssueTriggerDeliveryConfigs) error
	VisitIssueTriggerTransformationConfigs(*IssueTriggerTransformationConfigs) error
	VisitIssueTriggerBackpressureConfigs(*IssueTriggerBackpressureConfigs) error
}

func (u *UpsertIssueTriggerRequestConfigs) Accept(visitor UpsertIssueTriggerRequestConfigsVisitor) error {
	switch u.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "issueTriggerDeliveryConfigs":
		return visitor.VisitIssueTriggerDeliveryConfigs(u.IssueTriggerDeliveryConfigs)
	case "issueTriggerTransformationConfigs":
		return visitor.VisitIssueTriggerTransformationConfigs(u.IssueTriggerTransformationConfigs)
	case "issueTriggerBackpressureConfigs":
		return visitor.VisitIssueTriggerBackpressureConfigs(u.IssueTriggerBackpressureConfigs)
	}
}

type UpsertTransformationRequestEnvValue struct {
	typeName string
	String   string
	Double   float64
}

func NewUpsertTransformationRequestEnvValueFromString(value string) *UpsertTransformationRequestEnvValue {
	return &UpsertTransformationRequestEnvValue{typeName: "string", String: value}
}

func NewUpsertTransformationRequestEnvValueFromDouble(value float64) *UpsertTransformationRequestEnvValue {
	return &UpsertTransformationRequestEnvValue{typeName: "double", Double: value}
}

func (u *UpsertTransformationRequestEnvValue) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		u.typeName = "string"
		u.String = valueString
		return nil
	}
	var valueDouble float64
	if err := json.Unmarshal(data, &valueDouble); err == nil {
		u.typeName = "double"
		u.Double = valueDouble
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpsertTransformationRequestEnvValue) MarshalJSON() ([]byte, error) {
	switch u.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "string":
		return json.Marshal(u.String)
	case "double":
		return json.Marshal(u.Double)
	}
}

type UpsertTransformationRequestEnvValueVisitor interface {
	VisitString(string) error
	VisitDouble(float64) error
}

func (u *UpsertTransformationRequestEnvValue) Accept(visitor UpsertTransformationRequestEnvValueVisitor) error {
	switch u.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "string":
		return visitor.VisitString(u.String)
	case "double":
		return visitor.VisitDouble(u.Double)
	}
}

// The verification configs for the specific verification type
type VerificationConfig struct {
	typeName       string
	Hmac           *Hmac
	BasicAuth      *BasicAuth
	ApiKey         *ApiKey
	Twitter        *Twitter
	Stripe         *Stripe
	Recharge       *Recharge
	GitHub         *GitHub
	Shopify        *Shopify
	Postmark       *Postmark
	Typeform       *Typeform
	Xero           *Xero
	Svix           *Svix
	Zoom           *Zoom
	Akeneo         *Akeneo
	Adyen          *Adyen
	GitLab         *GitLab
	PropertyFinder *PropertyFinder
	WooCommerce    *WooCommerce
	Oura           *Oura
	Commercelayer  *Commercelayer
	Mailgun        *Mailgun
	Pipedrive      *Pipedrive
	SendGrid       *SendGrid
	WorkOs         *WorkOs
	Synctera       *Synctera
	AwsSns         *AwsSns
	ThreeDEye      *ThreeDEye
}

func NewVerificationConfigFromHmac(value *Hmac) *VerificationConfig {
	return &VerificationConfig{typeName: "hmac", Hmac: value}
}

func NewVerificationConfigFromBasicAuth(value *BasicAuth) *VerificationConfig {
	return &VerificationConfig{typeName: "basicAuth", BasicAuth: value}
}

func NewVerificationConfigFromApiKey(value *ApiKey) *VerificationConfig {
	return &VerificationConfig{typeName: "apiKey", ApiKey: value}
}

func NewVerificationConfigFromTwitter(value *Twitter) *VerificationConfig {
	return &VerificationConfig{typeName: "twitter", Twitter: value}
}

func NewVerificationConfigFromStripe(value *Stripe) *VerificationConfig {
	return &VerificationConfig{typeName: "stripe", Stripe: value}
}

func NewVerificationConfigFromRecharge(value *Recharge) *VerificationConfig {
	return &VerificationConfig{typeName: "recharge", Recharge: value}
}

func NewVerificationConfigFromGitHub(value *GitHub) *VerificationConfig {
	return &VerificationConfig{typeName: "gitHub", GitHub: value}
}

func NewVerificationConfigFromShopify(value *Shopify) *VerificationConfig {
	return &VerificationConfig{typeName: "shopify", Shopify: value}
}

func NewVerificationConfigFromPostmark(value *Postmark) *VerificationConfig {
	return &VerificationConfig{typeName: "postmark", Postmark: value}
}

func NewVerificationConfigFromTypeform(value *Typeform) *VerificationConfig {
	return &VerificationConfig{typeName: "typeform", Typeform: value}
}

func NewVerificationConfigFromXero(value *Xero) *VerificationConfig {
	return &VerificationConfig{typeName: "xero", Xero: value}
}

func NewVerificationConfigFromSvix(value *Svix) *VerificationConfig {
	return &VerificationConfig{typeName: "svix", Svix: value}
}

func NewVerificationConfigFromZoom(value *Zoom) *VerificationConfig {
	return &VerificationConfig{typeName: "zoom", Zoom: value}
}

func NewVerificationConfigFromAkeneo(value *Akeneo) *VerificationConfig {
	return &VerificationConfig{typeName: "akeneo", Akeneo: value}
}

func NewVerificationConfigFromAdyen(value *Adyen) *VerificationConfig {
	return &VerificationConfig{typeName: "adyen", Adyen: value}
}

func NewVerificationConfigFromGitLab(value *GitLab) *VerificationConfig {
	return &VerificationConfig{typeName: "gitLab", GitLab: value}
}

func NewVerificationConfigFromPropertyFinder(value *PropertyFinder) *VerificationConfig {
	return &VerificationConfig{typeName: "propertyFinder", PropertyFinder: value}
}

func NewVerificationConfigFromWooCommerce(value *WooCommerce) *VerificationConfig {
	return &VerificationConfig{typeName: "wooCommerce", WooCommerce: value}
}

func NewVerificationConfigFromOura(value *Oura) *VerificationConfig {
	return &VerificationConfig{typeName: "oura", Oura: value}
}

func NewVerificationConfigFromCommercelayer(value *Commercelayer) *VerificationConfig {
	return &VerificationConfig{typeName: "commercelayer", Commercelayer: value}
}

func NewVerificationConfigFromMailgun(value *Mailgun) *VerificationConfig {
	return &VerificationConfig{typeName: "mailgun", Mailgun: value}
}

func NewVerificationConfigFromPipedrive(value *Pipedrive) *VerificationConfig {
	return &VerificationConfig{typeName: "pipedrive", Pipedrive: value}
}

func NewVerificationConfigFromSendGrid(value *SendGrid) *VerificationConfig {
	return &VerificationConfig{typeName: "sendGrid", SendGrid: value}
}

func NewVerificationConfigFromWorkOs(value *WorkOs) *VerificationConfig {
	return &VerificationConfig{typeName: "workOs", WorkOs: value}
}

func NewVerificationConfigFromSynctera(value *Synctera) *VerificationConfig {
	return &VerificationConfig{typeName: "synctera", Synctera: value}
}

func NewVerificationConfigFromAwsSns(value *AwsSns) *VerificationConfig {
	return &VerificationConfig{typeName: "awsSns", AwsSns: value}
}

func NewVerificationConfigFromThreeDEye(value *ThreeDEye) *VerificationConfig {
	return &VerificationConfig{typeName: "threeDEye", ThreeDEye: value}
}

func (v *VerificationConfig) UnmarshalJSON(data []byte) error {
	valueHmac := new(Hmac)
	if err := json.Unmarshal(data, &valueHmac); err == nil {
		v.typeName = "hmac"
		v.Hmac = valueHmac
		return nil
	}
	valueBasicAuth := new(BasicAuth)
	if err := json.Unmarshal(data, &valueBasicAuth); err == nil {
		v.typeName = "basicAuth"
		v.BasicAuth = valueBasicAuth
		return nil
	}
	valueApiKey := new(ApiKey)
	if err := json.Unmarshal(data, &valueApiKey); err == nil {
		v.typeName = "apiKey"
		v.ApiKey = valueApiKey
		return nil
	}
	valueTwitter := new(Twitter)
	if err := json.Unmarshal(data, &valueTwitter); err == nil {
		v.typeName = "twitter"
		v.Twitter = valueTwitter
		return nil
	}
	valueStripe := new(Stripe)
	if err := json.Unmarshal(data, &valueStripe); err == nil {
		v.typeName = "stripe"
		v.Stripe = valueStripe
		return nil
	}
	valueRecharge := new(Recharge)
	if err := json.Unmarshal(data, &valueRecharge); err == nil {
		v.typeName = "recharge"
		v.Recharge = valueRecharge
		return nil
	}
	valueGitHub := new(GitHub)
	if err := json.Unmarshal(data, &valueGitHub); err == nil {
		v.typeName = "gitHub"
		v.GitHub = valueGitHub
		return nil
	}
	valueShopify := new(Shopify)
	if err := json.Unmarshal(data, &valueShopify); err == nil {
		v.typeName = "shopify"
		v.Shopify = valueShopify
		return nil
	}
	valuePostmark := new(Postmark)
	if err := json.Unmarshal(data, &valuePostmark); err == nil {
		v.typeName = "postmark"
		v.Postmark = valuePostmark
		return nil
	}
	valueTypeform := new(Typeform)
	if err := json.Unmarshal(data, &valueTypeform); err == nil {
		v.typeName = "typeform"
		v.Typeform = valueTypeform
		return nil
	}
	valueXero := new(Xero)
	if err := json.Unmarshal(data, &valueXero); err == nil {
		v.typeName = "xero"
		v.Xero = valueXero
		return nil
	}
	valueSvix := new(Svix)
	if err := json.Unmarshal(data, &valueSvix); err == nil {
		v.typeName = "svix"
		v.Svix = valueSvix
		return nil
	}
	valueZoom := new(Zoom)
	if err := json.Unmarshal(data, &valueZoom); err == nil {
		v.typeName = "zoom"
		v.Zoom = valueZoom
		return nil
	}
	valueAkeneo := new(Akeneo)
	if err := json.Unmarshal(data, &valueAkeneo); err == nil {
		v.typeName = "akeneo"
		v.Akeneo = valueAkeneo
		return nil
	}
	valueAdyen := new(Adyen)
	if err := json.Unmarshal(data, &valueAdyen); err == nil {
		v.typeName = "adyen"
		v.Adyen = valueAdyen
		return nil
	}
	valueGitLab := new(GitLab)
	if err := json.Unmarshal(data, &valueGitLab); err == nil {
		v.typeName = "gitLab"
		v.GitLab = valueGitLab
		return nil
	}
	valuePropertyFinder := new(PropertyFinder)
	if err := json.Unmarshal(data, &valuePropertyFinder); err == nil {
		v.typeName = "propertyFinder"
		v.PropertyFinder = valuePropertyFinder
		return nil
	}
	valueWooCommerce := new(WooCommerce)
	if err := json.Unmarshal(data, &valueWooCommerce); err == nil {
		v.typeName = "wooCommerce"
		v.WooCommerce = valueWooCommerce
		return nil
	}
	valueOura := new(Oura)
	if err := json.Unmarshal(data, &valueOura); err == nil {
		v.typeName = "oura"
		v.Oura = valueOura
		return nil
	}
	valueCommercelayer := new(Commercelayer)
	if err := json.Unmarshal(data, &valueCommercelayer); err == nil {
		v.typeName = "commercelayer"
		v.Commercelayer = valueCommercelayer
		return nil
	}
	valueMailgun := new(Mailgun)
	if err := json.Unmarshal(data, &valueMailgun); err == nil {
		v.typeName = "mailgun"
		v.Mailgun = valueMailgun
		return nil
	}
	valuePipedrive := new(Pipedrive)
	if err := json.Unmarshal(data, &valuePipedrive); err == nil {
		v.typeName = "pipedrive"
		v.Pipedrive = valuePipedrive
		return nil
	}
	valueSendGrid := new(SendGrid)
	if err := json.Unmarshal(data, &valueSendGrid); err == nil {
		v.typeName = "sendGrid"
		v.SendGrid = valueSendGrid
		return nil
	}
	valueWorkOs := new(WorkOs)
	if err := json.Unmarshal(data, &valueWorkOs); err == nil {
		v.typeName = "workOs"
		v.WorkOs = valueWorkOs
		return nil
	}
	valueSynctera := new(Synctera)
	if err := json.Unmarshal(data, &valueSynctera); err == nil {
		v.typeName = "synctera"
		v.Synctera = valueSynctera
		return nil
	}
	valueAwsSns := new(AwsSns)
	if err := json.Unmarshal(data, &valueAwsSns); err == nil {
		v.typeName = "awsSns"
		v.AwsSns = valueAwsSns
		return nil
	}
	valueThreeDEye := new(ThreeDEye)
	if err := json.Unmarshal(data, &valueThreeDEye); err == nil {
		v.typeName = "threeDEye"
		v.ThreeDEye = valueThreeDEye
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VerificationConfig) MarshalJSON() ([]byte, error) {
	switch v.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "hmac":
		return json.Marshal(v.Hmac)
	case "basicAuth":
		return json.Marshal(v.BasicAuth)
	case "apiKey":
		return json.Marshal(v.ApiKey)
	case "twitter":
		return json.Marshal(v.Twitter)
	case "stripe":
		return json.Marshal(v.Stripe)
	case "recharge":
		return json.Marshal(v.Recharge)
	case "gitHub":
		return json.Marshal(v.GitHub)
	case "shopify":
		return json.Marshal(v.Shopify)
	case "postmark":
		return json.Marshal(v.Postmark)
	case "typeform":
		return json.Marshal(v.Typeform)
	case "xero":
		return json.Marshal(v.Xero)
	case "svix":
		return json.Marshal(v.Svix)
	case "zoom":
		return json.Marshal(v.Zoom)
	case "akeneo":
		return json.Marshal(v.Akeneo)
	case "adyen":
		return json.Marshal(v.Adyen)
	case "gitLab":
		return json.Marshal(v.GitLab)
	case "propertyFinder":
		return json.Marshal(v.PropertyFinder)
	case "wooCommerce":
		return json.Marshal(v.WooCommerce)
	case "oura":
		return json.Marshal(v.Oura)
	case "commercelayer":
		return json.Marshal(v.Commercelayer)
	case "mailgun":
		return json.Marshal(v.Mailgun)
	case "pipedrive":
		return json.Marshal(v.Pipedrive)
	case "sendGrid":
		return json.Marshal(v.SendGrid)
	case "workOs":
		return json.Marshal(v.WorkOs)
	case "synctera":
		return json.Marshal(v.Synctera)
	case "awsSns":
		return json.Marshal(v.AwsSns)
	case "threeDEye":
		return json.Marshal(v.ThreeDEye)
	}
}

type VerificationConfigVisitor interface {
	VisitHmac(*Hmac) error
	VisitBasicAuth(*BasicAuth) error
	VisitApiKey(*ApiKey) error
	VisitTwitter(*Twitter) error
	VisitStripe(*Stripe) error
	VisitRecharge(*Recharge) error
	VisitGitHub(*GitHub) error
	VisitShopify(*Shopify) error
	VisitPostmark(*Postmark) error
	VisitTypeform(*Typeform) error
	VisitXero(*Xero) error
	VisitSvix(*Svix) error
	VisitZoom(*Zoom) error
	VisitAkeneo(*Akeneo) error
	VisitAdyen(*Adyen) error
	VisitGitLab(*GitLab) error
	VisitPropertyFinder(*PropertyFinder) error
	VisitWooCommerce(*WooCommerce) error
	VisitOura(*Oura) error
	VisitCommercelayer(*Commercelayer) error
	VisitMailgun(*Mailgun) error
	VisitPipedrive(*Pipedrive) error
	VisitSendGrid(*SendGrid) error
	VisitWorkOs(*WorkOs) error
	VisitSynctera(*Synctera) error
	VisitAwsSns(*AwsSns) error
	VisitThreeDEye(*ThreeDEye) error
}

func (v *VerificationConfig) Accept(visitor VerificationConfigVisitor) error {
	switch v.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "hmac":
		return visitor.VisitHmac(v.Hmac)
	case "basicAuth":
		return visitor.VisitBasicAuth(v.BasicAuth)
	case "apiKey":
		return visitor.VisitApiKey(v.ApiKey)
	case "twitter":
		return visitor.VisitTwitter(v.Twitter)
	case "stripe":
		return visitor.VisitStripe(v.Stripe)
	case "recharge":
		return visitor.VisitRecharge(v.Recharge)
	case "gitHub":
		return visitor.VisitGitHub(v.GitHub)
	case "shopify":
		return visitor.VisitShopify(v.Shopify)
	case "postmark":
		return visitor.VisitPostmark(v.Postmark)
	case "typeform":
		return visitor.VisitTypeform(v.Typeform)
	case "xero":
		return visitor.VisitXero(v.Xero)
	case "svix":
		return visitor.VisitSvix(v.Svix)
	case "zoom":
		return visitor.VisitZoom(v.Zoom)
	case "akeneo":
		return visitor.VisitAkeneo(v.Akeneo)
	case "adyen":
		return visitor.VisitAdyen(v.Adyen)
	case "gitLab":
		return visitor.VisitGitLab(v.GitLab)
	case "propertyFinder":
		return visitor.VisitPropertyFinder(v.PropertyFinder)
	case "wooCommerce":
		return visitor.VisitWooCommerce(v.WooCommerce)
	case "oura":
		return visitor.VisitOura(v.Oura)
	case "commercelayer":
		return visitor.VisitCommercelayer(v.Commercelayer)
	case "mailgun":
		return visitor.VisitMailgun(v.Mailgun)
	case "pipedrive":
		return visitor.VisitPipedrive(v.Pipedrive)
	case "sendGrid":
		return visitor.VisitSendGrid(v.SendGrid)
	case "workOs":
		return visitor.VisitWorkOs(v.WorkOs)
	case "synctera":
		return visitor.VisitSynctera(v.Synctera)
	case "awsSns":
		return visitor.VisitAwsSns(v.AwsSns)
	case "threeDEye":
		return visitor.VisitThreeDEye(v.ThreeDEye)
	}
}

type WooCommerce struct {
	Configs *WooCommerceConfigs `json:"configs,omitempty"`
	type_   string
}

func (w *WooCommerce) Type() string {
	return w.type_
}

func (w *WooCommerce) UnmarshalJSON(data []byte) error {
	type unmarshaler WooCommerce
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WooCommerce(value)
	w.type_ = "woocommerce"
	return nil
}

func (w *WooCommerce) MarshalJSON() ([]byte, error) {
	type embed WooCommerce
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*w),
		Type:  "woocommerce",
	}
	return json.Marshal(marshaler)
}

// The verification configs for WooCommerce. Only included if the ?include=verification.configs query param is present
type WooCommerceConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type WorkOs struct {
	Configs *WorkOsConfigs `json:"configs,omitempty"`
	type_   string
}

func (w *WorkOs) Type() string {
	return w.type_
}

func (w *WorkOs) UnmarshalJSON(data []byte) error {
	type unmarshaler WorkOs
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WorkOs(value)
	w.type_ = "workos"
	return nil
}

func (w *WorkOs) MarshalJSON() ([]byte, error) {
	type embed WorkOs
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*w),
		Type:  "workos",
	}
	return json.Marshal(marshaler)
}

// The verification configs for WorkOS. Only included if the ?include=verification.configs query param is present
type WorkOsConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type Xero struct {
	Configs *XeroConfigs `json:"configs,omitempty"`
	type_   string
}

func (x *Xero) Type() string {
	return x.type_
}

func (x *Xero) UnmarshalJSON(data []byte) error {
	type unmarshaler Xero
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*x = Xero(value)
	x.type_ = "xero"
	return nil
}

func (x *Xero) MarshalJSON() ([]byte, error) {
	type embed Xero
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*x),
		Type:  "xero",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Xero. Only included if the ?include=verification.configs query param is present
type XeroConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type Zoom struct {
	Configs *ZoomConfigs `json:"configs,omitempty"`
	type_   string
}

func (z *Zoom) Type() string {
	return z.type_
}

func (z *Zoom) UnmarshalJSON(data []byte) error {
	type unmarshaler Zoom
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*z = Zoom(value)
	z.type_ = "zoom"
	return nil
}

func (z *Zoom) MarshalJSON() ([]byte, error) {
	type embed Zoom
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*z),
		Type:  "zoom",
	}
	return json.Marshal(marshaler)
}

// The verification configs for Zoom. Only included if the ?include=verification.configs query param is present
type ZoomConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}
