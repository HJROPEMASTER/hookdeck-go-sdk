// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	time "time"
)

type AddCustomHostname struct {
	// The custom hostname to attach to the workspace
	Hostname string `json:"hostname"`
}

// Error response model
type ApiErrorResponse struct {
	// Error code
	Code string `json:"code"`
	// Status code
	Status float64 `json:"status"`
	// Error description
	Message string                `json:"message"`
	Data    *ApiErrorResponseData `json:"data,omitempty"`
}

type ApiErrorResponseData struct {
}

type ApiKeyIntegrationConfigs struct {
	HeaderKey string `json:"header_key"`
	ApiKey    string `json:"api_key"`
}

type AttachedIntegrationToSource struct {
	Success bool `json:"success"`
}

// Error code of the delivery attempt
type AttemptErrorCodes string

const (
	AttemptErrorCodesCancelled                AttemptErrorCodes = "CANCELLED"
	AttemptErrorCodesTimeout                  AttemptErrorCodes = "TIMEOUT"
	AttemptErrorCodesNotFound                 AttemptErrorCodes = "NOT_FOUND"
	AttemptErrorCodesConnectionRefused        AttemptErrorCodes = "CONNECTION_REFUSED"
	AttemptErrorCodesConnectionReset          AttemptErrorCodes = "CONNECTION_RESET"
	AttemptErrorCodesMissingUrl               AttemptErrorCodes = "MISSING_URL"
	AttemptErrorCodesCli                      AttemptErrorCodes = "CLI"
	AttemptErrorCodesCliUnavailable           AttemptErrorCodes = "CLI_UNAVAILABLE"
	AttemptErrorCodesSelfSignedCert           AttemptErrorCodes = "SELF_SIGNED_CERT"
	AttemptErrorCodesErrTlsCertAltnameInvalid AttemptErrorCodes = "ERR_TLS_CERT_ALTNAME_INVALID"
	AttemptErrorCodesErrSslWrongVersionNumber AttemptErrorCodes = "ERR_SSL_WRONG_VERSION_NUMBER"
	AttemptErrorCodesSslErrorCaUnknown        AttemptErrorCodes = "SSL_ERROR_CA_UNKNOWN"
	AttemptErrorCodesTtlExpired               AttemptErrorCodes = "TTL_EXPIRED"
	AttemptErrorCodesDataArchived             AttemptErrorCodes = "DATA_ARCHIVED"
	AttemptErrorCodesSslCertExpired           AttemptErrorCodes = "SSL_CERT_EXPIRED"
	AttemptErrorCodesBulkRetryCancelled       AttemptErrorCodes = "BULK_RETRY_CANCELLED"
	AttemptErrorCodesDnsLookupFailed          AttemptErrorCodes = "DNS_LOOKUP_FAILED"
	AttemptErrorCodesHostUnreachable          AttemptErrorCodes = "HOST_UNREACHABLE"
	AttemptErrorCodesProtocolError            AttemptErrorCodes = "PROTOCOL_ERROR"
	AttemptErrorCodesSocketClosed             AttemptErrorCodes = "SOCKET_CLOSED"
	AttemptErrorCodesOauth2HandshakeFailed    AttemptErrorCodes = "OAUTH2_HANDSHAKE_FAILED"
	AttemptErrorCodesUnknown                  AttemptErrorCodes = "UNKNOWN"
)

func NewAttemptErrorCodesFromString(s string) (AttemptErrorCodes, error) {
	switch s {
	case "CANCELLED":
		return AttemptErrorCodesCancelled, nil
	case "TIMEOUT":
		return AttemptErrorCodesTimeout, nil
	case "NOT_FOUND":
		return AttemptErrorCodesNotFound, nil
	case "CONNECTION_REFUSED":
		return AttemptErrorCodesConnectionRefused, nil
	case "CONNECTION_RESET":
		return AttemptErrorCodesConnectionReset, nil
	case "MISSING_URL":
		return AttemptErrorCodesMissingUrl, nil
	case "CLI":
		return AttemptErrorCodesCli, nil
	case "CLI_UNAVAILABLE":
		return AttemptErrorCodesCliUnavailable, nil
	case "SELF_SIGNED_CERT":
		return AttemptErrorCodesSelfSignedCert, nil
	case "ERR_TLS_CERT_ALTNAME_INVALID":
		return AttemptErrorCodesErrTlsCertAltnameInvalid, nil
	case "ERR_SSL_WRONG_VERSION_NUMBER":
		return AttemptErrorCodesErrSslWrongVersionNumber, nil
	case "SSL_ERROR_CA_UNKNOWN":
		return AttemptErrorCodesSslErrorCaUnknown, nil
	case "TTL_EXPIRED":
		return AttemptErrorCodesTtlExpired, nil
	case "DATA_ARCHIVED":
		return AttemptErrorCodesDataArchived, nil
	case "SSL_CERT_EXPIRED":
		return AttemptErrorCodesSslCertExpired, nil
	case "BULK_RETRY_CANCELLED":
		return AttemptErrorCodesBulkRetryCancelled, nil
	case "DNS_LOOKUP_FAILED":
		return AttemptErrorCodesDnsLookupFailed, nil
	case "HOST_UNREACHABLE":
		return AttemptErrorCodesHostUnreachable, nil
	case "PROTOCOL_ERROR":
		return AttemptErrorCodesProtocolError, nil
	case "SOCKET_CLOSED":
		return AttemptErrorCodesSocketClosed, nil
	case "OAUTH2_HANDSHAKE_FAILED":
		return AttemptErrorCodesOauth2HandshakeFailed, nil
	case "UNKNOWN":
		return AttemptErrorCodesUnknown, nil
	}
	var t AttemptErrorCodes
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AttemptErrorCodes) Ptr() *AttemptErrorCodes {
	return &a
}

type AttemptState string

const (
	AttemptStateDelivering AttemptState = "DELIVERING"
	AttemptStateQueued     AttemptState = "QUEUED"
	AttemptStatePending    AttemptState = "PENDING"
	AttemptStateCompleted  AttemptState = "COMPLETED"
	AttemptStateHold       AttemptState = "HOLD"
)

func NewAttemptStateFromString(s string) (AttemptState, error) {
	switch s {
	case "DELIVERING":
		return AttemptStateDelivering, nil
	case "QUEUED":
		return AttemptStateQueued, nil
	case "PENDING":
		return AttemptStatePending, nil
	case "COMPLETED":
		return AttemptStateCompleted, nil
	case "HOLD":
		return AttemptStateHold, nil
	}
	var t AttemptState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AttemptState) Ptr() *AttemptState {
	return &a
}

// Attempt status
type AttemptStatus string

const (
	AttemptStatusQueued     AttemptStatus = "QUEUED"
	AttemptStatusFailed     AttemptStatus = "FAILED"
	AttemptStatusSuccessful AttemptStatus = "SUCCESSFUL"
	AttemptStatusHold       AttemptStatus = "HOLD"
)

func NewAttemptStatusFromString(s string) (AttemptStatus, error) {
	switch s {
	case "QUEUED":
		return AttemptStatusQueued, nil
	case "FAILED":
		return AttemptStatusFailed, nil
	case "SUCCESSFUL":
		return AttemptStatusSuccessful, nil
	case "HOLD":
		return AttemptStatusHold, nil
	}
	var t AttemptStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AttemptStatus) Ptr() *AttemptStatus {
	return &a
}

// How the attempt was triggered
type AttemptTrigger string

const (
	AttemptTriggerInitial   AttemptTrigger = "INITIAL"
	AttemptTriggerManual    AttemptTrigger = "MANUAL"
	AttemptTriggerBulkRetry AttemptTrigger = "BULK_RETRY"
	AttemptTriggerUnpause   AttemptTrigger = "UNPAUSE"
	AttemptTriggerAutomatic AttemptTrigger = "AUTOMATIC"
)

func NewAttemptTriggerFromString(s string) (AttemptTrigger, error) {
	switch s {
	case "INITIAL":
		return AttemptTriggerInitial, nil
	case "MANUAL":
		return AttemptTriggerManual, nil
	case "BULK_RETRY":
		return AttemptTriggerBulkRetry, nil
	case "UNPAUSE":
		return AttemptTriggerUnpause, nil
	case "AUTOMATIC":
		return AttemptTriggerAutomatic, nil
	}
	var t AttemptTrigger
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AttemptTrigger) Ptr() *AttemptTrigger {
	return &a
}

// API Key
type AuthApiKey struct {
	Config *DestinationAuthMethodApiKeyConfig `json:"config,omitempty"`
}

// Basic Auth
type AuthBasicAuth struct {
	Config *DestinationAuthMethodBasicAuthConfig `json:"config,omitempty"`
}

// Bearer Token
type AuthBearerToken struct {
	Config *DestinationAuthMethodBearerTokenConfig `json:"config,omitempty"`
}

// Custom Signature
type AuthCustomSignature struct {
	Config *DestinationAuthMethodCustomSignatureConfig `json:"config,omitempty"`
}

// Hookdeck Signature
type AuthHookdeckSignature struct {
	Config *DestinationAuthMethodSignatureConfig `json:"config,omitempty"`
}

// OAuth2 Authorization Code
type AuthOAuth2AuthorizationCode struct {
	Config *DestinationAuthMethodOAuth2AuthorizationCodeConfig `json:"config,omitempty"`
}

// OAuth2 Client Credentials
type AuthOAuth2ClientCredentials struct {
	Config *DestinationAuthMethodOAuth2ClientCredentialsConfig `json:"config,omitempty"`
}

type BasicAuthIntegrationConfigs struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

type BatchOperation struct {
	// ID of the bulk retry
	Id string `json:"id"`
	// ID of the workspace
	TeamId string `json:"team_id"`
	// Query object to filter records
	Query *BatchOperationQuery `json:"query,omitempty"`
	// Date the bulk retry was created
	CreatedAt time.Time `json:"created_at"`
	// Last time the bulk retry was updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the bulk retry was cancelled
	CancelledAt *time.Time `json:"cancelled_at,omitempty"`
	// Date the bulk retry was completed
	CompletedAt *time.Time `json:"completed_at,omitempty"`
	// Number of batches required to complete the bulk retry
	EstimatedBatch *int `json:"estimated_batch,omitempty"`
	// Number of estimated events to be retried
	EstimatedCount *int `json:"estimated_count,omitempty"`
	// Number of batches currently processed
	ProcessedBatch *int `json:"processed_batch,omitempty"`
	// Number of events that were successfully delivered
	CompletedCount *int `json:"completed_count,omitempty"`
	// Indicates if the bulk retry is currently in progress
	InProgress bool `json:"in_progress"`
	// Progression of the batch operations, values 0 - 1
	Progress *float64 `json:"progress,omitempty"`
	// Number of events that failed to be delivered
	FailedCount *int     `json:"failed_count,omitempty"`
	Number      *float64 `json:"number,omitempty"`
}

type BatchOperationPaginatedResult struct {
	Pagination *SeekPagination   `json:"pagination,omitempty"`
	Count      *int              `json:"count,omitempty"`
	Models     []*BatchOperation `json:"models,omitempty"`
}

// Query object to filter records
type BatchOperationQuery struct {
	typeName         string
	StringUnknownMap map[string]interface{}
	StringOptional   *string
}

func NewBatchOperationQueryFromStringUnknownMap(value map[string]interface{}) *BatchOperationQuery {
	return &BatchOperationQuery{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func NewBatchOperationQueryFromStringOptional(value *string) *BatchOperationQuery {
	return &BatchOperationQuery{typeName: "stringOptional", StringOptional: value}
}

func (b *BatchOperationQuery) UnmarshalJSON(data []byte) error {
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		b.typeName = "stringUnknownMap"
		b.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		b.typeName = "stringOptional"
		b.StringOptional = valueStringOptional
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BatchOperationQuery) MarshalJSON() ([]byte, error) {
	switch b.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "stringUnknownMap":
		return json.Marshal(b.StringUnknownMap)
	case "stringOptional":
		return json.Marshal(b.StringOptional)
	}
}

type BatchOperationQueryVisitor interface {
	VisitStringUnknownMap(map[string]interface{}) error
	VisitStringOptional(*string) error
}

func (b *BatchOperationQuery) Accept(visitor BatchOperationQueryVisitor) error {
	switch b.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(b.StringUnknownMap)
	case "stringOptional":
		return visitor.VisitStringOptional(b.StringOptional)
	}
}

type Bookmark struct {
	// ID of the bookmark
	Id string `json:"id"`
	// ID of the workspace
	TeamId string `json:"team_id"`
	// ID of the associated connection
	WebhookId string `json:"webhook_id"`
	// ID of the bookmarked event data
	EventDataId string `json:"event_data_id"`
	// Descriptive name of the bookmark
	Label string `json:"label"`
	// Alternate alias for the bookmark
	Alias *string         `json:"alias,omitempty"`
	Data  *ShortEventData `json:"data,omitempty"`
	// Date the bookmark was last manually triggered
	LastUsedAt *time.Time `json:"last_used_at,omitempty"`
	// Date the bookmark was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the bookmark was created
	CreatedAt time.Time `json:"created_at"`
}

type BookmarkPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Bookmark     `json:"models,omitempty"`
}

type Connection struct {
	// ID of the connection
	Id string `json:"id"`
	// Unique name of the connection for this source
	Name *string `json:"name,omitempty"`
	// Full name of the connection concatenated from source, connection and desitnation name
	FullName *string `json:"full_name,omitempty"`
	// Description of the connection
	Description *string `json:"description,omitempty"`
	// ID of the workspace
	TeamId      string       `json:"team_id"`
	Destination *Destination `json:"destination,omitempty"`
	Source      *Source      `json:"source,omitempty"`
	// Array of rules configured on the connection
	Rules []*Rule `json:"rules,omitempty"`
	// Date the connection was disabled
	DisabledAt *time.Time `json:"disabled_at,omitempty"`
	// Date the connection was paused
	PausedAt *time.Time `json:"paused_at,omitempty"`
	// Date the connection was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the connection was created
	CreatedAt time.Time `json:"created_at"`
}

type ConnectionPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Connection   `json:"models,omitempty"`
}

type ConsoleLine struct {
	Type    ConsoleLineType `json:"type,omitempty"`
	Message string          `json:"message"`
}

type ConsoleLineType string

const (
	ConsoleLineTypeError ConsoleLineType = "error"
	ConsoleLineTypeLog   ConsoleLineType = "log"
	ConsoleLineTypeWarn  ConsoleLineType = "warn"
	ConsoleLineTypeInfo  ConsoleLineType = "info"
	ConsoleLineTypeDebug ConsoleLineType = "debug"
)

func NewConsoleLineTypeFromString(s string) (ConsoleLineType, error) {
	switch s {
	case "error":
		return ConsoleLineTypeError, nil
	case "log":
		return ConsoleLineTypeLog, nil
	case "warn":
		return ConsoleLineTypeWarn, nil
	case "info":
		return ConsoleLineTypeInfo, nil
	case "debug":
		return ConsoleLineTypeDebug, nil
	}
	var t ConsoleLineType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConsoleLineType) Ptr() *ConsoleLineType {
	return &c
}

type DelayRule struct {
	// Delay to introduce in MS
	Delay int `json:"delay"`
	type_ string
}

func (d *DelayRule) Type() string {
	return d.type_
}

func (d *DelayRule) UnmarshalJSON(data []byte) error {
	type unmarshaler DelayRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DelayRule(value)
	d.type_ = "delay"
	return nil
}

func (d *DelayRule) MarshalJSON() ([]byte, error) {
	type embed DelayRule
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*d),
		Type:  "delay",
	}
	return json.Marshal(marshaler)
}

type DeleteCustomDomainSchema struct {
	// The custom hostname ID
	Id string `json:"id"`
}

type DeletedBookmarkResponse struct {
	// Bookmark ID
	Id string `json:"id"`
}

type DeletedIntegration struct {
	Id string `json:"id"`
}

type DeletedIssueTriggerResponse struct {
	Id string `json:"id"`
}

// Delivery issue
type DeliveryIssue struct {
	// Issue ID
	Id string `json:"id"`
	// ID of the workspace
	TeamId string      `json:"team_id"`
	Status IssueStatus `json:"status,omitempty"`
	// ISO timestamp for when the issue was last opened
	OpenedAt time.Time `json:"opened_at"`
	// ISO timestamp for when the issue was first opened
	FirstSeenAt time.Time `json:"first_seen_at"`
	// ISO timestamp for when the issue last occured
	LastSeenAt time.Time `json:"last_seen_at"`
	// Deprecated, will always be set to null
	LastUpdatedBy *string `json:"last_updated_by,omitempty"`
	// ISO timestamp for when the issue was dismissed
	DismissedAt    *time.Time `json:"dismissed_at,omitempty"`
	AutoResolvedAt *time.Time `json:"auto_resolved_at,omitempty"`
	MergedWith     *string    `json:"merged_with,omitempty"`
	// ISO timestamp for when the issue was last updated
	UpdatedAt string `json:"updated_at"`
	// ISO timestamp for when the issue was created
	CreatedAt       string                        `json:"created_at"`
	AggregationKeys *DeliveryIssueAggregationKeys `json:"aggregation_keys,omitempty"`
	Reference       *DeliveryIssueReference       `json:"reference,omitempty"`
}

// Keys used as the aggregation keys a 'delivery' type issue
type DeliveryIssueAggregationKeys struct {
	WebhookId      []string            `json:"webhook_id,omitempty"`
	ResponseStatus []float64           `json:"response_status,omitempty"`
	ErrorCode      []AttemptErrorCodes `json:"error_code,omitempty"`
}

// Delivery issue data
type DeliveryIssueData struct {
	TriggerEvent   *Event        `json:"trigger_event,omitempty"`
	TriggerAttempt *EventAttempt `json:"trigger_attempt,omitempty"`
}

// Reference to the event and attempt an issue is being created for.
type DeliveryIssueReference struct {
	EventId   string `json:"event_id"`
	AttemptId string `json:"attempt_id"`
}

// Delivery issue
type DeliveryIssueWithData struct {
	// Issue ID
	Id string `json:"id"`
	// ID of the workspace
	TeamId string      `json:"team_id"`
	Status IssueStatus `json:"status,omitempty"`
	// ISO timestamp for when the issue was last opened
	OpenedAt time.Time `json:"opened_at"`
	// ISO timestamp for when the issue was first opened
	FirstSeenAt time.Time `json:"first_seen_at"`
	// ISO timestamp for when the issue last occured
	LastSeenAt time.Time `json:"last_seen_at"`
	// Deprecated, will always be set to null
	LastUpdatedBy *string `json:"last_updated_by,omitempty"`
	// ISO timestamp for when the issue was dismissed
	DismissedAt    *time.Time `json:"dismissed_at,omitempty"`
	AutoResolvedAt *time.Time `json:"auto_resolved_at,omitempty"`
	MergedWith     *string    `json:"merged_with,omitempty"`
	// ISO timestamp for when the issue was last updated
	UpdatedAt string `json:"updated_at"`
	// ISO timestamp for when the issue was created
	CreatedAt       string                        `json:"created_at"`
	AggregationKeys *DeliveryIssueAggregationKeys `json:"aggregation_keys,omitempty"`
	Reference       *DeliveryIssueReference       `json:"reference,omitempty"`
	Data            *DeliveryIssueData            `json:"data,omitempty"`
}

// Associated [Destination](#destination-object) object
type Destination struct {
	// ID of the destination
	Id string `json:"id"`
	// A unique, human-friendly name for the destination
	Name string `json:"name"`
	// Description of the destination
	Description *string `json:"description,omitempty"`
	// ID of the workspace
	TeamId                 string `json:"team_id"`
	PathForwardingDisabled *bool  `json:"path_forwarding_disabled,omitempty"`
	// HTTP endpoint of the destination
	Url *string `json:"url,omitempty"`
	// Path for the CLI destination
	CliPath *string `json:"cli_path,omitempty"`
	// Limit event attempts to receive per period. Max value is workspace plan's max attempts thoughput.
	RateLimit       *int                         `json:"rate_limit,omitempty"`
	RateLimitPeriod *DestinationRateLimitPeriod  `json:"rate_limit_period,omitempty"`
	HttpMethod      *DestinationHttpMethod       `json:"http_method,omitempty"`
	AuthMethod      *DestinationAuthMethodConfig `json:"auth_method,omitempty"`
	// Date the destination was disabled
	DisabledAt *time.Time `json:"disabled_at,omitempty"`
	// Date the destination was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the destination was created
	CreatedAt time.Time `json:"created_at"`
}

// API key config for the destination's auth method
type DestinationAuthMethodApiKeyConfig struct {
	// Key for the API key auth
	Key string `json:"key"`
	// API key for the API key auth
	ApiKey string `json:"api_key"`
	// Whether the API key should be sent as a header or a query parameter
	To *DestinationAuthMethodApiKeyConfigTo `json:"to,omitempty"`
}

// Whether the API key should be sent as a header or a query parameter
type DestinationAuthMethodApiKeyConfigTo string

const (
	DestinationAuthMethodApiKeyConfigToHeader DestinationAuthMethodApiKeyConfigTo = "header"
	DestinationAuthMethodApiKeyConfigToQuery  DestinationAuthMethodApiKeyConfigTo = "query"
)

func NewDestinationAuthMethodApiKeyConfigToFromString(s string) (DestinationAuthMethodApiKeyConfigTo, error) {
	switch s {
	case "header":
		return DestinationAuthMethodApiKeyConfigToHeader, nil
	case "query":
		return DestinationAuthMethodApiKeyConfigToQuery, nil
	}
	var t DestinationAuthMethodApiKeyConfigTo
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DestinationAuthMethodApiKeyConfigTo) Ptr() *DestinationAuthMethodApiKeyConfigTo {
	return &d
}

// Basic auth config for the destination's auth method
type DestinationAuthMethodBasicAuthConfig struct {
	// Username for basic auth
	Username string `json:"username"`
	// Password for basic auth
	Password string `json:"password"`
}

// Bearer token config for the destination's auth method
type DestinationAuthMethodBearerTokenConfig struct {
	// Token for the bearer token auth
	Token string `json:"token"`
}

// Config for the destination's auth method
type DestinationAuthMethodConfig struct {
	Type                    string
	HookdeckSignature       *AuthHookdeckSignature
	BasicAuth               *AuthBasicAuth
	ApiKey                  *AuthApiKey
	BearerToken             *AuthBearerToken
	Oauth2ClientCredentials *AuthOAuth2ClientCredentials
	Oauth2AuthorizationCode *AuthOAuth2AuthorizationCode
	CustomSignature         *AuthCustomSignature
}

func NewDestinationAuthMethodConfigFromHookdeckSignature(value *AuthHookdeckSignature) *DestinationAuthMethodConfig {
	return &DestinationAuthMethodConfig{Type: "HOOKDECK_SIGNATURE", HookdeckSignature: value}
}

func NewDestinationAuthMethodConfigFromBasicAuth(value *AuthBasicAuth) *DestinationAuthMethodConfig {
	return &DestinationAuthMethodConfig{Type: "BASIC_AUTH", BasicAuth: value}
}

func NewDestinationAuthMethodConfigFromApiKey(value *AuthApiKey) *DestinationAuthMethodConfig {
	return &DestinationAuthMethodConfig{Type: "API_KEY", ApiKey: value}
}

func NewDestinationAuthMethodConfigFromBearerToken(value *AuthBearerToken) *DestinationAuthMethodConfig {
	return &DestinationAuthMethodConfig{Type: "BEARER_TOKEN", BearerToken: value}
}

func NewDestinationAuthMethodConfigFromOauth2ClientCredentials(value *AuthOAuth2ClientCredentials) *DestinationAuthMethodConfig {
	return &DestinationAuthMethodConfig{Type: "OAUTH2_CLIENT_CREDENTIALS", Oauth2ClientCredentials: value}
}

func NewDestinationAuthMethodConfigFromOauth2AuthorizationCode(value *AuthOAuth2AuthorizationCode) *DestinationAuthMethodConfig {
	return &DestinationAuthMethodConfig{Type: "OAUTH2_AUTHORIZATION_CODE", Oauth2AuthorizationCode: value}
}

func NewDestinationAuthMethodConfigFromCustomSignature(value *AuthCustomSignature) *DestinationAuthMethodConfig {
	return &DestinationAuthMethodConfig{Type: "CUSTOM_SIGNATURE", CustomSignature: value}
}

func (d *DestinationAuthMethodConfig) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	d.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "HOOKDECK_SIGNATURE":
		value := new(AuthHookdeckSignature)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		d.HookdeckSignature = value
	case "BASIC_AUTH":
		value := new(AuthBasicAuth)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		d.BasicAuth = value
	case "API_KEY":
		value := new(AuthApiKey)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		d.ApiKey = value
	case "BEARER_TOKEN":
		value := new(AuthBearerToken)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		d.BearerToken = value
	case "OAUTH2_CLIENT_CREDENTIALS":
		value := new(AuthOAuth2ClientCredentials)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		d.Oauth2ClientCredentials = value
	case "OAUTH2_AUTHORIZATION_CODE":
		value := new(AuthOAuth2AuthorizationCode)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		d.Oauth2AuthorizationCode = value
	case "CUSTOM_SIGNATURE":
		value := new(AuthCustomSignature)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		d.CustomSignature = value
	}
	return nil
}

func (d DestinationAuthMethodConfig) MarshalJSON() ([]byte, error) {
	switch d.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.Type, d)
	case "HOOKDECK_SIGNATURE":
		var marshaler = struct {
			Type string `json:"type"`
			*AuthHookdeckSignature
		}{
			Type:                  d.Type,
			AuthHookdeckSignature: d.HookdeckSignature,
		}
		return json.Marshal(marshaler)
	case "BASIC_AUTH":
		var marshaler = struct {
			Type string `json:"type"`
			*AuthBasicAuth
		}{
			Type:          d.Type,
			AuthBasicAuth: d.BasicAuth,
		}
		return json.Marshal(marshaler)
	case "API_KEY":
		var marshaler = struct {
			Type string `json:"type"`
			*AuthApiKey
		}{
			Type:       d.Type,
			AuthApiKey: d.ApiKey,
		}
		return json.Marshal(marshaler)
	case "BEARER_TOKEN":
		var marshaler = struct {
			Type string `json:"type"`
			*AuthBearerToken
		}{
			Type:            d.Type,
			AuthBearerToken: d.BearerToken,
		}
		return json.Marshal(marshaler)
	case "OAUTH2_CLIENT_CREDENTIALS":
		var marshaler = struct {
			Type string `json:"type"`
			*AuthOAuth2ClientCredentials
		}{
			Type:                        d.Type,
			AuthOAuth2ClientCredentials: d.Oauth2ClientCredentials,
		}
		return json.Marshal(marshaler)
	case "OAUTH2_AUTHORIZATION_CODE":
		var marshaler = struct {
			Type string `json:"type"`
			*AuthOAuth2AuthorizationCode
		}{
			Type:                        d.Type,
			AuthOAuth2AuthorizationCode: d.Oauth2AuthorizationCode,
		}
		return json.Marshal(marshaler)
	case "CUSTOM_SIGNATURE":
		var marshaler = struct {
			Type string `json:"type"`
			*AuthCustomSignature
		}{
			Type:                d.Type,
			AuthCustomSignature: d.CustomSignature,
		}
		return json.Marshal(marshaler)
	}
}

type DestinationAuthMethodConfigVisitor interface {
	VisitHookdeckSignature(*AuthHookdeckSignature) error
	VisitBasicAuth(*AuthBasicAuth) error
	VisitApiKey(*AuthApiKey) error
	VisitBearerToken(*AuthBearerToken) error
	VisitOauth2ClientCredentials(*AuthOAuth2ClientCredentials) error
	VisitOauth2AuthorizationCode(*AuthOAuth2AuthorizationCode) error
	VisitCustomSignature(*AuthCustomSignature) error
}

func (d *DestinationAuthMethodConfig) Accept(visitor DestinationAuthMethodConfigVisitor) error {
	switch d.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", d.Type, d)
	case "HOOKDECK_SIGNATURE":
		return visitor.VisitHookdeckSignature(d.HookdeckSignature)
	case "BASIC_AUTH":
		return visitor.VisitBasicAuth(d.BasicAuth)
	case "API_KEY":
		return visitor.VisitApiKey(d.ApiKey)
	case "BEARER_TOKEN":
		return visitor.VisitBearerToken(d.BearerToken)
	case "OAUTH2_CLIENT_CREDENTIALS":
		return visitor.VisitOauth2ClientCredentials(d.Oauth2ClientCredentials)
	case "OAUTH2_AUTHORIZATION_CODE":
		return visitor.VisitOauth2AuthorizationCode(d.Oauth2AuthorizationCode)
	case "CUSTOM_SIGNATURE":
		return visitor.VisitCustomSignature(d.CustomSignature)
	}
}

// Custom signature config for the destination's auth method
type DestinationAuthMethodCustomSignatureConfig struct {
	// Key for the custom signature auth
	Key string `json:"key"`
	// Signing secret for the custom signature auth. If left empty a secret will be generated for you.
	SigningSecret *string `json:"signing_secret,omitempty"`
}

// OAuth2 Authorization Code config for the destination's auth method
type DestinationAuthMethodOAuth2AuthorizationCodeConfig struct {
	// Client id in the auth server
	ClientId string `json:"client_id"`
	// Client secret in the auth server
	ClientSecret string `json:"client_secret"`
	// Refresh token already returned by the auth server
	RefreshToken string `json:"refresh_token"`
	// Scope to access
	Scope *string `json:"scope,omitempty"`
	// URL of the auth server
	AuthServer string `json:"auth_server"`
}

// OAuth2 Client Credentials config for the destination's auth method
type DestinationAuthMethodOAuth2ClientCredentialsConfig struct {
	// Client id in the auth server
	ClientId string `json:"client_id"`
	// Client secret in the auth server
	ClientSecret string `json:"client_secret"`
	// Scope to access
	Scope *string `json:"scope,omitempty"`
	// URL of the auth server
	AuthServer string `json:"auth_server"`
}

// Empty config for the destination's auth method
type DestinationAuthMethodSignatureConfig struct {
}

// HTTP method used on requests sent to the destination, overrides the method used on requests sent to the source.
type DestinationHttpMethod string

const (
	DestinationHttpMethodGet    DestinationHttpMethod = "GET"
	DestinationHttpMethodPost   DestinationHttpMethod = "POST"
	DestinationHttpMethodPut    DestinationHttpMethod = "PUT"
	DestinationHttpMethodPatch  DestinationHttpMethod = "PATCH"
	DestinationHttpMethodDelete DestinationHttpMethod = "DELETE"
)

func NewDestinationHttpMethodFromString(s string) (DestinationHttpMethod, error) {
	switch s {
	case "GET":
		return DestinationHttpMethodGet, nil
	case "POST":
		return DestinationHttpMethodPost, nil
	case "PUT":
		return DestinationHttpMethodPut, nil
	case "PATCH":
		return DestinationHttpMethodPatch, nil
	case "DELETE":
		return DestinationHttpMethodDelete, nil
	}
	var t DestinationHttpMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DestinationHttpMethod) Ptr() *DestinationHttpMethod {
	return &d
}

type DestinationPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Destination  `json:"models,omitempty"`
}

// Period to rate limit attempts
type DestinationRateLimitPeriod string

const (
	DestinationRateLimitPeriodSecond     DestinationRateLimitPeriod = "second"
	DestinationRateLimitPeriodMinute     DestinationRateLimitPeriod = "minute"
	DestinationRateLimitPeriodHour       DestinationRateLimitPeriod = "hour"
	DestinationRateLimitPeriodConcurrent DestinationRateLimitPeriod = "concurrent"
)

func NewDestinationRateLimitPeriodFromString(s string) (DestinationRateLimitPeriod, error) {
	switch s {
	case "second":
		return DestinationRateLimitPeriodSecond, nil
	case "minute":
		return DestinationRateLimitPeriodMinute, nil
	case "hour":
		return DestinationRateLimitPeriodHour, nil
	case "concurrent":
		return DestinationRateLimitPeriodConcurrent, nil
	}
	var t DestinationRateLimitPeriod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DestinationRateLimitPeriod) Ptr() *DestinationRateLimitPeriod {
	return &d
}

type DetachedIntegrationFromSource struct {
}

type Event struct {
	// ID of the event
	Id string `json:"id"`
	// ID of the workspace
	TeamId string `json:"team_id"`
	// ID of the associated connection
	WebhookId string `json:"webhook_id"`
	// ID of the associated source
	SourceId string `json:"source_id"`
	// ID of the associated destination
	DestinationId string `json:"destination_id"`
	// ID of the event data
	EventDataId string `json:"event_data_id"`
	// ID of the request that created the event
	RequestId string `json:"request_id"`
	// Number of delivery attempts made
	Attempts int `json:"attempts"`
	// Date of the most recently attempted retry
	LastAttemptAt *time.Time `json:"last_attempt_at,omitempty"`
	// Date of the next scheduled retry
	NextAttemptAt *time.Time `json:"next_attempt_at,omitempty"`
	// Event status
	ResponseStatus *int               `json:"response_status,omitempty"`
	ErrorCode      *AttemptErrorCodes `json:"error_code,omitempty"`
	Status         EventStatus        `json:"status,omitempty"`
	// Date of the latest successful attempt
	SuccessfulAt *time.Time `json:"successful_at,omitempty"`
	// ID of the CLI the event is sent to
	CliId *string `json:"cli_id,omitempty"`
	// Date the event was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the event was created
	CreatedAt time.Time       `json:"created_at"`
	Data      *ShortEventData `json:"data,omitempty"`
}

type EventArray = []*Event

type EventAttempt struct {
	// Attempt ID
	Id string `json:"id"`
	// Team ID
	TeamId string `json:"team_id"`
	// Event ID
	EventId string `json:"event_id"`
	// Attempt's HTTP response code
	ResponseStatus *int `json:"response_status,omitempty"`
	// Sequential number of attempts (up to and including this one) made for the associated event
	AttemptNumber *int               `json:"attempt_number,omitempty"`
	Trigger       *AttemptTrigger    `json:"trigger,omitempty"`
	ErrorCode     *AttemptErrorCodes `json:"error_code,omitempty"`
	Body          *EventAttemptBody  `json:"body,omitempty"`
	// URL of the destination where delivery was attempted
	RequestedUrl *string `json:"requested_url,omitempty"`
	// HTTP method used to deliver the attempt
	HttpMethod *EventAttemptHttpMethod `json:"http_method,omitempty"`
	// ID of associated bulk retry
	BulkRetryId *string       `json:"bulk_retry_id,omitempty"`
	Status      AttemptStatus `json:"status,omitempty"`
	// Date the attempt was successful
	SuccessfulAt *time.Time `json:"successful_at,omitempty"`
	// Date the attempt was delivered
	DeliveredAt *time.Time `json:"delivered_at,omitempty"`
	// Date the destination responded to this attempt
	RespondedAt *time.Time `json:"responded_at,omitempty"`
	// Time elapsed between attempt initiation and final delivery (in ms)
	DeliveryLatency *int `json:"delivery_latency,omitempty"`
	// Time elapsed between attempt initiation and a response from the destination (in ms)
	ResponseLatency *int `json:"response_latency,omitempty"`
	// Date the attempt was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the attempt was created
	CreatedAt     time.Time     `json:"created_at"`
	State         *AttemptState `json:"state,omitempty"`
	DestinationId *string       `json:"destination_id,omitempty"`
}

type EventAttemptBody struct {
	typeName string
	// Response body from the destination
	EventAttemptBodyZeroOptional *EventAttemptBodyZero
	// Response body from the destination
	StringOptional *string
}

func NewEventAttemptBodyFromEventAttemptBodyZeroOptional(value *EventAttemptBodyZero) *EventAttemptBody {
	return &EventAttemptBody{typeName: "eventAttemptBodyZeroOptional", EventAttemptBodyZeroOptional: value}
}

func NewEventAttemptBodyFromStringOptional(value *string) *EventAttemptBody {
	return &EventAttemptBody{typeName: "stringOptional", StringOptional: value}
}

func (e *EventAttemptBody) UnmarshalJSON(data []byte) error {
	var valueEventAttemptBodyZeroOptional *EventAttemptBodyZero
	if err := json.Unmarshal(data, &valueEventAttemptBodyZeroOptional); err == nil {
		e.typeName = "eventAttemptBodyZeroOptional"
		e.EventAttemptBodyZeroOptional = valueEventAttemptBodyZeroOptional
		return nil
	}
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		e.typeName = "stringOptional"
		e.StringOptional = valueStringOptional
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventAttemptBody) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "eventAttemptBodyZeroOptional":
		return json.Marshal(e.EventAttemptBodyZeroOptional)
	case "stringOptional":
		return json.Marshal(e.StringOptional)
	}
}

type EventAttemptBodyVisitor interface {
	VisitEventAttemptBodyZeroOptional(*EventAttemptBodyZero) error
	VisitStringOptional(*string) error
}

func (e *EventAttemptBody) Accept(visitor EventAttemptBodyVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "eventAttemptBodyZeroOptional":
		return visitor.VisitEventAttemptBodyZeroOptional(e.EventAttemptBodyZeroOptional)
	case "stringOptional":
		return visitor.VisitStringOptional(e.StringOptional)
	}
}

// Response body from the destination
type EventAttemptBodyZero struct {
}

// HTTP method used to deliver the attempt
type EventAttemptHttpMethod string

const (
	EventAttemptHttpMethodGet    EventAttemptHttpMethod = "GET"
	EventAttemptHttpMethodPost   EventAttemptHttpMethod = "POST"
	EventAttemptHttpMethodPut    EventAttemptHttpMethod = "PUT"
	EventAttemptHttpMethodPatch  EventAttemptHttpMethod = "PATCH"
	EventAttemptHttpMethodDelete EventAttemptHttpMethod = "DELETE"
)

func NewEventAttemptHttpMethodFromString(s string) (EventAttemptHttpMethod, error) {
	switch s {
	case "GET":
		return EventAttemptHttpMethodGet, nil
	case "POST":
		return EventAttemptHttpMethodPost, nil
	case "PUT":
		return EventAttemptHttpMethodPut, nil
	case "PATCH":
		return EventAttemptHttpMethodPatch, nil
	case "DELETE":
		return EventAttemptHttpMethodDelete, nil
	}
	var t EventAttemptHttpMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventAttemptHttpMethod) Ptr() *EventAttemptHttpMethod {
	return &e
}

type EventAttemptPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*EventAttempt `json:"models,omitempty"`
}

type EventPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Event        `json:"models,omitempty"`
}

type EventStatus string

const (
	EventStatusScheduled  EventStatus = "SCHEDULED"
	EventStatusQueued     EventStatus = "QUEUED"
	EventStatusHold       EventStatus = "HOLD"
	EventStatusSuccessful EventStatus = "SUCCESSFUL"
	EventStatusFailed     EventStatus = "FAILED"
)

func NewEventStatusFromString(s string) (EventStatus, error) {
	switch s {
	case "SCHEDULED":
		return EventStatusScheduled, nil
	case "QUEUED":
		return EventStatusQueued, nil
	case "HOLD":
		return EventStatusHold, nil
	case "SUCCESSFUL":
		return EventStatusSuccessful, nil
	case "FAILED":
		return EventStatusFailed, nil
	}
	var t EventStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventStatus) Ptr() *EventStatus {
	return &e
}

type FilterRule struct {
	Headers *FilterRuleProperty `json:"headers,omitempty"`
	Body    *FilterRuleProperty `json:"body,omitempty"`
	Query   *FilterRuleProperty `json:"query,omitempty"`
	Path    *FilterRuleProperty `json:"path,omitempty"`
	type_   string
}

func (f *FilterRule) Type() string {
	return f.type_
}

func (f *FilterRule) UnmarshalJSON(data []byte) error {
	type unmarshaler FilterRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FilterRule(value)
	f.type_ = "filter"
	return nil
}

func (f *FilterRule) MarshalJSON() ([]byte, error) {
	type embed FilterRule
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*f),
		Type:  "filter",
	}
	return json.Marshal(marshaler)
}

// JSON using our filter syntax to filter on request headers
type FilterRuleProperty struct {
	typeName                 string
	StringOptional           *string
	DoubleOptional           *float64
	BooleanOptional          *bool
	StringUnknownMapOptional map[string]interface{}
}

func NewFilterRulePropertyFromStringOptional(value *string) *FilterRuleProperty {
	return &FilterRuleProperty{typeName: "stringOptional", StringOptional: value}
}

func NewFilterRulePropertyFromDoubleOptional(value *float64) *FilterRuleProperty {
	return &FilterRuleProperty{typeName: "doubleOptional", DoubleOptional: value}
}

func NewFilterRulePropertyFromBooleanOptional(value *bool) *FilterRuleProperty {
	return &FilterRuleProperty{typeName: "booleanOptional", BooleanOptional: value}
}

func NewFilterRulePropertyFromStringUnknownMapOptional(value map[string]interface{}) *FilterRuleProperty {
	return &FilterRuleProperty{typeName: "stringUnknownMapOptional", StringUnknownMapOptional: value}
}

func (f *FilterRuleProperty) UnmarshalJSON(data []byte) error {
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		f.typeName = "stringOptional"
		f.StringOptional = valueStringOptional
		return nil
	}
	var valueDoubleOptional *float64
	if err := json.Unmarshal(data, &valueDoubleOptional); err == nil {
		f.typeName = "doubleOptional"
		f.DoubleOptional = valueDoubleOptional
		return nil
	}
	var valueBooleanOptional *bool
	if err := json.Unmarshal(data, &valueBooleanOptional); err == nil {
		f.typeName = "booleanOptional"
		f.BooleanOptional = valueBooleanOptional
		return nil
	}
	var valueStringUnknownMapOptional map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMapOptional); err == nil {
		f.typeName = "stringUnknownMapOptional"
		f.StringUnknownMapOptional = valueStringUnknownMapOptional
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FilterRuleProperty) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "stringOptional":
		return json.Marshal(f.StringOptional)
	case "doubleOptional":
		return json.Marshal(f.DoubleOptional)
	case "booleanOptional":
		return json.Marshal(f.BooleanOptional)
	case "stringUnknownMapOptional":
		return json.Marshal(f.StringUnknownMapOptional)
	}
}

type FilterRulePropertyVisitor interface {
	VisitStringOptional(*string) error
	VisitDoubleOptional(*float64) error
	VisitBooleanOptional(*bool) error
	VisitStringUnknownMapOptional(map[string]interface{}) error
}

func (f *FilterRuleProperty) Accept(visitor FilterRulePropertyVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "stringOptional":
		return visitor.VisitStringOptional(f.StringOptional)
	case "doubleOptional":
		return visitor.VisitDoubleOptional(f.DoubleOptional)
	case "booleanOptional":
		return visitor.VisitBooleanOptional(f.BooleanOptional)
	case "stringUnknownMapOptional":
		return visitor.VisitStringUnknownMapOptional(f.StringUnknownMapOptional)
	}
}

type FilteredMeta string

const (
	FilteredMetaBody    FilteredMeta = "body"
	FilteredMetaHeaders FilteredMeta = "headers"
	FilteredMetaPath    FilteredMeta = "path"
	FilteredMetaQuery   FilteredMeta = "query"
)

func NewFilteredMetaFromString(s string) (FilteredMeta, error) {
	switch s {
	case "body":
		return FilteredMetaBody, nil
	case "headers":
		return FilteredMetaHeaders, nil
	case "path":
		return FilteredMetaPath, nil
	case "query":
		return FilteredMetaQuery, nil
	}
	var t FilteredMeta
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FilteredMeta) Ptr() *FilteredMeta {
	return &f
}

type HandledApiKeyIntegrationConfigs struct {
	ApiKey string `json:"api_key"`
}

type HandledHmacConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type HmacAlgorithms string

const (
	HmacAlgorithmsMd5    HmacAlgorithms = "md5"
	HmacAlgorithmsSha1   HmacAlgorithms = "sha1"
	HmacAlgorithmsSha256 HmacAlgorithms = "sha256"
	HmacAlgorithmsSha512 HmacAlgorithms = "sha512"
)

func NewHmacAlgorithmsFromString(s string) (HmacAlgorithms, error) {
	switch s {
	case "md5":
		return HmacAlgorithmsMd5, nil
	case "sha1":
		return HmacAlgorithmsSha1, nil
	case "sha256":
		return HmacAlgorithmsSha256, nil
	case "sha512":
		return HmacAlgorithmsSha512, nil
	}
	var t HmacAlgorithms
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HmacAlgorithms) Ptr() *HmacAlgorithms {
	return &h
}

type HmacIntegrationConfigs struct {
	WebhookSecretKey string                         `json:"webhook_secret_key"`
	Algorithm        HmacAlgorithms                 `json:"algorithm,omitempty"`
	HeaderKey        string                         `json:"header_key"`
	Encoding         HmacIntegrationConfigsEncoding `json:"encoding,omitempty"`
}

type HmacIntegrationConfigsEncoding string

const (
	HmacIntegrationConfigsEncodingBase64 HmacIntegrationConfigsEncoding = "base64"
	HmacIntegrationConfigsEncodingHex    HmacIntegrationConfigsEncoding = "hex"
)

func NewHmacIntegrationConfigsEncodingFromString(s string) (HmacIntegrationConfigsEncoding, error) {
	switch s {
	case "base64":
		return HmacIntegrationConfigsEncodingBase64, nil
	case "hex":
		return HmacIntegrationConfigsEncodingHex, nil
	}
	var t HmacIntegrationConfigsEncoding
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HmacIntegrationConfigsEncoding) Ptr() *HmacIntegrationConfigsEncoding {
	return &h
}

type IgnoredEvent struct {
	Id        string            `json:"id"`
	TeamId    string            `json:"team_id"`
	WebhookId string            `json:"webhook_id"`
	Cause     IgnoredEventCause `json:"cause,omitempty"`
	RequestId string            `json:"request_id"`
	Meta      *IgnoredEventMeta `json:"meta,omitempty"`
	UpdatedAt time.Time         `json:"updated_at"`
	CreatedAt time.Time         `json:"created_at"`
}

type IgnoredEventCause string

const (
	IgnoredEventCauseDisabled             IgnoredEventCause = "DISABLED"
	IgnoredEventCauseFiltered             IgnoredEventCause = "FILTERED"
	IgnoredEventCauseTransformationFailed IgnoredEventCause = "TRANSFORMATION_FAILED"
	IgnoredEventCauseCliDisconnected      IgnoredEventCause = "CLI_DISCONNECTED"
)

func NewIgnoredEventCauseFromString(s string) (IgnoredEventCause, error) {
	switch s {
	case "DISABLED":
		return IgnoredEventCauseDisabled, nil
	case "FILTERED":
		return IgnoredEventCauseFiltered, nil
	case "TRANSFORMATION_FAILED":
		return IgnoredEventCauseTransformationFailed, nil
	case "CLI_DISCONNECTED":
		return IgnoredEventCauseCliDisconnected, nil
	}
	var t IgnoredEventCause
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IgnoredEventCause) Ptr() *IgnoredEventCause {
	return &i
}

type IgnoredEventMeta struct {
	typeName                 string
	FilteredMeta             FilteredMeta
	TransformationFailedMeta *TransformationFailedMeta
}

func NewIgnoredEventMetaFromFilteredMeta(value FilteredMeta) *IgnoredEventMeta {
	return &IgnoredEventMeta{typeName: "filteredMeta", FilteredMeta: value}
}

func NewIgnoredEventMetaFromTransformationFailedMeta(value *TransformationFailedMeta) *IgnoredEventMeta {
	return &IgnoredEventMeta{typeName: "transformationFailedMeta", TransformationFailedMeta: value}
}

func (i *IgnoredEventMeta) UnmarshalJSON(data []byte) error {
	var valueFilteredMeta FilteredMeta
	if err := json.Unmarshal(data, &valueFilteredMeta); err == nil {
		i.typeName = "filteredMeta"
		i.FilteredMeta = valueFilteredMeta
		return nil
	}
	valueTransformationFailedMeta := new(TransformationFailedMeta)
	if err := json.Unmarshal(data, &valueTransformationFailedMeta); err == nil {
		i.typeName = "transformationFailedMeta"
		i.TransformationFailedMeta = valueTransformationFailedMeta
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IgnoredEventMeta) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "filteredMeta":
		return json.Marshal(i.FilteredMeta)
	case "transformationFailedMeta":
		return json.Marshal(i.TransformationFailedMeta)
	}
}

type IgnoredEventMetaVisitor interface {
	VisitFilteredMeta(FilteredMeta) error
	VisitTransformationFailedMeta(*TransformationFailedMeta) error
}

func (i *IgnoredEventMeta) Accept(visitor IgnoredEventMetaVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "filteredMeta":
		return visitor.VisitFilteredMeta(i.FilteredMeta)
	case "transformationFailedMeta":
		return visitor.VisitTransformationFailedMeta(i.TransformationFailedMeta)
	}
}

type IgnoredEventPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*IgnoredEvent `json:"models,omitempty"`
}

type Integration struct {
	// ID of the integration
	Id string `json:"id"`
	// ID of the workspace
	TeamId string `json:"team_id"`
	// Label of the integration
	Label    string              `json:"label"`
	Provider IntegrationProvider `json:"provider,omitempty"`
	// List of features to enable (see features list below)
	Features []IntegrationFeature `json:"features,omitempty"`
	// Decrypted Key/Value object of the associated configuration for that provider
	Configs *IntegrationConfigs `json:"configs,omitempty"`
	// List of source IDs the integration is attached to
	Sources []string `json:"sources,omitempty"`
	// Date the integration was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the integration was created
	CreatedAt time.Time `json:"created_at"`
}

// Decrypted Key/Value object of the associated configuration for that provider
type IntegrationConfigs struct {
	typeName                        string
	HmacIntegrationConfigs          *HmacIntegrationConfigs
	ApiKeyIntegrationConfigs        *ApiKeyIntegrationConfigs
	HandledApiKeyIntegrationConfigs *HandledApiKeyIntegrationConfigs
	HandledHmacConfigs              *HandledHmacConfigs
	BasicAuthIntegrationConfigs     *BasicAuthIntegrationConfigs
	ShopifyIntegrationConfigs       *ShopifyIntegrationConfigs
	IntegrationConfigsSix           *IntegrationConfigsSix
}

func NewIntegrationConfigsFromHmacIntegrationConfigs(value *HmacIntegrationConfigs) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "hmacIntegrationConfigs", HmacIntegrationConfigs: value}
}

func NewIntegrationConfigsFromApiKeyIntegrationConfigs(value *ApiKeyIntegrationConfigs) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "apiKeyIntegrationConfigs", ApiKeyIntegrationConfigs: value}
}

func NewIntegrationConfigsFromHandledApiKeyIntegrationConfigs(value *HandledApiKeyIntegrationConfigs) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "handledApiKeyIntegrationConfigs", HandledApiKeyIntegrationConfigs: value}
}

func NewIntegrationConfigsFromHandledHmacConfigs(value *HandledHmacConfigs) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "handledHmacConfigs", HandledHmacConfigs: value}
}

func NewIntegrationConfigsFromBasicAuthIntegrationConfigs(value *BasicAuthIntegrationConfigs) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "basicAuthIntegrationConfigs", BasicAuthIntegrationConfigs: value}
}

func NewIntegrationConfigsFromShopifyIntegrationConfigs(value *ShopifyIntegrationConfigs) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "shopifyIntegrationConfigs", ShopifyIntegrationConfigs: value}
}

func NewIntegrationConfigsFromIntegrationConfigsSix(value *IntegrationConfigsSix) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "integrationConfigsSix", IntegrationConfigsSix: value}
}

func (i *IntegrationConfigs) UnmarshalJSON(data []byte) error {
	valueHmacIntegrationConfigs := new(HmacIntegrationConfigs)
	if err := json.Unmarshal(data, &valueHmacIntegrationConfigs); err == nil {
		i.typeName = "hmacIntegrationConfigs"
		i.HmacIntegrationConfigs = valueHmacIntegrationConfigs
		return nil
	}
	valueApiKeyIntegrationConfigs := new(ApiKeyIntegrationConfigs)
	if err := json.Unmarshal(data, &valueApiKeyIntegrationConfigs); err == nil {
		i.typeName = "apiKeyIntegrationConfigs"
		i.ApiKeyIntegrationConfigs = valueApiKeyIntegrationConfigs
		return nil
	}
	valueHandledApiKeyIntegrationConfigs := new(HandledApiKeyIntegrationConfigs)
	if err := json.Unmarshal(data, &valueHandledApiKeyIntegrationConfigs); err == nil {
		i.typeName = "handledApiKeyIntegrationConfigs"
		i.HandledApiKeyIntegrationConfigs = valueHandledApiKeyIntegrationConfigs
		return nil
	}
	valueHandledHmacConfigs := new(HandledHmacConfigs)
	if err := json.Unmarshal(data, &valueHandledHmacConfigs); err == nil {
		i.typeName = "handledHmacConfigs"
		i.HandledHmacConfigs = valueHandledHmacConfigs
		return nil
	}
	valueBasicAuthIntegrationConfigs := new(BasicAuthIntegrationConfigs)
	if err := json.Unmarshal(data, &valueBasicAuthIntegrationConfigs); err == nil {
		i.typeName = "basicAuthIntegrationConfigs"
		i.BasicAuthIntegrationConfigs = valueBasicAuthIntegrationConfigs
		return nil
	}
	valueShopifyIntegrationConfigs := new(ShopifyIntegrationConfigs)
	if err := json.Unmarshal(data, &valueShopifyIntegrationConfigs); err == nil {
		i.typeName = "shopifyIntegrationConfigs"
		i.ShopifyIntegrationConfigs = valueShopifyIntegrationConfigs
		return nil
	}
	valueIntegrationConfigsSix := new(IntegrationConfigsSix)
	if err := json.Unmarshal(data, &valueIntegrationConfigsSix); err == nil {
		i.typeName = "integrationConfigsSix"
		i.IntegrationConfigsSix = valueIntegrationConfigsSix
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IntegrationConfigs) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "hmacIntegrationConfigs":
		return json.Marshal(i.HmacIntegrationConfigs)
	case "apiKeyIntegrationConfigs":
		return json.Marshal(i.ApiKeyIntegrationConfigs)
	case "handledApiKeyIntegrationConfigs":
		return json.Marshal(i.HandledApiKeyIntegrationConfigs)
	case "handledHmacConfigs":
		return json.Marshal(i.HandledHmacConfigs)
	case "basicAuthIntegrationConfigs":
		return json.Marshal(i.BasicAuthIntegrationConfigs)
	case "shopifyIntegrationConfigs":
		return json.Marshal(i.ShopifyIntegrationConfigs)
	case "integrationConfigsSix":
		return json.Marshal(i.IntegrationConfigsSix)
	}
}

type IntegrationConfigsVisitor interface {
	VisitHmacIntegrationConfigs(*HmacIntegrationConfigs) error
	VisitApiKeyIntegrationConfigs(*ApiKeyIntegrationConfigs) error
	VisitHandledApiKeyIntegrationConfigs(*HandledApiKeyIntegrationConfigs) error
	VisitHandledHmacConfigs(*HandledHmacConfigs) error
	VisitBasicAuthIntegrationConfigs(*BasicAuthIntegrationConfigs) error
	VisitShopifyIntegrationConfigs(*ShopifyIntegrationConfigs) error
	VisitIntegrationConfigsSix(*IntegrationConfigsSix) error
}

func (i *IntegrationConfigs) Accept(visitor IntegrationConfigsVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "hmacIntegrationConfigs":
		return visitor.VisitHmacIntegrationConfigs(i.HmacIntegrationConfigs)
	case "apiKeyIntegrationConfigs":
		return visitor.VisitApiKeyIntegrationConfigs(i.ApiKeyIntegrationConfigs)
	case "handledApiKeyIntegrationConfigs":
		return visitor.VisitHandledApiKeyIntegrationConfigs(i.HandledApiKeyIntegrationConfigs)
	case "handledHmacConfigs":
		return visitor.VisitHandledHmacConfigs(i.HandledHmacConfigs)
	case "basicAuthIntegrationConfigs":
		return visitor.VisitBasicAuthIntegrationConfigs(i.BasicAuthIntegrationConfigs)
	case "shopifyIntegrationConfigs":
		return visitor.VisitShopifyIntegrationConfigs(i.ShopifyIntegrationConfigs)
	case "integrationConfigsSix":
		return visitor.VisitIntegrationConfigsSix(i.IntegrationConfigsSix)
	}
}

type IntegrationConfigsSix struct {
}

type IntegrationFeature string

const (
	IntegrationFeatureVerification IntegrationFeature = "VERIFICATION"
	IntegrationFeatureHandshake    IntegrationFeature = "HANDSHAKE"
)

func NewIntegrationFeatureFromString(s string) (IntegrationFeature, error) {
	switch s {
	case "VERIFICATION":
		return IntegrationFeatureVerification, nil
	case "HANDSHAKE":
		return IntegrationFeatureHandshake, nil
	}
	var t IntegrationFeature
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IntegrationFeature) Ptr() *IntegrationFeature {
	return &i
}

type IntegrationPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Integration  `json:"models,omitempty"`
}

type IntegrationProvider string

const (
	IntegrationProviderHmac           IntegrationProvider = "HMAC"
	IntegrationProviderBasicAuth      IntegrationProvider = "BASIC_AUTH"
	IntegrationProviderApiKey         IntegrationProvider = "API_KEY"
	IntegrationProviderCloudsignal    IntegrationProvider = "CLOUDSIGNAL"
	IntegrationProviderCourier        IntegrationProvider = "COURIER"
	IntegrationProviderFrontapp       IntegrationProvider = "FRONTAPP"
	IntegrationProviderTwitter        IntegrationProvider = "TWITTER"
	IntegrationProviderStripe         IntegrationProvider = "STRIPE"
	IntegrationProviderRecharge       IntegrationProvider = "RECHARGE"
	IntegrationProviderTwilio         IntegrationProvider = "TWILIO"
	IntegrationProviderGithub         IntegrationProvider = "GITHUB"
	IntegrationProviderShopify        IntegrationProvider = "SHOPIFY"
	IntegrationProviderPostmark       IntegrationProvider = "POSTMARK"
	IntegrationProviderTypeform       IntegrationProvider = "TYPEFORM"
	IntegrationProviderXero           IntegrationProvider = "XERO"
	IntegrationProviderSvix           IntegrationProvider = "SVIX"
	IntegrationProviderZoom           IntegrationProvider = "ZOOM"
	IntegrationProviderAkeneo         IntegrationProvider = "AKENEO"
	IntegrationProviderAdyen          IntegrationProvider = "ADYEN"
	IntegrationProviderGitlab         IntegrationProvider = "GITLAB"
	IntegrationProviderPropertyFinder IntegrationProvider = "PROPERTY-FINDER"
	IntegrationProviderWoocommerce    IntegrationProvider = "WOOCOMMERCE"
	IntegrationProviderOura           IntegrationProvider = "OURA"
	IntegrationProviderCommercelayer  IntegrationProvider = "COMMERCELAYER"
	IntegrationProviderHubspot        IntegrationProvider = "HUBSPOT"
	IntegrationProviderMailgun        IntegrationProvider = "MAILGUN"
	IntegrationProviderPersona        IntegrationProvider = "PERSONA"
	IntegrationProviderPipedrive      IntegrationProvider = "PIPEDRIVE"
	IntegrationProviderSendgrid       IntegrationProvider = "SENDGRID"
	IntegrationProviderWorkos         IntegrationProvider = "WORKOS"
	IntegrationProviderSynctera       IntegrationProvider = "SYNCTERA"
	IntegrationProviderAwsSns         IntegrationProvider = "AWS_SNS"
	IntegrationProviderThreeDEye      IntegrationProvider = "THREE_D_EYE"
	IntegrationProviderTwitch         IntegrationProvider = "TWITCH"
	IntegrationProviderEnode          IntegrationProvider = "ENODE"
	IntegrationProviderFavro          IntegrationProvider = "FAVRO"
	IntegrationProviderLinear         IntegrationProvider = "LINEAR"
	IntegrationProviderShopline       IntegrationProvider = "SHOPLINE"
	IntegrationProviderWix            IntegrationProvider = "WIX"
	IntegrationProviderNmi            IntegrationProvider = "NMI"
	IntegrationProviderOrb            IntegrationProvider = "ORB"
	IntegrationProviderPylon          IntegrationProvider = "PYLON"
	IntegrationProviderRepay          IntegrationProvider = "REPAY"
	IntegrationProviderSquare         IntegrationProvider = "SQUARE"
	IntegrationProviderSolidgate      IntegrationProvider = "SOLIDGATE"
	IntegrationProviderTrello         IntegrationProvider = "TRELLO"
	IntegrationProviderSanity         IntegrationProvider = "SANITY"
	IntegrationProviderEbay           IntegrationProvider = "EBAY"
	IntegrationProviderTelnyx         IntegrationProvider = "TELNYX"
	IntegrationProviderTokenio        IntegrationProvider = "TOKENIO"
)

func NewIntegrationProviderFromString(s string) (IntegrationProvider, error) {
	switch s {
	case "HMAC":
		return IntegrationProviderHmac, nil
	case "BASIC_AUTH":
		return IntegrationProviderBasicAuth, nil
	case "API_KEY":
		return IntegrationProviderApiKey, nil
	case "CLOUDSIGNAL":
		return IntegrationProviderCloudsignal, nil
	case "COURIER":
		return IntegrationProviderCourier, nil
	case "FRONTAPP":
		return IntegrationProviderFrontapp, nil
	case "TWITTER":
		return IntegrationProviderTwitter, nil
	case "STRIPE":
		return IntegrationProviderStripe, nil
	case "RECHARGE":
		return IntegrationProviderRecharge, nil
	case "TWILIO":
		return IntegrationProviderTwilio, nil
	case "GITHUB":
		return IntegrationProviderGithub, nil
	case "SHOPIFY":
		return IntegrationProviderShopify, nil
	case "POSTMARK":
		return IntegrationProviderPostmark, nil
	case "TYPEFORM":
		return IntegrationProviderTypeform, nil
	case "XERO":
		return IntegrationProviderXero, nil
	case "SVIX":
		return IntegrationProviderSvix, nil
	case "ZOOM":
		return IntegrationProviderZoom, nil
	case "AKENEO":
		return IntegrationProviderAkeneo, nil
	case "ADYEN":
		return IntegrationProviderAdyen, nil
	case "GITLAB":
		return IntegrationProviderGitlab, nil
	case "PROPERTY-FINDER":
		return IntegrationProviderPropertyFinder, nil
	case "WOOCOMMERCE":
		return IntegrationProviderWoocommerce, nil
	case "OURA":
		return IntegrationProviderOura, nil
	case "COMMERCELAYER":
		return IntegrationProviderCommercelayer, nil
	case "HUBSPOT":
		return IntegrationProviderHubspot, nil
	case "MAILGUN":
		return IntegrationProviderMailgun, nil
	case "PERSONA":
		return IntegrationProviderPersona, nil
	case "PIPEDRIVE":
		return IntegrationProviderPipedrive, nil
	case "SENDGRID":
		return IntegrationProviderSendgrid, nil
	case "WORKOS":
		return IntegrationProviderWorkos, nil
	case "SYNCTERA":
		return IntegrationProviderSynctera, nil
	case "AWS_SNS":
		return IntegrationProviderAwsSns, nil
	case "THREE_D_EYE":
		return IntegrationProviderThreeDEye, nil
	case "TWITCH":
		return IntegrationProviderTwitch, nil
	case "ENODE":
		return IntegrationProviderEnode, nil
	case "FAVRO":
		return IntegrationProviderFavro, nil
	case "LINEAR":
		return IntegrationProviderLinear, nil
	case "SHOPLINE":
		return IntegrationProviderShopline, nil
	case "WIX":
		return IntegrationProviderWix, nil
	case "NMI":
		return IntegrationProviderNmi, nil
	case "ORB":
		return IntegrationProviderOrb, nil
	case "PYLON":
		return IntegrationProviderPylon, nil
	case "REPAY":
		return IntegrationProviderRepay, nil
	case "SQUARE":
		return IntegrationProviderSquare, nil
	case "SOLIDGATE":
		return IntegrationProviderSolidgate, nil
	case "TRELLO":
		return IntegrationProviderTrello, nil
	case "SANITY":
		return IntegrationProviderSanity, nil
	case "EBAY":
		return IntegrationProviderEbay, nil
	case "TELNYX":
		return IntegrationProviderTelnyx, nil
	case "TOKENIO":
		return IntegrationProviderTokenio, nil
	}
	var t IntegrationProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IntegrationProvider) Ptr() *IntegrationProvider {
	return &i
}

// Issue
type Issue struct {
	Type           string
	Delivery       *DeliveryIssue
	Transformation *TransformationIssue
}

func NewIssueFromDelivery(value *DeliveryIssue) *Issue {
	return &Issue{Type: "delivery", Delivery: value}
}

func NewIssueFromTransformation(value *TransformationIssue) *Issue {
	return &Issue{Type: "transformation", Transformation: value}
}

func (i *Issue) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	i.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "delivery":
		value := new(DeliveryIssue)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.Delivery = value
	case "transformation":
		value := new(TransformationIssue)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.Transformation = value
	}
	return nil
}

func (i Issue) MarshalJSON() ([]byte, error) {
	switch i.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.Type, i)
	case "delivery":
		var marshaler = struct {
			Type string `json:"type"`
			*DeliveryIssue
		}{
			Type:          i.Type,
			DeliveryIssue: i.Delivery,
		}
		return json.Marshal(marshaler)
	case "transformation":
		var marshaler = struct {
			Type string `json:"type"`
			*TransformationIssue
		}{
			Type:                i.Type,
			TransformationIssue: i.Transformation,
		}
		return json.Marshal(marshaler)
	}
}

type IssueVisitor interface {
	VisitDelivery(*DeliveryIssue) error
	VisitTransformation(*TransformationIssue) error
}

func (i *Issue) Accept(visitor IssueVisitor) error {
	switch i.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", i.Type, i)
	case "delivery":
		return visitor.VisitDelivery(i.Delivery)
	case "transformation":
		return visitor.VisitTransformation(i.Transformation)
	}
}

type IssueCount struct {
	// Number of issues
	Count int `json:"count"`
}

// Issue status
type IssueStatus string

const (
	IssueStatusOpened       IssueStatus = "OPENED"
	IssueStatusIgnored      IssueStatus = "IGNORED"
	IssueStatusAcknowledged IssueStatus = "ACKNOWLEDGED"
	IssueStatusResolved     IssueStatus = "RESOLVED"
)

func NewIssueStatusFromString(s string) (IssueStatus, error) {
	switch s {
	case "OPENED":
		return IssueStatusOpened, nil
	case "IGNORED":
		return IssueStatusIgnored, nil
	case "ACKNOWLEDGED":
		return IssueStatusAcknowledged, nil
	case "RESOLVED":
		return IssueStatusResolved, nil
	}
	var t IssueStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueStatus) Ptr() *IssueStatus {
	return &i
}

type IssueTrigger struct {
	// ID of the issue trigger
	Id string `json:"id"`
	// ID of the workspace
	TeamId *string `json:"team_id,omitempty"`
	// Optional unique name to use as reference when using the API
	Name     *string                `json:"name,omitempty"`
	Type     IssueType              `json:"type,omitempty"`
	Configs  *IssueTriggerReference `json:"configs,omitempty"`
	Channels *IssueTriggerChannels  `json:"channels,omitempty"`
	// ISO timestamp for when the issue trigger was disabled
	DisabledAt *time.Time `json:"disabled_at,omitempty"`
	// ISO timestamp for when the issue trigger was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// ISO timestamp for when the issue trigger was created
	CreatedAt time.Time `json:"created_at"`
	// ISO timestamp for when the issue trigger was deleted
	DeletedAt *time.Time `json:"deleted_at,omitempty"`
}

// Configurations for a 'Backpressure' issue trigger
type IssueTriggerBackpressureConfigs struct {
	Delay IssueTriggerBackpressureDelay `json:"delay"`
	// A pattern to match on the destination name or array of destination IDs. Use `*` as wildcard.
	Destinations *IssueTriggerBackpressureConfigsDestinations `json:"destinations,omitempty"`
}

// A pattern to match on the destination name or array of destination IDs. Use `*` as wildcard.
type IssueTriggerBackpressureConfigsDestinations struct {
	typeName   string
	String     string
	StringList []string
}

func NewIssueTriggerBackpressureConfigsDestinationsFromString(value string) *IssueTriggerBackpressureConfigsDestinations {
	return &IssueTriggerBackpressureConfigsDestinations{typeName: "string", String: value}
}

func NewIssueTriggerBackpressureConfigsDestinationsFromStringList(value []string) *IssueTriggerBackpressureConfigsDestinations {
	return &IssueTriggerBackpressureConfigsDestinations{typeName: "stringList", StringList: value}
}

func (i *IssueTriggerBackpressureConfigsDestinations) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		i.typeName = "stringList"
		i.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerBackpressureConfigsDestinations) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "stringList":
		return json.Marshal(i.StringList)
	}
}

type IssueTriggerBackpressureConfigsDestinationsVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (i *IssueTriggerBackpressureConfigsDestinations) Accept(visitor IssueTriggerBackpressureConfigsDestinationsVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "stringList":
		return visitor.VisitStringList(i.StringList)
	}
}

// The minimum delay (backpressure) to open the issue for min of 1 minute (60000) and max of 1 day (86400000)
type IssueTriggerBackpressureDelay = int

// Notification channels object for the specific channel type
type IssueTriggerChannels struct {
	Slack    *IssueTriggerSlackChannel       `json:"slack,omitempty"`
	Opsgenie *IssueTriggerIntegrationChannel `json:"opsgenie,omitempty"`
	Email    *IssueTriggerEmailChannel       `json:"email,omitempty"`
}

// Configurations for a 'delivery' issue trigger
type IssueTriggerDeliveryConfigs struct {
	Strategy IssueTriggerStrategy `json:"strategy,omitempty"`
	// A pattern to match on the connection name or array of connection IDs. Use `*` as wildcard.
	Connections *IssueTriggerDeliveryConfigsConnections `json:"connections,omitempty"`
}

// A pattern to match on the connection name or array of connection IDs. Use `*` as wildcard.
type IssueTriggerDeliveryConfigsConnections struct {
	typeName   string
	String     string
	StringList []string
}

func NewIssueTriggerDeliveryConfigsConnectionsFromString(value string) *IssueTriggerDeliveryConfigsConnections {
	return &IssueTriggerDeliveryConfigsConnections{typeName: "string", String: value}
}

func NewIssueTriggerDeliveryConfigsConnectionsFromStringList(value []string) *IssueTriggerDeliveryConfigsConnections {
	return &IssueTriggerDeliveryConfigsConnections{typeName: "stringList", StringList: value}
}

func (i *IssueTriggerDeliveryConfigsConnections) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		i.typeName = "stringList"
		i.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerDeliveryConfigsConnections) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "stringList":
		return json.Marshal(i.StringList)
	}
}

type IssueTriggerDeliveryConfigsConnectionsVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (i *IssueTriggerDeliveryConfigsConnections) Accept(visitor IssueTriggerDeliveryConfigsConnectionsVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "stringList":
		return visitor.VisitStringList(i.StringList)
	}
}

// Email channel for an issue trigger
type IssueTriggerEmailChannel struct {
}

// Integration channel for an issue trigger
type IssueTriggerIntegrationChannel struct {
}

type IssueTriggerPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*IssueTrigger `json:"models,omitempty"`
}

// Configuration object for the specific issue type selected
type IssueTriggerReference struct {
	typeName                          string
	IssueTriggerDeliveryConfigs       *IssueTriggerDeliveryConfigs
	IssueTriggerTransformationConfigs *IssueTriggerTransformationConfigs
	IssueTriggerBackpressureConfigs   *IssueTriggerBackpressureConfigs
}

func NewIssueTriggerReferenceFromIssueTriggerDeliveryConfigs(value *IssueTriggerDeliveryConfigs) *IssueTriggerReference {
	return &IssueTriggerReference{typeName: "issueTriggerDeliveryConfigs", IssueTriggerDeliveryConfigs: value}
}

func NewIssueTriggerReferenceFromIssueTriggerTransformationConfigs(value *IssueTriggerTransformationConfigs) *IssueTriggerReference {
	return &IssueTriggerReference{typeName: "issueTriggerTransformationConfigs", IssueTriggerTransformationConfigs: value}
}

func NewIssueTriggerReferenceFromIssueTriggerBackpressureConfigs(value *IssueTriggerBackpressureConfigs) *IssueTriggerReference {
	return &IssueTriggerReference{typeName: "issueTriggerBackpressureConfigs", IssueTriggerBackpressureConfigs: value}
}

func (i *IssueTriggerReference) UnmarshalJSON(data []byte) error {
	valueIssueTriggerDeliveryConfigs := new(IssueTriggerDeliveryConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerDeliveryConfigs); err == nil {
		i.typeName = "issueTriggerDeliveryConfigs"
		i.IssueTriggerDeliveryConfigs = valueIssueTriggerDeliveryConfigs
		return nil
	}
	valueIssueTriggerTransformationConfigs := new(IssueTriggerTransformationConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerTransformationConfigs); err == nil {
		i.typeName = "issueTriggerTransformationConfigs"
		i.IssueTriggerTransformationConfigs = valueIssueTriggerTransformationConfigs
		return nil
	}
	valueIssueTriggerBackpressureConfigs := new(IssueTriggerBackpressureConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerBackpressureConfigs); err == nil {
		i.typeName = "issueTriggerBackpressureConfigs"
		i.IssueTriggerBackpressureConfigs = valueIssueTriggerBackpressureConfigs
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerReference) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueTriggerDeliveryConfigs":
		return json.Marshal(i.IssueTriggerDeliveryConfigs)
	case "issueTriggerTransformationConfigs":
		return json.Marshal(i.IssueTriggerTransformationConfigs)
	case "issueTriggerBackpressureConfigs":
		return json.Marshal(i.IssueTriggerBackpressureConfigs)
	}
}

type IssueTriggerReferenceVisitor interface {
	VisitIssueTriggerDeliveryConfigs(*IssueTriggerDeliveryConfigs) error
	VisitIssueTriggerTransformationConfigs(*IssueTriggerTransformationConfigs) error
	VisitIssueTriggerBackpressureConfigs(*IssueTriggerBackpressureConfigs) error
}

func (i *IssueTriggerReference) Accept(visitor IssueTriggerReferenceVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueTriggerDeliveryConfigs":
		return visitor.VisitIssueTriggerDeliveryConfigs(i.IssueTriggerDeliveryConfigs)
	case "issueTriggerTransformationConfigs":
		return visitor.VisitIssueTriggerTransformationConfigs(i.IssueTriggerTransformationConfigs)
	case "issueTriggerBackpressureConfigs":
		return visitor.VisitIssueTriggerBackpressureConfigs(i.IssueTriggerBackpressureConfigs)
	}
}

// Slack channel for an issue trigger
type IssueTriggerSlackChannel struct {
	// Channel name
	ChannelName string `json:"channel_name"`
}

// The strategy uses to open the issue
type IssueTriggerStrategy string

const (
	IssueTriggerStrategyFirstAttempt IssueTriggerStrategy = "first_attempt"
	IssueTriggerStrategyFinalAttempt IssueTriggerStrategy = "final_attempt"
)

func NewIssueTriggerStrategyFromString(s string) (IssueTriggerStrategy, error) {
	switch s {
	case "first_attempt":
		return IssueTriggerStrategyFirstAttempt, nil
	case "final_attempt":
		return IssueTriggerStrategyFinalAttempt, nil
	}
	var t IssueTriggerStrategy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueTriggerStrategy) Ptr() *IssueTriggerStrategy {
	return &i
}

// Configurations for a 'Transformation' issue trigger
type IssueTriggerTransformationConfigs struct {
	LogLevel TransformationExecutionLogLevel `json:"log_level,omitempty"`
	// A pattern to match on the transformation name or array of transformation IDs. Use `*` as wildcard.
	Transformations *IssueTriggerTransformationConfigsTransformations `json:"transformations,omitempty"`
}

// A pattern to match on the transformation name or array of transformation IDs. Use `*` as wildcard.
type IssueTriggerTransformationConfigsTransformations struct {
	typeName   string
	String     string
	StringList []string
}

func NewIssueTriggerTransformationConfigsTransformationsFromString(value string) *IssueTriggerTransformationConfigsTransformations {
	return &IssueTriggerTransformationConfigsTransformations{typeName: "string", String: value}
}

func NewIssueTriggerTransformationConfigsTransformationsFromStringList(value []string) *IssueTriggerTransformationConfigsTransformations {
	return &IssueTriggerTransformationConfigsTransformations{typeName: "stringList", StringList: value}
}

func (i *IssueTriggerTransformationConfigsTransformations) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		i.typeName = "stringList"
		i.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerTransformationConfigsTransformations) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "stringList":
		return json.Marshal(i.StringList)
	}
}

type IssueTriggerTransformationConfigsTransformationsVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (i *IssueTriggerTransformationConfigsTransformations) Accept(visitor IssueTriggerTransformationConfigsTransformationsVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "stringList":
		return visitor.VisitStringList(i.StringList)
	}
}

// Issue type
type IssueType string

const (
	IssueTypeDelivery       IssueType = "delivery"
	IssueTypeTransformation IssueType = "transformation"
	IssueTypeBackpressure   IssueType = "backpressure"
)

func NewIssueTypeFromString(s string) (IssueType, error) {
	switch s {
	case "delivery":
		return IssueTypeDelivery, nil
	case "transformation":
		return IssueTypeTransformation, nil
	case "backpressure":
		return IssueTypeBackpressure, nil
	}
	var t IssueType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueType) Ptr() *IssueType {
	return &i
}

type IssueWithData struct {
	Type           string
	Delivery       *DeliveryIssueWithData
	Transformation *TransformationIssueWithData
}

func NewIssueWithDataFromDelivery(value *DeliveryIssueWithData) *IssueWithData {
	return &IssueWithData{Type: "delivery", Delivery: value}
}

func NewIssueWithDataFromTransformation(value *TransformationIssueWithData) *IssueWithData {
	return &IssueWithData{Type: "transformation", Transformation: value}
}

func (i *IssueWithData) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	i.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "delivery":
		value := new(DeliveryIssueWithData)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.Delivery = value
	case "transformation":
		value := new(TransformationIssueWithData)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.Transformation = value
	}
	return nil
}

func (i IssueWithData) MarshalJSON() ([]byte, error) {
	switch i.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.Type, i)
	case "delivery":
		var marshaler = struct {
			Type string `json:"type"`
			*DeliveryIssueWithData
		}{
			Type:                  i.Type,
			DeliveryIssueWithData: i.Delivery,
		}
		return json.Marshal(marshaler)
	case "transformation":
		var marshaler = struct {
			Type string `json:"type"`
			*TransformationIssueWithData
		}{
			Type:                        i.Type,
			TransformationIssueWithData: i.Transformation,
		}
		return json.Marshal(marshaler)
	}
}

type IssueWithDataVisitor interface {
	VisitDelivery(*DeliveryIssueWithData) error
	VisitTransformation(*TransformationIssueWithData) error
}

func (i *IssueWithData) Accept(visitor IssueWithDataVisitor) error {
	switch i.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", i.Type, i)
	case "delivery":
		return visitor.VisitDelivery(i.Delivery)
	case "transformation":
		return visitor.VisitTransformation(i.Transformation)
	}
}

type IssueWithDataPaginatedResult struct {
	Pagination *SeekPagination  `json:"pagination,omitempty"`
	Count      *int             `json:"count,omitempty"`
	Models     []*IssueWithData `json:"models,omitempty"`
}

type ListCustomDomainSchema = []*ListCustomDomainSchemaItem

type ListCustomDomainSchemaItem struct {
	Id                    *string                                          `json:"id,omitempty"`
	Hostname              *string                                          `json:"hostname,omitempty"`
	Status                *string                                          `json:"status,omitempty"`
	Ssl                   *ListCustomDomainSchemaItemSsl                   `json:"ssl,omitempty"`
	VerificationErrors    []string                                         `json:"verification_errors,omitempty"`
	OwnershipVerification *ListCustomDomainSchemaItemOwnershipVerification `json:"ownership_verification,omitempty"`
	CreatedAt             *string                                          `json:"created_at,omitempty"`
}

type ListCustomDomainSchemaItemOwnershipVerification struct {
	Type  *string `json:"type,omitempty"`
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

type ListCustomDomainSchemaItemSsl struct {
	Id                   *string                                                  `json:"id,omitempty"`
	Type                 *string                                                  `json:"type,omitempty"`
	Method               *string                                                  `json:"method,omitempty"`
	Status               *string                                                  `json:"status,omitempty"`
	TxtName              *string                                                  `json:"txt_name,omitempty"`
	TxtValue             *string                                                  `json:"txt_value,omitempty"`
	ValidationRecords    []*ListCustomDomainSchemaItemSslValidationRecordsItem    `json:"validation_records,omitempty"`
	DcvDelegationRecords []*ListCustomDomainSchemaItemSslDcvDelegationRecordsItem `json:"dcv_delegation_records,omitempty"`
	Settings             *ListCustomDomainSchemaItemSslSettings                   `json:"settings,omitempty"`
	BundleMethod         *string                                                  `json:"bundle_method,omitempty"`
	Wildcard             *bool                                                    `json:"wildcard,omitempty"`
	CertificateAuthority *string                                                  `json:"certificate_authority,omitempty"`
}

type ListCustomDomainSchemaItemSslDcvDelegationRecordsItem struct {
	Cname       *string `json:"cname,omitempty"`
	CnameTarget *string `json:"cname_target,omitempty"`
}

type ListCustomDomainSchemaItemSslSettings struct {
	MinTlsVersion *string `json:"min_tls_version,omitempty"`
}

type ListCustomDomainSchemaItemSslValidationRecordsItem struct {
	Status   *string `json:"status,omitempty"`
	TxtName  *string `json:"txt_name,omitempty"`
	TxtValue *string `json:"txt_value,omitempty"`
}

type OrderByDirection string

const (
	OrderByDirectionAsc  OrderByDirection = "asc"
	OrderByDirectionDesc OrderByDirection = "desc"
)

func NewOrderByDirectionFromString(s string) (OrderByDirection, error) {
	switch s {
	case "asc":
		return OrderByDirectionAsc, nil
	case "desc":
		return OrderByDirectionDesc, nil
	}
	var t OrderByDirection
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderByDirection) Ptr() *OrderByDirection {
	return &o
}

type RawBody struct {
	Body string `json:"body"`
}

type Request struct {
	// ID of the request
	Id string `json:"id"`
	// ID of the workspace
	TeamId string `json:"team_id"`
	// Whether or not the request was verified when received
	Verified *bool `json:"verified,omitempty"`
	// ID of the request data
	OriginalEventDataId *string               `json:"original_event_data_id,omitempty"`
	RejectionCause      RequestRejectionCause `json:"rejection_cause,omitempty"`
	// The priority attributed to the request when received
	IngestPriority *RequestIngestPriority `json:"ingest_priority,omitempty"`
	// The time the request was originally received
	IngestedAt *time.Time `json:"ingested_at,omitempty"`
	// ID of the associated source
	SourceId string `json:"source_id"`
	// The count of events created from this request (CLI events not included)
	EventsCount *int `json:"events_count,omitempty"`
	// The count of CLI events created from this request
	CliEventsCount *int `json:"cli_events_count,omitempty"`
	IgnoredCount   *int `json:"ignored_count,omitempty"`
	// Date the event was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the event was created
	CreatedAt time.Time       `json:"created_at"`
	Data      *ShortEventData `json:"data,omitempty"`
}

// The priority attributed to the request when received
type RequestIngestPriority string

const (
	RequestIngestPriorityNormal RequestIngestPriority = "NORMAL"
	RequestIngestPriorityLow    RequestIngestPriority = "LOW"
)

func NewRequestIngestPriorityFromString(s string) (RequestIngestPriority, error) {
	switch s {
	case "NORMAL":
		return RequestIngestPriorityNormal, nil
	case "LOW":
		return RequestIngestPriorityLow, nil
	}
	var t RequestIngestPriority
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestIngestPriority) Ptr() *RequestIngestPriority {
	return &r
}

type RequestPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Request      `json:"models,omitempty"`
}

type RequestRejectionCause string

const (
	RequestRejectionCauseSourceDisabled         RequestRejectionCause = "SOURCE_DISABLED"
	RequestRejectionCauseNoConnection           RequestRejectionCause = "NO_CONNECTION"
	RequestRejectionCauseVerificationFailed     RequestRejectionCause = "VERIFICATION_FAILED"
	RequestRejectionCauseUnsupportedHttpMethod  RequestRejectionCause = "UNSUPPORTED_HTTP_METHOD"
	RequestRejectionCauseUnsupportedContentType RequestRejectionCause = "UNSUPPORTED_CONTENT_TYPE"
	RequestRejectionCauseUnparsableJson         RequestRejectionCause = "UNPARSABLE_JSON"
	RequestRejectionCausePayloadTooLarge        RequestRejectionCause = "PAYLOAD_TOO_LARGE"
	RequestRejectionCauseIngestionFatal         RequestRejectionCause = "INGESTION_FATAL"
	RequestRejectionCauseUnknown                RequestRejectionCause = "UNKNOWN"
)

func NewRequestRejectionCauseFromString(s string) (RequestRejectionCause, error) {
	switch s {
	case "SOURCE_DISABLED":
		return RequestRejectionCauseSourceDisabled, nil
	case "NO_CONNECTION":
		return RequestRejectionCauseNoConnection, nil
	case "VERIFICATION_FAILED":
		return RequestRejectionCauseVerificationFailed, nil
	case "UNSUPPORTED_HTTP_METHOD":
		return RequestRejectionCauseUnsupportedHttpMethod, nil
	case "UNSUPPORTED_CONTENT_TYPE":
		return RequestRejectionCauseUnsupportedContentType, nil
	case "UNPARSABLE_JSON":
		return RequestRejectionCauseUnparsableJson, nil
	case "PAYLOAD_TOO_LARGE":
		return RequestRejectionCausePayloadTooLarge, nil
	case "INGESTION_FATAL":
		return RequestRejectionCauseIngestionFatal, nil
	case "UNKNOWN":
		return RequestRejectionCauseUnknown, nil
	}
	var t RequestRejectionCause
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestRejectionCause) Ptr() *RequestRejectionCause {
	return &r
}

type RetriedEvent struct {
	Event   *Event        `json:"event,omitempty"`
	Attempt *EventAttempt `json:"attempt,omitempty"`
}

type RetryRequest struct {
	Request *Request `json:"request,omitempty"`
	Events  []*Event `json:"events,omitempty"`
}

type RetryRule struct {
	Strategy RetryStrategy `json:"strategy,omitempty"`
	// Time in MS between each retry
	Interval *int `json:"interval,omitempty"`
	// Maximum number of retries to attempt
	Count *int `json:"count,omitempty"`
	type_ string
}

func (r *RetryRule) Type() string {
	return r.type_
}

func (r *RetryRule) UnmarshalJSON(data []byte) error {
	type unmarshaler RetryRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetryRule(value)
	r.type_ = "retry"
	return nil
}

func (r *RetryRule) MarshalJSON() ([]byte, error) {
	type embed RetryRule
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
		Type:  "retry",
	}
	return json.Marshal(marshaler)
}

// Algorithm to use when calculating delay between retries
type RetryStrategy string

const (
	RetryStrategyLinear      RetryStrategy = "linear"
	RetryStrategyExponential RetryStrategy = "exponential"
)

func NewRetryStrategyFromString(s string) (RetryStrategy, error) {
	switch s {
	case "linear":
		return RetryStrategyLinear, nil
	case "exponential":
		return RetryStrategyExponential, nil
	}
	var t RetryStrategy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RetryStrategy) Ptr() *RetryStrategy {
	return &r
}

type Rule struct {
	typeName      string
	RetryRule     *RetryRule
	FilterRule    *FilterRule
	TransformRule *TransformRule
	DelayRule     *DelayRule
}

func NewRuleFromRetryRule(value *RetryRule) *Rule {
	return &Rule{typeName: "retryRule", RetryRule: value}
}

func NewRuleFromFilterRule(value *FilterRule) *Rule {
	return &Rule{typeName: "filterRule", FilterRule: value}
}

func NewRuleFromTransformRule(value *TransformRule) *Rule {
	return &Rule{typeName: "transformRule", TransformRule: value}
}

func NewRuleFromDelayRule(value *DelayRule) *Rule {
	return &Rule{typeName: "delayRule", DelayRule: value}
}

func (r *Rule) UnmarshalJSON(data []byte) error {
	valueRetryRule := new(RetryRule)
	if err := json.Unmarshal(data, &valueRetryRule); err == nil {
		r.typeName = "retryRule"
		r.RetryRule = valueRetryRule
		return nil
	}
	valueFilterRule := new(FilterRule)
	if err := json.Unmarshal(data, &valueFilterRule); err == nil {
		r.typeName = "filterRule"
		r.FilterRule = valueFilterRule
		return nil
	}
	valueTransformRule := new(TransformRule)
	if err := json.Unmarshal(data, &valueTransformRule); err == nil {
		r.typeName = "transformRule"
		r.TransformRule = valueTransformRule
		return nil
	}
	valueDelayRule := new(DelayRule)
	if err := json.Unmarshal(data, &valueDelayRule); err == nil {
		r.typeName = "delayRule"
		r.DelayRule = valueDelayRule
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r Rule) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "retryRule":
		return json.Marshal(r.RetryRule)
	case "filterRule":
		return json.Marshal(r.FilterRule)
	case "transformRule":
		return json.Marshal(r.TransformRule)
	case "delayRule":
		return json.Marshal(r.DelayRule)
	}
}

type RuleVisitor interface {
	VisitRetryRule(*RetryRule) error
	VisitFilterRule(*FilterRule) error
	VisitTransformRule(*TransformRule) error
	VisitDelayRule(*DelayRule) error
}

func (r *Rule) Accept(visitor RuleVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "retryRule":
		return visitor.VisitRetryRule(r.RetryRule)
	case "filterRule":
		return visitor.VisitFilterRule(r.FilterRule)
	case "transformRule":
		return visitor.VisitTransformRule(r.TransformRule)
	case "delayRule":
		return visitor.VisitDelayRule(r.DelayRule)
	}
}

type SeekPagination struct {
	OrderBy *SeekPaginationOrderBy `json:"order_by,omitempty"`
	Dir     *SeekPaginationDir     `json:"dir,omitempty"`
	Limit   *int                   `json:"limit,omitempty"`
	Prev    *string                `json:"prev,omitempty"`
	Next    *string                `json:"next,omitempty"`
}

type SeekPaginationDir struct {
	typeName             string
	OrderByDirection     OrderByDirection
	OrderByDirectionList []OrderByDirection
}

func NewSeekPaginationDirFromOrderByDirection(value OrderByDirection) *SeekPaginationDir {
	return &SeekPaginationDir{typeName: "orderByDirection", OrderByDirection: value}
}

func NewSeekPaginationDirFromOrderByDirectionList(value []OrderByDirection) *SeekPaginationDir {
	return &SeekPaginationDir{typeName: "orderByDirectionList", OrderByDirectionList: value}
}

func (s *SeekPaginationDir) UnmarshalJSON(data []byte) error {
	var valueOrderByDirection OrderByDirection
	if err := json.Unmarshal(data, &valueOrderByDirection); err == nil {
		s.typeName = "orderByDirection"
		s.OrderByDirection = valueOrderByDirection
		return nil
	}
	var valueOrderByDirectionList []OrderByDirection
	if err := json.Unmarshal(data, &valueOrderByDirectionList); err == nil {
		s.typeName = "orderByDirectionList"
		s.OrderByDirectionList = valueOrderByDirectionList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SeekPaginationDir) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "orderByDirection":
		return json.Marshal(s.OrderByDirection)
	case "orderByDirectionList":
		return json.Marshal(s.OrderByDirectionList)
	}
}

type SeekPaginationDirVisitor interface {
	VisitOrderByDirection(OrderByDirection) error
	VisitOrderByDirectionList([]OrderByDirection) error
}

func (s *SeekPaginationDir) Accept(visitor SeekPaginationDirVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "orderByDirection":
		return visitor.VisitOrderByDirection(s.OrderByDirection)
	case "orderByDirectionList":
		return visitor.VisitOrderByDirectionList(s.OrderByDirectionList)
	}
}

type SeekPaginationOrderBy struct {
	typeName   string
	String     string
	StringList []string
}

func NewSeekPaginationOrderByFromString(value string) *SeekPaginationOrderBy {
	return &SeekPaginationOrderBy{typeName: "string", String: value}
}

func NewSeekPaginationOrderByFromStringList(value []string) *SeekPaginationOrderBy {
	return &SeekPaginationOrderBy{typeName: "stringList", StringList: value}
}

func (s *SeekPaginationOrderBy) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typeName = "string"
		s.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		s.typeName = "stringList"
		s.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SeekPaginationOrderBy) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return json.Marshal(s.String)
	case "stringList":
		return json.Marshal(s.StringList)
	}
}

type SeekPaginationOrderByVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (s *SeekPaginationOrderBy) Accept(visitor SeekPaginationOrderByVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return visitor.VisitString(s.String)
	case "stringList":
		return visitor.VisitStringList(s.StringList)
	}
}

type ShopifyIntegrationConfigs struct {
	WebhookSecretKey string                                    `json:"webhook_secret_key"`
	RateLimitPeriod  *ShopifyIntegrationConfigsRateLimitPeriod `json:"rate_limit_period,omitempty"`
	RateLimit        *float64                                  `json:"rate_limit,omitempty"`
	ApiKey           *string                                   `json:"api_key,omitempty"`
	ApiSecret        *string                                   `json:"api_secret,omitempty"`
	Shop             *string                                   `json:"shop,omitempty"`
}

type ShopifyIntegrationConfigsRateLimitPeriod string

const (
	ShopifyIntegrationConfigsRateLimitPeriodMinute ShopifyIntegrationConfigsRateLimitPeriod = "minute"
	ShopifyIntegrationConfigsRateLimitPeriodSecond ShopifyIntegrationConfigsRateLimitPeriod = "second"
)

func NewShopifyIntegrationConfigsRateLimitPeriodFromString(s string) (ShopifyIntegrationConfigsRateLimitPeriod, error) {
	switch s {
	case "minute":
		return ShopifyIntegrationConfigsRateLimitPeriodMinute, nil
	case "second":
		return ShopifyIntegrationConfigsRateLimitPeriodSecond, nil
	}
	var t ShopifyIntegrationConfigsRateLimitPeriod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ShopifyIntegrationConfigsRateLimitPeriod) Ptr() *ShopifyIntegrationConfigsRateLimitPeriod {
	return &s
}

// Request data
type ShortEventData struct {
	// Request path
	Path string `json:"path"`
	// Raw query param string
	Query *string `json:"query,omitempty"`
	// JSON representation of query params
	ParsedQuery *ShortEventDataParsedQuery `json:"parsed_query,omitempty"`
	// JSON representation of the headers
	Headers *ShortEventDataHeaders `json:"headers,omitempty"`
	// JSON or string representation of the body
	Body *ShortEventDataBody `json:"body,omitempty"`
	// Whether the payload is considered large payload and not searchable
	IsLargePayload *bool `json:"is_large_payload,omitempty"`
}

// JSON or string representation of the body
type ShortEventDataBody struct {
	typeName              string
	String                string
	ShortEventDataBodyOne *ShortEventDataBodyOne
	UnknownList           []interface{}
}

func NewShortEventDataBodyFromString(value string) *ShortEventDataBody {
	return &ShortEventDataBody{typeName: "string", String: value}
}

func NewShortEventDataBodyFromShortEventDataBodyOne(value *ShortEventDataBodyOne) *ShortEventDataBody {
	return &ShortEventDataBody{typeName: "shortEventDataBodyOne", ShortEventDataBodyOne: value}
}

func NewShortEventDataBodyFromUnknownList(value []interface{}) *ShortEventDataBody {
	return &ShortEventDataBody{typeName: "unknownList", UnknownList: value}
}

func (s *ShortEventDataBody) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typeName = "string"
		s.String = valueString
		return nil
	}
	valueShortEventDataBodyOne := new(ShortEventDataBodyOne)
	if err := json.Unmarshal(data, &valueShortEventDataBodyOne); err == nil {
		s.typeName = "shortEventDataBodyOne"
		s.ShortEventDataBodyOne = valueShortEventDataBodyOne
		return nil
	}
	var valueUnknownList []interface{}
	if err := json.Unmarshal(data, &valueUnknownList); err == nil {
		s.typeName = "unknownList"
		s.UnknownList = valueUnknownList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ShortEventDataBody) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return json.Marshal(s.String)
	case "shortEventDataBodyOne":
		return json.Marshal(s.ShortEventDataBodyOne)
	case "unknownList":
		return json.Marshal(s.UnknownList)
	}
}

type ShortEventDataBodyVisitor interface {
	VisitString(string) error
	VisitShortEventDataBodyOne(*ShortEventDataBodyOne) error
	VisitUnknownList([]interface{}) error
}

func (s *ShortEventDataBody) Accept(visitor ShortEventDataBodyVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return visitor.VisitString(s.String)
	case "shortEventDataBodyOne":
		return visitor.VisitShortEventDataBodyOne(s.ShortEventDataBodyOne)
	case "unknownList":
		return visitor.VisitUnknownList(s.UnknownList)
	}
}

type ShortEventDataBodyOne struct {
}

// JSON representation of the headers
type ShortEventDataHeaders struct {
	typeName                string
	String                  string
	StringStringOptionalMap map[string]*string
}

func NewShortEventDataHeadersFromString(value string) *ShortEventDataHeaders {
	return &ShortEventDataHeaders{typeName: "string", String: value}
}

func NewShortEventDataHeadersFromStringStringOptionalMap(value map[string]*string) *ShortEventDataHeaders {
	return &ShortEventDataHeaders{typeName: "stringStringOptionalMap", StringStringOptionalMap: value}
}

func (s *ShortEventDataHeaders) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typeName = "string"
		s.String = valueString
		return nil
	}
	var valueStringStringOptionalMap map[string]*string
	if err := json.Unmarshal(data, &valueStringStringOptionalMap); err == nil {
		s.typeName = "stringStringOptionalMap"
		s.StringStringOptionalMap = valueStringStringOptionalMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ShortEventDataHeaders) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return json.Marshal(s.String)
	case "stringStringOptionalMap":
		return json.Marshal(s.StringStringOptionalMap)
	}
}

type ShortEventDataHeadersVisitor interface {
	VisitString(string) error
	VisitStringStringOptionalMap(map[string]*string) error
}

func (s *ShortEventDataHeaders) Accept(visitor ShortEventDataHeadersVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return visitor.VisitString(s.String)
	case "stringStringOptionalMap":
		return visitor.VisitStringStringOptionalMap(s.StringStringOptionalMap)
	}
}

// JSON representation of query params
type ShortEventDataParsedQuery struct {
	typeName                     string
	StringOptional               *string
	ShortEventDataParsedQueryOne *ShortEventDataParsedQueryOne
}

func NewShortEventDataParsedQueryFromStringOptional(value *string) *ShortEventDataParsedQuery {
	return &ShortEventDataParsedQuery{typeName: "stringOptional", StringOptional: value}
}

func NewShortEventDataParsedQueryFromShortEventDataParsedQueryOne(value *ShortEventDataParsedQueryOne) *ShortEventDataParsedQuery {
	return &ShortEventDataParsedQuery{typeName: "shortEventDataParsedQueryOne", ShortEventDataParsedQueryOne: value}
}

func (s *ShortEventDataParsedQuery) UnmarshalJSON(data []byte) error {
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		s.typeName = "stringOptional"
		s.StringOptional = valueStringOptional
		return nil
	}
	valueShortEventDataParsedQueryOne := new(ShortEventDataParsedQueryOne)
	if err := json.Unmarshal(data, &valueShortEventDataParsedQueryOne); err == nil {
		s.typeName = "shortEventDataParsedQueryOne"
		s.ShortEventDataParsedQueryOne = valueShortEventDataParsedQueryOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ShortEventDataParsedQuery) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "stringOptional":
		return json.Marshal(s.StringOptional)
	case "shortEventDataParsedQueryOne":
		return json.Marshal(s.ShortEventDataParsedQueryOne)
	}
}

type ShortEventDataParsedQueryVisitor interface {
	VisitStringOptional(*string) error
	VisitShortEventDataParsedQueryOne(*ShortEventDataParsedQueryOne) error
}

func (s *ShortEventDataParsedQuery) Accept(visitor ShortEventDataParsedQueryVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "stringOptional":
		return visitor.VisitStringOptional(s.StringOptional)
	case "shortEventDataParsedQueryOne":
		return visitor.VisitShortEventDataParsedQueryOne(s.ShortEventDataParsedQueryOne)
	}
}

type ShortEventDataParsedQueryOne struct {
}

// Associated [Source](#source-object) object
type Source struct {
	// ID of the source
	Id string `json:"id"`
	// Name for the source
	Name string `json:"name"`
	// Description of the source
	Description *string `json:"description,omitempty"`
	// ID of the workspace
	TeamId string `json:"team_id"`
	// A unique URL that must be supplied to your webhook's provider
	Url                string                   `json:"url"`
	Verification       *SourceVerification      `json:"verification,omitempty"`
	AllowedHttpMethods *SourceAllowedHttpMethod `json:"allowed_http_methods,omitempty"`
	CustomResponse     *SourceCustomResponse    `json:"custom_response,omitempty"`
	// Date the source was disabled
	DisabledAt *time.Time `json:"disabled_at,omitempty"`
	// Date the source was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the source was created
	CreatedAt time.Time `json:"created_at"`
}

// List of allowed HTTP methods. Defaults to PUT, POST, PATCH, DELETE.
type SourceAllowedHttpMethod = []SourceAllowedHttpMethodItem

type SourceAllowedHttpMethodItem string

const (
	SourceAllowedHttpMethodItemGet    SourceAllowedHttpMethodItem = "GET"
	SourceAllowedHttpMethodItemPost   SourceAllowedHttpMethodItem = "POST"
	SourceAllowedHttpMethodItemPut    SourceAllowedHttpMethodItem = "PUT"
	SourceAllowedHttpMethodItemPatch  SourceAllowedHttpMethodItem = "PATCH"
	SourceAllowedHttpMethodItemDelete SourceAllowedHttpMethodItem = "DELETE"
)

func NewSourceAllowedHttpMethodItemFromString(s string) (SourceAllowedHttpMethodItem, error) {
	switch s {
	case "GET":
		return SourceAllowedHttpMethodItemGet, nil
	case "POST":
		return SourceAllowedHttpMethodItemPost, nil
	case "PUT":
		return SourceAllowedHttpMethodItemPut, nil
	case "PATCH":
		return SourceAllowedHttpMethodItemPatch, nil
	case "DELETE":
		return SourceAllowedHttpMethodItemDelete, nil
	}
	var t SourceAllowedHttpMethodItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SourceAllowedHttpMethodItem) Ptr() *SourceAllowedHttpMethodItem {
	return &s
}

// Custom response object
type SourceCustomResponse struct {
	ContentType SourceCustomResponseContentType `json:"content_type,omitempty"`
	// Body of the custom response
	Body string `json:"body"`
}

// Content type of the custom response
type SourceCustomResponseContentType string

const (
	SourceCustomResponseContentTypeJson SourceCustomResponseContentType = "json"
	SourceCustomResponseContentTypeText SourceCustomResponseContentType = "text"
	SourceCustomResponseContentTypeXml  SourceCustomResponseContentType = "xml"
)

func NewSourceCustomResponseContentTypeFromString(s string) (SourceCustomResponseContentType, error) {
	switch s {
	case "json":
		return SourceCustomResponseContentTypeJson, nil
	case "text":
		return SourceCustomResponseContentTypeText, nil
	case "xml":
		return SourceCustomResponseContentTypeXml, nil
	}
	var t SourceCustomResponseContentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SourceCustomResponseContentType) Ptr() *SourceCustomResponseContentType {
	return &s
}

type SourcePaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Source       `json:"models,omitempty"`
}

type SourceVerification struct {
	typeName              string
	VerificationConfig    *VerificationConfig
	SourceVerificationOne *SourceVerificationOne
}

func NewSourceVerificationFromVerificationConfig(value *VerificationConfig) *SourceVerification {
	return &SourceVerification{typeName: "verificationConfig", VerificationConfig: value}
}

func NewSourceVerificationFromSourceVerificationOne(value *SourceVerificationOne) *SourceVerification {
	return &SourceVerification{typeName: "sourceVerificationOne", SourceVerificationOne: value}
}

func (s *SourceVerification) UnmarshalJSON(data []byte) error {
	valueVerificationConfig := new(VerificationConfig)
	if err := json.Unmarshal(data, &valueVerificationConfig); err == nil {
		s.typeName = "verificationConfig"
		s.VerificationConfig = valueVerificationConfig
		return nil
	}
	valueSourceVerificationOne := new(SourceVerificationOne)
	if err := json.Unmarshal(data, &valueSourceVerificationOne); err == nil {
		s.typeName = "sourceVerificationOne"
		s.SourceVerificationOne = valueSourceVerificationOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SourceVerification) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "verificationConfig":
		return json.Marshal(s.VerificationConfig)
	case "sourceVerificationOne":
		return json.Marshal(s.SourceVerificationOne)
	}
}

type SourceVerificationVisitor interface {
	VisitVerificationConfig(*VerificationConfig) error
	VisitSourceVerificationOne(*SourceVerificationOne) error
}

func (s *SourceVerification) Accept(visitor SourceVerificationVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "verificationConfig":
		return visitor.VisitVerificationConfig(s.VerificationConfig)
	case "sourceVerificationOne":
		return visitor.VisitSourceVerificationOne(s.SourceVerificationOne)
	}
}

type SourceVerificationOne struct {
}

type ToggleWebhookNotifications struct {
	Enabled  bool          `json:"enabled"`
	Topics   []TopicsValue `json:"topics,omitempty"`
	SourceId string        `json:"source_id"`
}

// Supported topics
type TopicsValue string

const (
	TopicsValueIssueOpened             TopicsValue = "issue.opened"
	TopicsValueIssueUpdated            TopicsValue = "issue.updated"
	TopicsValueDeprecatedAttemptFailed TopicsValue = "deprecated.attempt-failed"
	TopicsValueEventSuccessful         TopicsValue = "event.successful"
)

func NewTopicsValueFromString(s string) (TopicsValue, error) {
	switch s {
	case "issue.opened":
		return TopicsValueIssueOpened, nil
	case "issue.updated":
		return TopicsValueIssueUpdated, nil
	case "deprecated.attempt-failed":
		return TopicsValueDeprecatedAttemptFailed, nil
	case "event.successful":
		return TopicsValueEventSuccessful, nil
	}
	var t TopicsValue
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TopicsValue) Ptr() *TopicsValue {
	return &t
}

type TransformFull struct {
	// ID of the attached transformation object. Optional input, always set once the rule is defined
	TransformationId *string `json:"transformation_id,omitempty"`
	// You can optionally define a new transformation while creating a transform rule
	Transformation *TransformFullTransformation `json:"transformation,omitempty"`
	type_          string
}

func (t *TransformFull) Type() string {
	return t.type_
}

func (t *TransformFull) UnmarshalJSON(data []byte) error {
	type unmarshaler TransformFull
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransformFull(value)
	t.type_ = "transform"
	return nil
}

func (t *TransformFull) MarshalJSON() ([]byte, error) {
	type embed TransformFull
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "transform",
	}
	return json.Marshal(marshaler)
}

// You can optionally define a new transformation while creating a transform rule
type TransformFullTransformation struct {
	// The unique name of the transformation
	Name string `json:"name"`
	// A string representation of your JavaScript (ES6) code to run
	Code string `json:"code"`
	// A key-value object of environment variables to encrypt and expose to your transformation code
	Env map[string]*string `json:"env,omitempty"`
}

type TransformReference struct {
	// ID of the attached transformation object. Optional input, always set once the rule is defined
	TransformationId string `json:"transformation_id"`
	type_            string
}

func (t *TransformReference) Type() string {
	return t.type_
}

func (t *TransformReference) UnmarshalJSON(data []byte) error {
	type unmarshaler TransformReference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransformReference(value)
	t.type_ = "transform"
	return nil
}

func (t *TransformReference) MarshalJSON() ([]byte, error) {
	type embed TransformReference
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "transform",
	}
	return json.Marshal(marshaler)
}

type TransformRule struct {
	typeName           string
	TransformReference *TransformReference
	TransformFull      *TransformFull
}

func NewTransformRuleFromTransformReference(value *TransformReference) *TransformRule {
	return &TransformRule{typeName: "transformReference", TransformReference: value}
}

func NewTransformRuleFromTransformFull(value *TransformFull) *TransformRule {
	return &TransformRule{typeName: "transformFull", TransformFull: value}
}

func (t *TransformRule) UnmarshalJSON(data []byte) error {
	valueTransformReference := new(TransformReference)
	if err := json.Unmarshal(data, &valueTransformReference); err == nil {
		t.typeName = "transformReference"
		t.TransformReference = valueTransformReference
		return nil
	}
	valueTransformFull := new(TransformFull)
	if err := json.Unmarshal(data, &valueTransformFull); err == nil {
		t.typeName = "transformFull"
		t.TransformFull = valueTransformFull
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransformRule) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transformReference":
		return json.Marshal(t.TransformReference)
	case "transformFull":
		return json.Marshal(t.TransformFull)
	}
}

type TransformRuleVisitor interface {
	VisitTransformReference(*TransformReference) error
	VisitTransformFull(*TransformFull) error
}

func (t *TransformRule) Accept(visitor TransformRuleVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transformReference":
		return visitor.VisitTransformReference(t.TransformReference)
	case "transformFull":
		return visitor.VisitTransformFull(t.TransformFull)
	}
}

type Transformation struct {
	// ID of the transformation
	Id string `json:"id"`
	// ID of the workspace
	TeamId string `json:"team_id"`
	// A unique, human-friendly name for the transformation
	Name string `json:"name"`
	// JavaScript code to be executed
	Code         string  `json:"code"`
	EncryptedEnv *string `json:"encrypted_env,omitempty"`
	Iv           *string `json:"iv,omitempty"`
	// Key-value environment variables to be passed to the transformation
	Env map[string]*string `json:"env,omitempty"`
	// Date the transformation was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the transformation was created
	CreatedAt time.Time `json:"created_at"`
}

type TransformationExecution struct {
	Id                     string                          `json:"id"`
	TransformedEventDataId string                          `json:"transformed_event_data_id"`
	OriginalEventDataId    string                          `json:"original_event_data_id"`
	TransformationId       string                          `json:"transformation_id"`
	TeamId                 string                          `json:"team_id"`
	WebhookId              string                          `json:"webhook_id"`
	LogLevel               TransformationExecutionLogLevel `json:"log_level,omitempty"`
	Logs                   []*ConsoleLine                  `json:"logs,omitempty"`
	UpdatedAt              time.Time                       `json:"updated_at"`
	CreatedAt              time.Time                       `json:"created_at"`
	OriginalEventData      *ShortEventData                 `json:"original_event_data,omitempty"`
	TransformedEventData   *ShortEventData                 `json:"transformed_event_data,omitempty"`
	IssueId                *string                         `json:"issue_id,omitempty"`
}

// The minimum log level to open the issue on
type TransformationExecutionLogLevel string

const (
	TransformationExecutionLogLevelDebug TransformationExecutionLogLevel = "debug"
	TransformationExecutionLogLevelInfo  TransformationExecutionLogLevel = "info"
	TransformationExecutionLogLevelWarn  TransformationExecutionLogLevel = "warn"
	TransformationExecutionLogLevelError TransformationExecutionLogLevel = "error"
	TransformationExecutionLogLevelFatal TransformationExecutionLogLevel = "fatal"
)

func NewTransformationExecutionLogLevelFromString(s string) (TransformationExecutionLogLevel, error) {
	switch s {
	case "debug":
		return TransformationExecutionLogLevelDebug, nil
	case "info":
		return TransformationExecutionLogLevelInfo, nil
	case "warn":
		return TransformationExecutionLogLevelWarn, nil
	case "error":
		return TransformationExecutionLogLevelError, nil
	case "fatal":
		return TransformationExecutionLogLevelFatal, nil
	}
	var t TransformationExecutionLogLevel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransformationExecutionLogLevel) Ptr() *TransformationExecutionLogLevel {
	return &t
}

type TransformationExecutionPaginatedResult struct {
	Pagination *SeekPagination            `json:"pagination,omitempty"`
	Count      *int                       `json:"count,omitempty"`
	Models     []*TransformationExecution `json:"models,omitempty"`
}

type TransformationExecutorOutput struct {
	RequestId        *string                              `json:"request_id,omitempty"`
	TransformationId *string                              `json:"transformation_id,omitempty"`
	ExecutionId      *string                              `json:"execution_id,omitempty"`
	LogLevel         TransformationExecutionLogLevel      `json:"log_level,omitempty"`
	Request          *TransformationExecutorOutputRequest `json:"request,omitempty"`
	Console          []*ConsoleLine                       `json:"console,omitempty"`
}

type TransformationExecutorOutputRequest struct {
	Headers     *TransformationExecutorOutputRequestHeaders     `json:"headers,omitempty"`
	Path        string                                          `json:"path"`
	Query       *TransformationExecutorOutputRequestQuery       `json:"query,omitempty"`
	ParsedQuery *TransformationExecutorOutputRequestParsedQuery `json:"parsed_query,omitempty"`
	Body        *TransformationExecutorOutputRequestBody        `json:"body,omitempty"`
}

type TransformationExecutorOutputRequestBody struct {
	typeName                                   string
	StringOptional                             *string
	TransformationExecutorOutputRequestBodyOne *TransformationExecutorOutputRequestBodyOne
}

func NewTransformationExecutorOutputRequestBodyFromStringOptional(value *string) *TransformationExecutorOutputRequestBody {
	return &TransformationExecutorOutputRequestBody{typeName: "stringOptional", StringOptional: value}
}

func NewTransformationExecutorOutputRequestBodyFromTransformationExecutorOutputRequestBodyOne(value *TransformationExecutorOutputRequestBodyOne) *TransformationExecutorOutputRequestBody {
	return &TransformationExecutorOutputRequestBody{typeName: "transformationExecutorOutputRequestBodyOne", TransformationExecutorOutputRequestBodyOne: value}
}

func (t *TransformationExecutorOutputRequestBody) UnmarshalJSON(data []byte) error {
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		t.typeName = "stringOptional"
		t.StringOptional = valueStringOptional
		return nil
	}
	valueTransformationExecutorOutputRequestBodyOne := new(TransformationExecutorOutputRequestBodyOne)
	if err := json.Unmarshal(data, &valueTransformationExecutorOutputRequestBodyOne); err == nil {
		t.typeName = "transformationExecutorOutputRequestBodyOne"
		t.TransformationExecutorOutputRequestBodyOne = valueTransformationExecutorOutputRequestBodyOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransformationExecutorOutputRequestBody) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "stringOptional":
		return json.Marshal(t.StringOptional)
	case "transformationExecutorOutputRequestBodyOne":
		return json.Marshal(t.TransformationExecutorOutputRequestBodyOne)
	}
}

type TransformationExecutorOutputRequestBodyVisitor interface {
	VisitStringOptional(*string) error
	VisitTransformationExecutorOutputRequestBodyOne(*TransformationExecutorOutputRequestBodyOne) error
}

func (t *TransformationExecutorOutputRequestBody) Accept(visitor TransformationExecutorOutputRequestBodyVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "stringOptional":
		return visitor.VisitStringOptional(t.StringOptional)
	case "transformationExecutorOutputRequestBodyOne":
		return visitor.VisitTransformationExecutorOutputRequestBodyOne(t.TransformationExecutorOutputRequestBodyOne)
	}
}

type TransformationExecutorOutputRequestBodyOne struct {
}

type TransformationExecutorOutputRequestHeaders struct {
	typeName         string
	String           string
	StringUnknownMap map[string]interface{}
}

func NewTransformationExecutorOutputRequestHeadersFromString(value string) *TransformationExecutorOutputRequestHeaders {
	return &TransformationExecutorOutputRequestHeaders{typeName: "string", String: value}
}

func NewTransformationExecutorOutputRequestHeadersFromStringUnknownMap(value map[string]interface{}) *TransformationExecutorOutputRequestHeaders {
	return &TransformationExecutorOutputRequestHeaders{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func (t *TransformationExecutorOutputRequestHeaders) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		t.typeName = "stringUnknownMap"
		t.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransformationExecutorOutputRequestHeaders) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "stringUnknownMap":
		return json.Marshal(t.StringUnknownMap)
	}
}

type TransformationExecutorOutputRequestHeadersVisitor interface {
	VisitString(string) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (t *TransformationExecutorOutputRequestHeaders) Accept(visitor TransformationExecutorOutputRequestHeadersVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(t.StringUnknownMap)
	}
}

type TransformationExecutorOutputRequestParsedQuery struct {
	typeName                                          string
	StringOptional                                    *string
	TransformationExecutorOutputRequestParsedQueryOne *TransformationExecutorOutputRequestParsedQueryOne
}

func NewTransformationExecutorOutputRequestParsedQueryFromStringOptional(value *string) *TransformationExecutorOutputRequestParsedQuery {
	return &TransformationExecutorOutputRequestParsedQuery{typeName: "stringOptional", StringOptional: value}
}

func NewTransformationExecutorOutputRequestParsedQueryFromTransformationExecutorOutputRequestParsedQueryOne(value *TransformationExecutorOutputRequestParsedQueryOne) *TransformationExecutorOutputRequestParsedQuery {
	return &TransformationExecutorOutputRequestParsedQuery{typeName: "transformationExecutorOutputRequestParsedQueryOne", TransformationExecutorOutputRequestParsedQueryOne: value}
}

func (t *TransformationExecutorOutputRequestParsedQuery) UnmarshalJSON(data []byte) error {
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		t.typeName = "stringOptional"
		t.StringOptional = valueStringOptional
		return nil
	}
	valueTransformationExecutorOutputRequestParsedQueryOne := new(TransformationExecutorOutputRequestParsedQueryOne)
	if err := json.Unmarshal(data, &valueTransformationExecutorOutputRequestParsedQueryOne); err == nil {
		t.typeName = "transformationExecutorOutputRequestParsedQueryOne"
		t.TransformationExecutorOutputRequestParsedQueryOne = valueTransformationExecutorOutputRequestParsedQueryOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransformationExecutorOutputRequestParsedQuery) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "stringOptional":
		return json.Marshal(t.StringOptional)
	case "transformationExecutorOutputRequestParsedQueryOne":
		return json.Marshal(t.TransformationExecutorOutputRequestParsedQueryOne)
	}
}

type TransformationExecutorOutputRequestParsedQueryVisitor interface {
	VisitStringOptional(*string) error
	VisitTransformationExecutorOutputRequestParsedQueryOne(*TransformationExecutorOutputRequestParsedQueryOne) error
}

func (t *TransformationExecutorOutputRequestParsedQuery) Accept(visitor TransformationExecutorOutputRequestParsedQueryVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "stringOptional":
		return visitor.VisitStringOptional(t.StringOptional)
	case "transformationExecutorOutputRequestParsedQueryOne":
		return visitor.VisitTransformationExecutorOutputRequestParsedQueryOne(t.TransformationExecutorOutputRequestParsedQueryOne)
	}
}

type TransformationExecutorOutputRequestParsedQueryOne struct {
}

type TransformationExecutorOutputRequestQuery struct {
	typeName                                             string
	TransformationExecutorOutputRequestQueryZeroOptional *TransformationExecutorOutputRequestQueryZero
	String                                               string
}

func NewTransformationExecutorOutputRequestQueryFromTransformationExecutorOutputRequestQueryZeroOptional(value *TransformationExecutorOutputRequestQueryZero) *TransformationExecutorOutputRequestQuery {
	return &TransformationExecutorOutputRequestQuery{typeName: "transformationExecutorOutputRequestQueryZeroOptional", TransformationExecutorOutputRequestQueryZeroOptional: value}
}

func NewTransformationExecutorOutputRequestQueryFromString(value string) *TransformationExecutorOutputRequestQuery {
	return &TransformationExecutorOutputRequestQuery{typeName: "string", String: value}
}

func (t *TransformationExecutorOutputRequestQuery) UnmarshalJSON(data []byte) error {
	var valueTransformationExecutorOutputRequestQueryZeroOptional *TransformationExecutorOutputRequestQueryZero
	if err := json.Unmarshal(data, &valueTransformationExecutorOutputRequestQueryZeroOptional); err == nil {
		t.typeName = "transformationExecutorOutputRequestQueryZeroOptional"
		t.TransformationExecutorOutputRequestQueryZeroOptional = valueTransformationExecutorOutputRequestQueryZeroOptional
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransformationExecutorOutputRequestQuery) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transformationExecutorOutputRequestQueryZeroOptional":
		return json.Marshal(t.TransformationExecutorOutputRequestQueryZeroOptional)
	case "string":
		return json.Marshal(t.String)
	}
}

type TransformationExecutorOutputRequestQueryVisitor interface {
	VisitTransformationExecutorOutputRequestQueryZeroOptional(*TransformationExecutorOutputRequestQueryZero) error
	VisitString(string) error
}

func (t *TransformationExecutorOutputRequestQuery) Accept(visitor TransformationExecutorOutputRequestQueryVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transformationExecutorOutputRequestQueryZeroOptional":
		return visitor.VisitTransformationExecutorOutputRequestQueryZeroOptional(t.TransformationExecutorOutputRequestQueryZeroOptional)
	case "string":
		return visitor.VisitString(t.String)
	}
}

type TransformationExecutorOutputRequestQueryZero struct {
}

type TransformationFailedMeta struct {
	TransformationId string `json:"transformation_id"`
}

// Transformation issue
type TransformationIssue struct {
	// Issue ID
	Id string `json:"id"`
	// ID of the workspace
	TeamId string      `json:"team_id"`
	Status IssueStatus `json:"status,omitempty"`
	// ISO timestamp for when the issue was last opened
	OpenedAt time.Time `json:"opened_at"`
	// ISO timestamp for when the issue was first opened
	FirstSeenAt time.Time `json:"first_seen_at"`
	// ISO timestamp for when the issue last occured
	LastSeenAt time.Time `json:"last_seen_at"`
	// Deprecated, will always be set to null
	LastUpdatedBy *string `json:"last_updated_by,omitempty"`
	// ISO timestamp for when the issue was dismissed
	DismissedAt    *time.Time `json:"dismissed_at,omitempty"`
	AutoResolvedAt *time.Time `json:"auto_resolved_at,omitempty"`
	MergedWith     *string    `json:"merged_with,omitempty"`
	// ISO timestamp for when the issue was last updated
	UpdatedAt string `json:"updated_at"`
	// ISO timestamp for when the issue was created
	CreatedAt       string                              `json:"created_at"`
	AggregationKeys *TransformationIssueAggregationKeys `json:"aggregation_keys,omitempty"`
	Reference       *TransformationIssueReference       `json:"reference,omitempty"`
}

// Keys used as the aggregation keys a 'transformation' type issue
type TransformationIssueAggregationKeys struct {
	TransformationId []string                        `json:"transformation_id,omitempty"`
	LogLevel         TransformationExecutionLogLevel `json:"log_level,omitempty"`
}

// Transformation issue data
type TransformationIssueData struct {
	TransformationExecution *TransformationExecution `json:"transformation_execution,omitempty"`
	TriggerAttempt          *EventAttempt            `json:"trigger_attempt,omitempty"`
}

// Reference to the event request transformation an issue is being created for.
type TransformationIssueReference struct {
	TransformationExecutionId string `json:"transformation_execution_id"`
	// Deprecated but still found on historical issues
	TriggerEventRequestTransformationId *string `json:"trigger_event_request_transformation_id,omitempty"`
}

// Transformation issue
type TransformationIssueWithData struct {
	// Issue ID
	Id string `json:"id"`
	// ID of the workspace
	TeamId string      `json:"team_id"`
	Status IssueStatus `json:"status,omitempty"`
	// ISO timestamp for when the issue was last opened
	OpenedAt time.Time `json:"opened_at"`
	// ISO timestamp for when the issue was first opened
	FirstSeenAt time.Time `json:"first_seen_at"`
	// ISO timestamp for when the issue last occured
	LastSeenAt time.Time `json:"last_seen_at"`
	// Deprecated, will always be set to null
	LastUpdatedBy *string `json:"last_updated_by,omitempty"`
	// ISO timestamp for when the issue was dismissed
	DismissedAt    *time.Time `json:"dismissed_at,omitempty"`
	AutoResolvedAt *time.Time `json:"auto_resolved_at,omitempty"`
	MergedWith     *string    `json:"merged_with,omitempty"`
	// ISO timestamp for when the issue was last updated
	UpdatedAt string `json:"updated_at"`
	// ISO timestamp for when the issue was created
	CreatedAt       string                              `json:"created_at"`
	AggregationKeys *TransformationIssueAggregationKeys `json:"aggregation_keys,omitempty"`
	Reference       *TransformationIssueReference       `json:"reference,omitempty"`
	Data            *TransformationIssueData            `json:"data,omitempty"`
}

type TransformationPaginatedResult struct {
	Pagination *SeekPagination   `json:"pagination,omitempty"`
	Count      *int              `json:"count,omitempty"`
	Models     []*Transformation `json:"models,omitempty"`
}

type Verification3DEye struct {
	Type    Verification3DEyeType     `json:"type,omitempty"`
	Configs *Verification3DEyeConfigs `json:"configs,omitempty"`
}

// The verification configs for 3dEye. Only included if the ?include=verification.configs query param is present
type Verification3DEyeConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type Verification3DEyeType string

const (
	Verification3DEyeTypeThreeDEye Verification3DEyeType = "three_d_eye"
)

func NewVerification3DEyeTypeFromString(s string) (Verification3DEyeType, error) {
	switch s {
	case "three_d_eye":
		return Verification3DEyeTypeThreeDEye, nil
	}
	var t Verification3DEyeType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v Verification3DEyeType) Ptr() *Verification3DEyeType {
	return &v
}

type VerificationAdyen struct {
	Type    VerificationAdyenType     `json:"type,omitempty"`
	Configs *VerificationAdyenConfigs `json:"configs,omitempty"`
}

// The verification configs for Adyen. Only included if the ?include=verification.configs query param is present
type VerificationAdyenConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationAdyenType string

const (
	VerificationAdyenTypeAdyen VerificationAdyenType = "adyen"
)

func NewVerificationAdyenTypeFromString(s string) (VerificationAdyenType, error) {
	switch s {
	case "adyen":
		return VerificationAdyenTypeAdyen, nil
	}
	var t VerificationAdyenType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationAdyenType) Ptr() *VerificationAdyenType {
	return &v
}

type VerificationAkeneo struct {
	Type    VerificationAkeneoType     `json:"type,omitempty"`
	Configs *VerificationAkeneoConfigs `json:"configs,omitempty"`
}

// The verification configs for Akeneo. Only included if the ?include=verification.configs query param is present
type VerificationAkeneoConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationAkeneoType string

const (
	VerificationAkeneoTypeAkeneo VerificationAkeneoType = "akeneo"
)

func NewVerificationAkeneoTypeFromString(s string) (VerificationAkeneoType, error) {
	switch s {
	case "akeneo":
		return VerificationAkeneoTypeAkeneo, nil
	}
	var t VerificationAkeneoType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationAkeneoType) Ptr() *VerificationAkeneoType {
	return &v
}

type VerificationApiKey struct {
	Type    VerificationApiKeyType     `json:"type,omitempty"`
	Configs *VerificationApiKeyConfigs `json:"configs,omitempty"`
}

// The verification configs for API Key. Only included if the ?include=verification.configs query param is present
type VerificationApiKeyConfigs struct {
	HeaderKey string `json:"header_key"`
	ApiKey    string `json:"api_key"`
}

type VerificationApiKeyType string

const (
	VerificationApiKeyTypeApiKey VerificationApiKeyType = "api_key"
)

func NewVerificationApiKeyTypeFromString(s string) (VerificationApiKeyType, error) {
	switch s {
	case "api_key":
		return VerificationApiKeyTypeApiKey, nil
	}
	var t VerificationApiKeyType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationApiKeyType) Ptr() *VerificationApiKeyType {
	return &v
}

type VerificationAwssns struct {
	Type    VerificationAwssnsType     `json:"type,omitempty"`
	Configs *VerificationAwssnsConfigs `json:"configs,omitempty"`
}

// The verification configs for AWS SNS. Only included if the ?include=verification.configs query param is present
type VerificationAwssnsConfigs struct {
}

type VerificationAwssnsType string

const (
	VerificationAwssnsTypeAwsSns VerificationAwssnsType = "aws_sns"
)

func NewVerificationAwssnsTypeFromString(s string) (VerificationAwssnsType, error) {
	switch s {
	case "aws_sns":
		return VerificationAwssnsTypeAwsSns, nil
	}
	var t VerificationAwssnsType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationAwssnsType) Ptr() *VerificationAwssnsType {
	return &v
}

type VerificationBasicAuth struct {
	Type    VerificationBasicAuthType     `json:"type,omitempty"`
	Configs *VerificationBasicAuthConfigs `json:"configs,omitempty"`
}

// The verification configs for Basic Auth. Only included if the ?include=verification.configs query param is present
type VerificationBasicAuthConfigs struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

type VerificationBasicAuthType string

const (
	VerificationBasicAuthTypeBasicAuth VerificationBasicAuthType = "basic_auth"
)

func NewVerificationBasicAuthTypeFromString(s string) (VerificationBasicAuthType, error) {
	switch s {
	case "basic_auth":
		return VerificationBasicAuthTypeBasicAuth, nil
	}
	var t VerificationBasicAuthType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationBasicAuthType) Ptr() *VerificationBasicAuthType {
	return &v
}

type VerificationCloudSignal struct {
	Type    VerificationCloudSignalType     `json:"type,omitempty"`
	Configs *VerificationCloudSignalConfigs `json:"configs,omitempty"`
}

// The verification configs for Cloud Signal. Only included if the ?include=verification.configs query param is present
type VerificationCloudSignalConfigs struct {
	ApiKey string `json:"api_key"`
}

type VerificationCloudSignalType string

const (
	VerificationCloudSignalTypeCloudsignal VerificationCloudSignalType = "cloudsignal"
)

func NewVerificationCloudSignalTypeFromString(s string) (VerificationCloudSignalType, error) {
	switch s {
	case "cloudsignal":
		return VerificationCloudSignalTypeCloudsignal, nil
	}
	var t VerificationCloudSignalType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationCloudSignalType) Ptr() *VerificationCloudSignalType {
	return &v
}

type VerificationCommercelayer struct {
	Type    VerificationCommercelayerType     `json:"type,omitempty"`
	Configs *VerificationCommercelayerConfigs `json:"configs,omitempty"`
}

// The verification configs for Commercelayer. Only included if the ?include=verification.configs query param is present
type VerificationCommercelayerConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationCommercelayerType string

const (
	VerificationCommercelayerTypeCommercelayer VerificationCommercelayerType = "commercelayer"
)

func NewVerificationCommercelayerTypeFromString(s string) (VerificationCommercelayerType, error) {
	switch s {
	case "commercelayer":
		return VerificationCommercelayerTypeCommercelayer, nil
	}
	var t VerificationCommercelayerType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationCommercelayerType) Ptr() *VerificationCommercelayerType {
	return &v
}

// The verification configs for the specified verification type
type VerificationConfig struct {
	typeName                      string
	VerificationHmac              *VerificationHmac
	VerificationBasicAuth         *VerificationBasicAuth
	VerificationApiKey            *VerificationApiKey
	VerificationCloudSignal       *VerificationCloudSignal
	VerificationCourier           *VerificationCourier
	VerificationFrontApp          *VerificationFrontApp
	VerificationTwitter           *VerificationTwitter
	VerificationStripe            *VerificationStripe
	VerificationRecharge          *VerificationRecharge
	VerificationTwilio            *VerificationTwilio
	VerificationGitHub            *VerificationGitHub
	VerificationShopify           *VerificationShopify
	VerificationPostmark          *VerificationPostmark
	VerificationTypeform          *VerificationTypeform
	VerificationXero              *VerificationXero
	VerificationSvix              *VerificationSvix
	VerificationZoom              *VerificationZoom
	VerificationAkeneo            *VerificationAkeneo
	VerificationAdyen             *VerificationAdyen
	VerificationGitLab            *VerificationGitLab
	VerificationPropertyFinder    *VerificationPropertyFinder
	VerificationWooCommerce       *VerificationWooCommerce
	VerificationOura              *VerificationOura
	VerificationCommercelayer     *VerificationCommercelayer
	VerificationHubspot           *VerificationHubspot
	VerificationMailgun           *VerificationMailgun
	VerificationPersona           *VerificationPersona
	VerificationPipedrive         *VerificationPipedrive
	VerificationSendGrid          *VerificationSendGrid
	VerificationWorkOs            *VerificationWorkOs
	VerificationSynctera          *VerificationSynctera
	VerificationAwssns            *VerificationAwssns
	Verification3DEye             *Verification3DEye
	VerificationTwitch            *VerificationTwitch
	VerificationEnode             *VerificationEnode
	VerificationFavro             *VerificationFavro
	VerificationLinear            *VerificationLinear
	VerificationShopline          *VerificationShopline
	VerificationWix               *VerificationWix
	VerificationNmiPaymentGateway *VerificationNmiPaymentGateway
	VerificationOrb               *VerificationOrb
	VerificationPylon             *VerificationPylon
	VerificationRepay             *VerificationRepay
	VerificationSquare            *VerificationSquare
	VerificationSolidGate         *VerificationSolidGate
	VerificationTrello            *VerificationTrello
	VerificationSanity            *VerificationSanity
	VerificationEbay              *VerificationEbay
	VerificationTelnyx            *VerificationTelnyx
	VerificationTokenIo           *VerificationTokenIo
}

func NewVerificationConfigFromVerificationHmac(value *VerificationHmac) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationHmac", VerificationHmac: value}
}

func NewVerificationConfigFromVerificationBasicAuth(value *VerificationBasicAuth) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationBasicAuth", VerificationBasicAuth: value}
}

func NewVerificationConfigFromVerificationApiKey(value *VerificationApiKey) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationApiKey", VerificationApiKey: value}
}

func NewVerificationConfigFromVerificationCloudSignal(value *VerificationCloudSignal) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationCloudSignal", VerificationCloudSignal: value}
}

func NewVerificationConfigFromVerificationCourier(value *VerificationCourier) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationCourier", VerificationCourier: value}
}

func NewVerificationConfigFromVerificationFrontApp(value *VerificationFrontApp) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationFrontApp", VerificationFrontApp: value}
}

func NewVerificationConfigFromVerificationTwitter(value *VerificationTwitter) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationTwitter", VerificationTwitter: value}
}

func NewVerificationConfigFromVerificationStripe(value *VerificationStripe) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationStripe", VerificationStripe: value}
}

func NewVerificationConfigFromVerificationRecharge(value *VerificationRecharge) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationRecharge", VerificationRecharge: value}
}

func NewVerificationConfigFromVerificationTwilio(value *VerificationTwilio) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationTwilio", VerificationTwilio: value}
}

func NewVerificationConfigFromVerificationGitHub(value *VerificationGitHub) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationGitHub", VerificationGitHub: value}
}

func NewVerificationConfigFromVerificationShopify(value *VerificationShopify) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationShopify", VerificationShopify: value}
}

func NewVerificationConfigFromVerificationPostmark(value *VerificationPostmark) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationPostmark", VerificationPostmark: value}
}

func NewVerificationConfigFromVerificationTypeform(value *VerificationTypeform) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationTypeform", VerificationTypeform: value}
}

func NewVerificationConfigFromVerificationXero(value *VerificationXero) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationXero", VerificationXero: value}
}

func NewVerificationConfigFromVerificationSvix(value *VerificationSvix) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationSvix", VerificationSvix: value}
}

func NewVerificationConfigFromVerificationZoom(value *VerificationZoom) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationZoom", VerificationZoom: value}
}

func NewVerificationConfigFromVerificationAkeneo(value *VerificationAkeneo) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationAkeneo", VerificationAkeneo: value}
}

func NewVerificationConfigFromVerificationAdyen(value *VerificationAdyen) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationAdyen", VerificationAdyen: value}
}

func NewVerificationConfigFromVerificationGitLab(value *VerificationGitLab) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationGitLab", VerificationGitLab: value}
}

func NewVerificationConfigFromVerificationPropertyFinder(value *VerificationPropertyFinder) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationPropertyFinder", VerificationPropertyFinder: value}
}

func NewVerificationConfigFromVerificationWooCommerce(value *VerificationWooCommerce) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationWooCommerce", VerificationWooCommerce: value}
}

func NewVerificationConfigFromVerificationOura(value *VerificationOura) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationOura", VerificationOura: value}
}

func NewVerificationConfigFromVerificationCommercelayer(value *VerificationCommercelayer) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationCommercelayer", VerificationCommercelayer: value}
}

func NewVerificationConfigFromVerificationHubspot(value *VerificationHubspot) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationHubspot", VerificationHubspot: value}
}

func NewVerificationConfigFromVerificationMailgun(value *VerificationMailgun) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationMailgun", VerificationMailgun: value}
}

func NewVerificationConfigFromVerificationPersona(value *VerificationPersona) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationPersona", VerificationPersona: value}
}

func NewVerificationConfigFromVerificationPipedrive(value *VerificationPipedrive) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationPipedrive", VerificationPipedrive: value}
}

func NewVerificationConfigFromVerificationSendGrid(value *VerificationSendGrid) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationSendGrid", VerificationSendGrid: value}
}

func NewVerificationConfigFromVerificationWorkOs(value *VerificationWorkOs) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationWorkOs", VerificationWorkOs: value}
}

func NewVerificationConfigFromVerificationSynctera(value *VerificationSynctera) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationSynctera", VerificationSynctera: value}
}

func NewVerificationConfigFromVerificationAwssns(value *VerificationAwssns) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationAwssns", VerificationAwssns: value}
}

func NewVerificationConfigFromVerification3DEye(value *Verification3DEye) *VerificationConfig {
	return &VerificationConfig{typeName: "verification3DEye", Verification3DEye: value}
}

func NewVerificationConfigFromVerificationTwitch(value *VerificationTwitch) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationTwitch", VerificationTwitch: value}
}

func NewVerificationConfigFromVerificationEnode(value *VerificationEnode) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationEnode", VerificationEnode: value}
}

func NewVerificationConfigFromVerificationFavro(value *VerificationFavro) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationFavro", VerificationFavro: value}
}

func NewVerificationConfigFromVerificationLinear(value *VerificationLinear) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationLinear", VerificationLinear: value}
}

func NewVerificationConfigFromVerificationShopline(value *VerificationShopline) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationShopline", VerificationShopline: value}
}

func NewVerificationConfigFromVerificationWix(value *VerificationWix) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationWix", VerificationWix: value}
}

func NewVerificationConfigFromVerificationNmiPaymentGateway(value *VerificationNmiPaymentGateway) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationNmiPaymentGateway", VerificationNmiPaymentGateway: value}
}

func NewVerificationConfigFromVerificationOrb(value *VerificationOrb) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationOrb", VerificationOrb: value}
}

func NewVerificationConfigFromVerificationPylon(value *VerificationPylon) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationPylon", VerificationPylon: value}
}

func NewVerificationConfigFromVerificationRepay(value *VerificationRepay) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationRepay", VerificationRepay: value}
}

func NewVerificationConfigFromVerificationSquare(value *VerificationSquare) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationSquare", VerificationSquare: value}
}

func NewVerificationConfigFromVerificationSolidGate(value *VerificationSolidGate) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationSolidGate", VerificationSolidGate: value}
}

func NewVerificationConfigFromVerificationTrello(value *VerificationTrello) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationTrello", VerificationTrello: value}
}

func NewVerificationConfigFromVerificationSanity(value *VerificationSanity) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationSanity", VerificationSanity: value}
}

func NewVerificationConfigFromVerificationEbay(value *VerificationEbay) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationEbay", VerificationEbay: value}
}

func NewVerificationConfigFromVerificationTelnyx(value *VerificationTelnyx) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationTelnyx", VerificationTelnyx: value}
}

func NewVerificationConfigFromVerificationTokenIo(value *VerificationTokenIo) *VerificationConfig {
	return &VerificationConfig{typeName: "verificationTokenIo", VerificationTokenIo: value}
}

func (v *VerificationConfig) UnmarshalJSON(data []byte) error {
	valueVerificationHmac := new(VerificationHmac)
	if err := json.Unmarshal(data, &valueVerificationHmac); err == nil {
		v.typeName = "verificationHmac"
		v.VerificationHmac = valueVerificationHmac
		return nil
	}
	valueVerificationBasicAuth := new(VerificationBasicAuth)
	if err := json.Unmarshal(data, &valueVerificationBasicAuth); err == nil {
		v.typeName = "verificationBasicAuth"
		v.VerificationBasicAuth = valueVerificationBasicAuth
		return nil
	}
	valueVerificationApiKey := new(VerificationApiKey)
	if err := json.Unmarshal(data, &valueVerificationApiKey); err == nil {
		v.typeName = "verificationApiKey"
		v.VerificationApiKey = valueVerificationApiKey
		return nil
	}
	valueVerificationCloudSignal := new(VerificationCloudSignal)
	if err := json.Unmarshal(data, &valueVerificationCloudSignal); err == nil {
		v.typeName = "verificationCloudSignal"
		v.VerificationCloudSignal = valueVerificationCloudSignal
		return nil
	}
	valueVerificationCourier := new(VerificationCourier)
	if err := json.Unmarshal(data, &valueVerificationCourier); err == nil {
		v.typeName = "verificationCourier"
		v.VerificationCourier = valueVerificationCourier
		return nil
	}
	valueVerificationFrontApp := new(VerificationFrontApp)
	if err := json.Unmarshal(data, &valueVerificationFrontApp); err == nil {
		v.typeName = "verificationFrontApp"
		v.VerificationFrontApp = valueVerificationFrontApp
		return nil
	}
	valueVerificationTwitter := new(VerificationTwitter)
	if err := json.Unmarshal(data, &valueVerificationTwitter); err == nil {
		v.typeName = "verificationTwitter"
		v.VerificationTwitter = valueVerificationTwitter
		return nil
	}
	valueVerificationStripe := new(VerificationStripe)
	if err := json.Unmarshal(data, &valueVerificationStripe); err == nil {
		v.typeName = "verificationStripe"
		v.VerificationStripe = valueVerificationStripe
		return nil
	}
	valueVerificationRecharge := new(VerificationRecharge)
	if err := json.Unmarshal(data, &valueVerificationRecharge); err == nil {
		v.typeName = "verificationRecharge"
		v.VerificationRecharge = valueVerificationRecharge
		return nil
	}
	valueVerificationTwilio := new(VerificationTwilio)
	if err := json.Unmarshal(data, &valueVerificationTwilio); err == nil {
		v.typeName = "verificationTwilio"
		v.VerificationTwilio = valueVerificationTwilio
		return nil
	}
	valueVerificationGitHub := new(VerificationGitHub)
	if err := json.Unmarshal(data, &valueVerificationGitHub); err == nil {
		v.typeName = "verificationGitHub"
		v.VerificationGitHub = valueVerificationGitHub
		return nil
	}
	valueVerificationShopify := new(VerificationShopify)
	if err := json.Unmarshal(data, &valueVerificationShopify); err == nil {
		v.typeName = "verificationShopify"
		v.VerificationShopify = valueVerificationShopify
		return nil
	}
	valueVerificationPostmark := new(VerificationPostmark)
	if err := json.Unmarshal(data, &valueVerificationPostmark); err == nil {
		v.typeName = "verificationPostmark"
		v.VerificationPostmark = valueVerificationPostmark
		return nil
	}
	valueVerificationTypeform := new(VerificationTypeform)
	if err := json.Unmarshal(data, &valueVerificationTypeform); err == nil {
		v.typeName = "verificationTypeform"
		v.VerificationTypeform = valueVerificationTypeform
		return nil
	}
	valueVerificationXero := new(VerificationXero)
	if err := json.Unmarshal(data, &valueVerificationXero); err == nil {
		v.typeName = "verificationXero"
		v.VerificationXero = valueVerificationXero
		return nil
	}
	valueVerificationSvix := new(VerificationSvix)
	if err := json.Unmarshal(data, &valueVerificationSvix); err == nil {
		v.typeName = "verificationSvix"
		v.VerificationSvix = valueVerificationSvix
		return nil
	}
	valueVerificationZoom := new(VerificationZoom)
	if err := json.Unmarshal(data, &valueVerificationZoom); err == nil {
		v.typeName = "verificationZoom"
		v.VerificationZoom = valueVerificationZoom
		return nil
	}
	valueVerificationAkeneo := new(VerificationAkeneo)
	if err := json.Unmarshal(data, &valueVerificationAkeneo); err == nil {
		v.typeName = "verificationAkeneo"
		v.VerificationAkeneo = valueVerificationAkeneo
		return nil
	}
	valueVerificationAdyen := new(VerificationAdyen)
	if err := json.Unmarshal(data, &valueVerificationAdyen); err == nil {
		v.typeName = "verificationAdyen"
		v.VerificationAdyen = valueVerificationAdyen
		return nil
	}
	valueVerificationGitLab := new(VerificationGitLab)
	if err := json.Unmarshal(data, &valueVerificationGitLab); err == nil {
		v.typeName = "verificationGitLab"
		v.VerificationGitLab = valueVerificationGitLab
		return nil
	}
	valueVerificationPropertyFinder := new(VerificationPropertyFinder)
	if err := json.Unmarshal(data, &valueVerificationPropertyFinder); err == nil {
		v.typeName = "verificationPropertyFinder"
		v.VerificationPropertyFinder = valueVerificationPropertyFinder
		return nil
	}
	valueVerificationWooCommerce := new(VerificationWooCommerce)
	if err := json.Unmarshal(data, &valueVerificationWooCommerce); err == nil {
		v.typeName = "verificationWooCommerce"
		v.VerificationWooCommerce = valueVerificationWooCommerce
		return nil
	}
	valueVerificationOura := new(VerificationOura)
	if err := json.Unmarshal(data, &valueVerificationOura); err == nil {
		v.typeName = "verificationOura"
		v.VerificationOura = valueVerificationOura
		return nil
	}
	valueVerificationCommercelayer := new(VerificationCommercelayer)
	if err := json.Unmarshal(data, &valueVerificationCommercelayer); err == nil {
		v.typeName = "verificationCommercelayer"
		v.VerificationCommercelayer = valueVerificationCommercelayer
		return nil
	}
	valueVerificationHubspot := new(VerificationHubspot)
	if err := json.Unmarshal(data, &valueVerificationHubspot); err == nil {
		v.typeName = "verificationHubspot"
		v.VerificationHubspot = valueVerificationHubspot
		return nil
	}
	valueVerificationMailgun := new(VerificationMailgun)
	if err := json.Unmarshal(data, &valueVerificationMailgun); err == nil {
		v.typeName = "verificationMailgun"
		v.VerificationMailgun = valueVerificationMailgun
		return nil
	}
	valueVerificationPersona := new(VerificationPersona)
	if err := json.Unmarshal(data, &valueVerificationPersona); err == nil {
		v.typeName = "verificationPersona"
		v.VerificationPersona = valueVerificationPersona
		return nil
	}
	valueVerificationPipedrive := new(VerificationPipedrive)
	if err := json.Unmarshal(data, &valueVerificationPipedrive); err == nil {
		v.typeName = "verificationPipedrive"
		v.VerificationPipedrive = valueVerificationPipedrive
		return nil
	}
	valueVerificationSendGrid := new(VerificationSendGrid)
	if err := json.Unmarshal(data, &valueVerificationSendGrid); err == nil {
		v.typeName = "verificationSendGrid"
		v.VerificationSendGrid = valueVerificationSendGrid
		return nil
	}
	valueVerificationWorkOs := new(VerificationWorkOs)
	if err := json.Unmarshal(data, &valueVerificationWorkOs); err == nil {
		v.typeName = "verificationWorkOs"
		v.VerificationWorkOs = valueVerificationWorkOs
		return nil
	}
	valueVerificationSynctera := new(VerificationSynctera)
	if err := json.Unmarshal(data, &valueVerificationSynctera); err == nil {
		v.typeName = "verificationSynctera"
		v.VerificationSynctera = valueVerificationSynctera
		return nil
	}
	valueVerificationAwssns := new(VerificationAwssns)
	if err := json.Unmarshal(data, &valueVerificationAwssns); err == nil {
		v.typeName = "verificationAwssns"
		v.VerificationAwssns = valueVerificationAwssns
		return nil
	}
	valueVerification3DEye := new(Verification3DEye)
	if err := json.Unmarshal(data, &valueVerification3DEye); err == nil {
		v.typeName = "verification3DEye"
		v.Verification3DEye = valueVerification3DEye
		return nil
	}
	valueVerificationTwitch := new(VerificationTwitch)
	if err := json.Unmarshal(data, &valueVerificationTwitch); err == nil {
		v.typeName = "verificationTwitch"
		v.VerificationTwitch = valueVerificationTwitch
		return nil
	}
	valueVerificationEnode := new(VerificationEnode)
	if err := json.Unmarshal(data, &valueVerificationEnode); err == nil {
		v.typeName = "verificationEnode"
		v.VerificationEnode = valueVerificationEnode
		return nil
	}
	valueVerificationFavro := new(VerificationFavro)
	if err := json.Unmarshal(data, &valueVerificationFavro); err == nil {
		v.typeName = "verificationFavro"
		v.VerificationFavro = valueVerificationFavro
		return nil
	}
	valueVerificationLinear := new(VerificationLinear)
	if err := json.Unmarshal(data, &valueVerificationLinear); err == nil {
		v.typeName = "verificationLinear"
		v.VerificationLinear = valueVerificationLinear
		return nil
	}
	valueVerificationShopline := new(VerificationShopline)
	if err := json.Unmarshal(data, &valueVerificationShopline); err == nil {
		v.typeName = "verificationShopline"
		v.VerificationShopline = valueVerificationShopline
		return nil
	}
	valueVerificationWix := new(VerificationWix)
	if err := json.Unmarshal(data, &valueVerificationWix); err == nil {
		v.typeName = "verificationWix"
		v.VerificationWix = valueVerificationWix
		return nil
	}
	valueVerificationNmiPaymentGateway := new(VerificationNmiPaymentGateway)
	if err := json.Unmarshal(data, &valueVerificationNmiPaymentGateway); err == nil {
		v.typeName = "verificationNmiPaymentGateway"
		v.VerificationNmiPaymentGateway = valueVerificationNmiPaymentGateway
		return nil
	}
	valueVerificationOrb := new(VerificationOrb)
	if err := json.Unmarshal(data, &valueVerificationOrb); err == nil {
		v.typeName = "verificationOrb"
		v.VerificationOrb = valueVerificationOrb
		return nil
	}
	valueVerificationPylon := new(VerificationPylon)
	if err := json.Unmarshal(data, &valueVerificationPylon); err == nil {
		v.typeName = "verificationPylon"
		v.VerificationPylon = valueVerificationPylon
		return nil
	}
	valueVerificationRepay := new(VerificationRepay)
	if err := json.Unmarshal(data, &valueVerificationRepay); err == nil {
		v.typeName = "verificationRepay"
		v.VerificationRepay = valueVerificationRepay
		return nil
	}
	valueVerificationSquare := new(VerificationSquare)
	if err := json.Unmarshal(data, &valueVerificationSquare); err == nil {
		v.typeName = "verificationSquare"
		v.VerificationSquare = valueVerificationSquare
		return nil
	}
	valueVerificationSolidGate := new(VerificationSolidGate)
	if err := json.Unmarshal(data, &valueVerificationSolidGate); err == nil {
		v.typeName = "verificationSolidGate"
		v.VerificationSolidGate = valueVerificationSolidGate
		return nil
	}
	valueVerificationTrello := new(VerificationTrello)
	if err := json.Unmarshal(data, &valueVerificationTrello); err == nil {
		v.typeName = "verificationTrello"
		v.VerificationTrello = valueVerificationTrello
		return nil
	}
	valueVerificationSanity := new(VerificationSanity)
	if err := json.Unmarshal(data, &valueVerificationSanity); err == nil {
		v.typeName = "verificationSanity"
		v.VerificationSanity = valueVerificationSanity
		return nil
	}
	valueVerificationEbay := new(VerificationEbay)
	if err := json.Unmarshal(data, &valueVerificationEbay); err == nil {
		v.typeName = "verificationEbay"
		v.VerificationEbay = valueVerificationEbay
		return nil
	}
	valueVerificationTelnyx := new(VerificationTelnyx)
	if err := json.Unmarshal(data, &valueVerificationTelnyx); err == nil {
		v.typeName = "verificationTelnyx"
		v.VerificationTelnyx = valueVerificationTelnyx
		return nil
	}
	valueVerificationTokenIo := new(VerificationTokenIo)
	if err := json.Unmarshal(data, &valueVerificationTokenIo); err == nil {
		v.typeName = "verificationTokenIo"
		v.VerificationTokenIo = valueVerificationTokenIo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v VerificationConfig) MarshalJSON() ([]byte, error) {
	switch v.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "verificationHmac":
		return json.Marshal(v.VerificationHmac)
	case "verificationBasicAuth":
		return json.Marshal(v.VerificationBasicAuth)
	case "verificationApiKey":
		return json.Marshal(v.VerificationApiKey)
	case "verificationCloudSignal":
		return json.Marshal(v.VerificationCloudSignal)
	case "verificationCourier":
		return json.Marshal(v.VerificationCourier)
	case "verificationFrontApp":
		return json.Marshal(v.VerificationFrontApp)
	case "verificationTwitter":
		return json.Marshal(v.VerificationTwitter)
	case "verificationStripe":
		return json.Marshal(v.VerificationStripe)
	case "verificationRecharge":
		return json.Marshal(v.VerificationRecharge)
	case "verificationTwilio":
		return json.Marshal(v.VerificationTwilio)
	case "verificationGitHub":
		return json.Marshal(v.VerificationGitHub)
	case "verificationShopify":
		return json.Marshal(v.VerificationShopify)
	case "verificationPostmark":
		return json.Marshal(v.VerificationPostmark)
	case "verificationTypeform":
		return json.Marshal(v.VerificationTypeform)
	case "verificationXero":
		return json.Marshal(v.VerificationXero)
	case "verificationSvix":
		return json.Marshal(v.VerificationSvix)
	case "verificationZoom":
		return json.Marshal(v.VerificationZoom)
	case "verificationAkeneo":
		return json.Marshal(v.VerificationAkeneo)
	case "verificationAdyen":
		return json.Marshal(v.VerificationAdyen)
	case "verificationGitLab":
		return json.Marshal(v.VerificationGitLab)
	case "verificationPropertyFinder":
		return json.Marshal(v.VerificationPropertyFinder)
	case "verificationWooCommerce":
		return json.Marshal(v.VerificationWooCommerce)
	case "verificationOura":
		return json.Marshal(v.VerificationOura)
	case "verificationCommercelayer":
		return json.Marshal(v.VerificationCommercelayer)
	case "verificationHubspot":
		return json.Marshal(v.VerificationHubspot)
	case "verificationMailgun":
		return json.Marshal(v.VerificationMailgun)
	case "verificationPersona":
		return json.Marshal(v.VerificationPersona)
	case "verificationPipedrive":
		return json.Marshal(v.VerificationPipedrive)
	case "verificationSendGrid":
		return json.Marshal(v.VerificationSendGrid)
	case "verificationWorkOs":
		return json.Marshal(v.VerificationWorkOs)
	case "verificationSynctera":
		return json.Marshal(v.VerificationSynctera)
	case "verificationAwssns":
		return json.Marshal(v.VerificationAwssns)
	case "verification3DEye":
		return json.Marshal(v.Verification3DEye)
	case "verificationTwitch":
		return json.Marshal(v.VerificationTwitch)
	case "verificationEnode":
		return json.Marshal(v.VerificationEnode)
	case "verificationFavro":
		return json.Marshal(v.VerificationFavro)
	case "verificationLinear":
		return json.Marshal(v.VerificationLinear)
	case "verificationShopline":
		return json.Marshal(v.VerificationShopline)
	case "verificationWix":
		return json.Marshal(v.VerificationWix)
	case "verificationNmiPaymentGateway":
		return json.Marshal(v.VerificationNmiPaymentGateway)
	case "verificationOrb":
		return json.Marshal(v.VerificationOrb)
	case "verificationPylon":
		return json.Marshal(v.VerificationPylon)
	case "verificationRepay":
		return json.Marshal(v.VerificationRepay)
	case "verificationSquare":
		return json.Marshal(v.VerificationSquare)
	case "verificationSolidGate":
		return json.Marshal(v.VerificationSolidGate)
	case "verificationTrello":
		return json.Marshal(v.VerificationTrello)
	case "verificationSanity":
		return json.Marshal(v.VerificationSanity)
	case "verificationEbay":
		return json.Marshal(v.VerificationEbay)
	case "verificationTelnyx":
		return json.Marshal(v.VerificationTelnyx)
	case "verificationTokenIo":
		return json.Marshal(v.VerificationTokenIo)
	}
}

type VerificationConfigVisitor interface {
	VisitVerificationHmac(*VerificationHmac) error
	VisitVerificationBasicAuth(*VerificationBasicAuth) error
	VisitVerificationApiKey(*VerificationApiKey) error
	VisitVerificationCloudSignal(*VerificationCloudSignal) error
	VisitVerificationCourier(*VerificationCourier) error
	VisitVerificationFrontApp(*VerificationFrontApp) error
	VisitVerificationTwitter(*VerificationTwitter) error
	VisitVerificationStripe(*VerificationStripe) error
	VisitVerificationRecharge(*VerificationRecharge) error
	VisitVerificationTwilio(*VerificationTwilio) error
	VisitVerificationGitHub(*VerificationGitHub) error
	VisitVerificationShopify(*VerificationShopify) error
	VisitVerificationPostmark(*VerificationPostmark) error
	VisitVerificationTypeform(*VerificationTypeform) error
	VisitVerificationXero(*VerificationXero) error
	VisitVerificationSvix(*VerificationSvix) error
	VisitVerificationZoom(*VerificationZoom) error
	VisitVerificationAkeneo(*VerificationAkeneo) error
	VisitVerificationAdyen(*VerificationAdyen) error
	VisitVerificationGitLab(*VerificationGitLab) error
	VisitVerificationPropertyFinder(*VerificationPropertyFinder) error
	VisitVerificationWooCommerce(*VerificationWooCommerce) error
	VisitVerificationOura(*VerificationOura) error
	VisitVerificationCommercelayer(*VerificationCommercelayer) error
	VisitVerificationHubspot(*VerificationHubspot) error
	VisitVerificationMailgun(*VerificationMailgun) error
	VisitVerificationPersona(*VerificationPersona) error
	VisitVerificationPipedrive(*VerificationPipedrive) error
	VisitVerificationSendGrid(*VerificationSendGrid) error
	VisitVerificationWorkOs(*VerificationWorkOs) error
	VisitVerificationSynctera(*VerificationSynctera) error
	VisitVerificationAwssns(*VerificationAwssns) error
	VisitVerification3DEye(*Verification3DEye) error
	VisitVerificationTwitch(*VerificationTwitch) error
	VisitVerificationEnode(*VerificationEnode) error
	VisitVerificationFavro(*VerificationFavro) error
	VisitVerificationLinear(*VerificationLinear) error
	VisitVerificationShopline(*VerificationShopline) error
	VisitVerificationWix(*VerificationWix) error
	VisitVerificationNmiPaymentGateway(*VerificationNmiPaymentGateway) error
	VisitVerificationOrb(*VerificationOrb) error
	VisitVerificationPylon(*VerificationPylon) error
	VisitVerificationRepay(*VerificationRepay) error
	VisitVerificationSquare(*VerificationSquare) error
	VisitVerificationSolidGate(*VerificationSolidGate) error
	VisitVerificationTrello(*VerificationTrello) error
	VisitVerificationSanity(*VerificationSanity) error
	VisitVerificationEbay(*VerificationEbay) error
	VisitVerificationTelnyx(*VerificationTelnyx) error
	VisitVerificationTokenIo(*VerificationTokenIo) error
}

func (v *VerificationConfig) Accept(visitor VerificationConfigVisitor) error {
	switch v.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "verificationHmac":
		return visitor.VisitVerificationHmac(v.VerificationHmac)
	case "verificationBasicAuth":
		return visitor.VisitVerificationBasicAuth(v.VerificationBasicAuth)
	case "verificationApiKey":
		return visitor.VisitVerificationApiKey(v.VerificationApiKey)
	case "verificationCloudSignal":
		return visitor.VisitVerificationCloudSignal(v.VerificationCloudSignal)
	case "verificationCourier":
		return visitor.VisitVerificationCourier(v.VerificationCourier)
	case "verificationFrontApp":
		return visitor.VisitVerificationFrontApp(v.VerificationFrontApp)
	case "verificationTwitter":
		return visitor.VisitVerificationTwitter(v.VerificationTwitter)
	case "verificationStripe":
		return visitor.VisitVerificationStripe(v.VerificationStripe)
	case "verificationRecharge":
		return visitor.VisitVerificationRecharge(v.VerificationRecharge)
	case "verificationTwilio":
		return visitor.VisitVerificationTwilio(v.VerificationTwilio)
	case "verificationGitHub":
		return visitor.VisitVerificationGitHub(v.VerificationGitHub)
	case "verificationShopify":
		return visitor.VisitVerificationShopify(v.VerificationShopify)
	case "verificationPostmark":
		return visitor.VisitVerificationPostmark(v.VerificationPostmark)
	case "verificationTypeform":
		return visitor.VisitVerificationTypeform(v.VerificationTypeform)
	case "verificationXero":
		return visitor.VisitVerificationXero(v.VerificationXero)
	case "verificationSvix":
		return visitor.VisitVerificationSvix(v.VerificationSvix)
	case "verificationZoom":
		return visitor.VisitVerificationZoom(v.VerificationZoom)
	case "verificationAkeneo":
		return visitor.VisitVerificationAkeneo(v.VerificationAkeneo)
	case "verificationAdyen":
		return visitor.VisitVerificationAdyen(v.VerificationAdyen)
	case "verificationGitLab":
		return visitor.VisitVerificationGitLab(v.VerificationGitLab)
	case "verificationPropertyFinder":
		return visitor.VisitVerificationPropertyFinder(v.VerificationPropertyFinder)
	case "verificationWooCommerce":
		return visitor.VisitVerificationWooCommerce(v.VerificationWooCommerce)
	case "verificationOura":
		return visitor.VisitVerificationOura(v.VerificationOura)
	case "verificationCommercelayer":
		return visitor.VisitVerificationCommercelayer(v.VerificationCommercelayer)
	case "verificationHubspot":
		return visitor.VisitVerificationHubspot(v.VerificationHubspot)
	case "verificationMailgun":
		return visitor.VisitVerificationMailgun(v.VerificationMailgun)
	case "verificationPersona":
		return visitor.VisitVerificationPersona(v.VerificationPersona)
	case "verificationPipedrive":
		return visitor.VisitVerificationPipedrive(v.VerificationPipedrive)
	case "verificationSendGrid":
		return visitor.VisitVerificationSendGrid(v.VerificationSendGrid)
	case "verificationWorkOs":
		return visitor.VisitVerificationWorkOs(v.VerificationWorkOs)
	case "verificationSynctera":
		return visitor.VisitVerificationSynctera(v.VerificationSynctera)
	case "verificationAwssns":
		return visitor.VisitVerificationAwssns(v.VerificationAwssns)
	case "verification3DEye":
		return visitor.VisitVerification3DEye(v.Verification3DEye)
	case "verificationTwitch":
		return visitor.VisitVerificationTwitch(v.VerificationTwitch)
	case "verificationEnode":
		return visitor.VisitVerificationEnode(v.VerificationEnode)
	case "verificationFavro":
		return visitor.VisitVerificationFavro(v.VerificationFavro)
	case "verificationLinear":
		return visitor.VisitVerificationLinear(v.VerificationLinear)
	case "verificationShopline":
		return visitor.VisitVerificationShopline(v.VerificationShopline)
	case "verificationWix":
		return visitor.VisitVerificationWix(v.VerificationWix)
	case "verificationNmiPaymentGateway":
		return visitor.VisitVerificationNmiPaymentGateway(v.VerificationNmiPaymentGateway)
	case "verificationOrb":
		return visitor.VisitVerificationOrb(v.VerificationOrb)
	case "verificationPylon":
		return visitor.VisitVerificationPylon(v.VerificationPylon)
	case "verificationRepay":
		return visitor.VisitVerificationRepay(v.VerificationRepay)
	case "verificationSquare":
		return visitor.VisitVerificationSquare(v.VerificationSquare)
	case "verificationSolidGate":
		return visitor.VisitVerificationSolidGate(v.VerificationSolidGate)
	case "verificationTrello":
		return visitor.VisitVerificationTrello(v.VerificationTrello)
	case "verificationSanity":
		return visitor.VisitVerificationSanity(v.VerificationSanity)
	case "verificationEbay":
		return visitor.VisitVerificationEbay(v.VerificationEbay)
	case "verificationTelnyx":
		return visitor.VisitVerificationTelnyx(v.VerificationTelnyx)
	case "verificationTokenIo":
		return visitor.VisitVerificationTokenIo(v.VerificationTokenIo)
	}
}

type VerificationCourier struct {
	Type    VerificationCourierType     `json:"type,omitempty"`
	Configs *VerificationCourierConfigs `json:"configs,omitempty"`
}

// The verification configs for Courier. Only included if the ?include=verification.configs query param is present
type VerificationCourierConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationCourierType string

const (
	VerificationCourierTypeCourier VerificationCourierType = "courier"
)

func NewVerificationCourierTypeFromString(s string) (VerificationCourierType, error) {
	switch s {
	case "courier":
		return VerificationCourierTypeCourier, nil
	}
	var t VerificationCourierType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationCourierType) Ptr() *VerificationCourierType {
	return &v
}

type VerificationEbay struct {
	Type    VerificationEbayType     `json:"type,omitempty"`
	Configs *VerificationEbayConfigs `json:"configs,omitempty"`
}

// The verification configs for Ebay. Only included if the ?include=verification.configs query param is present
type VerificationEbayConfigs struct {
	Environment       string `json:"environment"`
	ClientId          string `json:"client_id"`
	ClientSecret      string `json:"client_secret"`
	DevId             string `json:"dev_id"`
	VerificationToken string `json:"verification_token"`
}

type VerificationEbayType string

const (
	VerificationEbayTypeEbay VerificationEbayType = "ebay"
)

func NewVerificationEbayTypeFromString(s string) (VerificationEbayType, error) {
	switch s {
	case "ebay":
		return VerificationEbayTypeEbay, nil
	}
	var t VerificationEbayType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationEbayType) Ptr() *VerificationEbayType {
	return &v
}

type VerificationEnode struct {
	Type    VerificationEnodeType     `json:"type,omitempty"`
	Configs *VerificationEnodeConfigs `json:"configs,omitempty"`
}

// The verification configs for Enode. Only included if the ?include=verification.configs query param is present
type VerificationEnodeConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationEnodeType string

const (
	VerificationEnodeTypeEnode VerificationEnodeType = "enode"
)

func NewVerificationEnodeTypeFromString(s string) (VerificationEnodeType, error) {
	switch s {
	case "enode":
		return VerificationEnodeTypeEnode, nil
	}
	var t VerificationEnodeType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationEnodeType) Ptr() *VerificationEnodeType {
	return &v
}

type VerificationFavro struct {
	Type    VerificationFavroType     `json:"type,omitempty"`
	Configs *VerificationFavroConfigs `json:"configs,omitempty"`
}

// The verification configs for Favro. Only included if the ?include=verification.configs query param is present
type VerificationFavroConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationFavroType string

const (
	VerificationFavroTypeFavro VerificationFavroType = "favro"
)

func NewVerificationFavroTypeFromString(s string) (VerificationFavroType, error) {
	switch s {
	case "favro":
		return VerificationFavroTypeFavro, nil
	}
	var t VerificationFavroType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationFavroType) Ptr() *VerificationFavroType {
	return &v
}

type VerificationFrontApp struct {
	Type    VerificationFrontAppType     `json:"type,omitempty"`
	Configs *VerificationFrontAppConfigs `json:"configs,omitempty"`
}

// The verification configs for FrontApp. Only included if the ?include=verification.configs query param is present
type VerificationFrontAppConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationFrontAppType string

const (
	VerificationFrontAppTypeFrontapp VerificationFrontAppType = "frontapp"
)

func NewVerificationFrontAppTypeFromString(s string) (VerificationFrontAppType, error) {
	switch s {
	case "frontapp":
		return VerificationFrontAppTypeFrontapp, nil
	}
	var t VerificationFrontAppType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationFrontAppType) Ptr() *VerificationFrontAppType {
	return &v
}

type VerificationGitHub struct {
	Type    VerificationGitHubType     `json:"type,omitempty"`
	Configs *VerificationGitHubConfigs `json:"configs,omitempty"`
}

// The verification configs for GitHub. Only included if the ?include=verification.configs query param is present
type VerificationGitHubConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationGitHubType string

const (
	VerificationGitHubTypeGithub VerificationGitHubType = "github"
)

func NewVerificationGitHubTypeFromString(s string) (VerificationGitHubType, error) {
	switch s {
	case "github":
		return VerificationGitHubTypeGithub, nil
	}
	var t VerificationGitHubType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationGitHubType) Ptr() *VerificationGitHubType {
	return &v
}

type VerificationGitLab struct {
	Type    VerificationGitLabType     `json:"type,omitempty"`
	Configs *VerificationGitLabConfigs `json:"configs,omitempty"`
}

// The verification configs for GitLab. Only included if the ?include=verification.configs query param is present
type VerificationGitLabConfigs struct {
	ApiKey string `json:"api_key"`
}

type VerificationGitLabType string

const (
	VerificationGitLabTypeGitlab VerificationGitLabType = "gitlab"
)

func NewVerificationGitLabTypeFromString(s string) (VerificationGitLabType, error) {
	switch s {
	case "gitlab":
		return VerificationGitLabTypeGitlab, nil
	}
	var t VerificationGitLabType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationGitLabType) Ptr() *VerificationGitLabType {
	return &v
}

type VerificationHmac struct {
	Type    VerificationHmacType     `json:"type,omitempty"`
	Configs *VerificationHmacConfigs `json:"configs,omitempty"`
}

// The verification configs for HMAC. Only included if the ?include=verification.configs query param is present
type VerificationHmacConfigs struct {
	WebhookSecretKey string                          `json:"webhook_secret_key"`
	Algorithm        HmacAlgorithms                  `json:"algorithm,omitempty"`
	HeaderKey        string                          `json:"header_key"`
	Encoding         VerificationHmacConfigsEncoding `json:"encoding,omitempty"`
}

type VerificationHmacConfigsEncoding string

const (
	VerificationHmacConfigsEncodingBase64    VerificationHmacConfigsEncoding = "base64"
	VerificationHmacConfigsEncodingBase64Url VerificationHmacConfigsEncoding = "base64url"
	VerificationHmacConfigsEncodingHex       VerificationHmacConfigsEncoding = "hex"
)

func NewVerificationHmacConfigsEncodingFromString(s string) (VerificationHmacConfigsEncoding, error) {
	switch s {
	case "base64":
		return VerificationHmacConfigsEncodingBase64, nil
	case "base64url":
		return VerificationHmacConfigsEncodingBase64Url, nil
	case "hex":
		return VerificationHmacConfigsEncodingHex, nil
	}
	var t VerificationHmacConfigsEncoding
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationHmacConfigsEncoding) Ptr() *VerificationHmacConfigsEncoding {
	return &v
}

type VerificationHmacType string

const (
	VerificationHmacTypeHmac VerificationHmacType = "hmac"
)

func NewVerificationHmacTypeFromString(s string) (VerificationHmacType, error) {
	switch s {
	case "hmac":
		return VerificationHmacTypeHmac, nil
	}
	var t VerificationHmacType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationHmacType) Ptr() *VerificationHmacType {
	return &v
}

type VerificationHubspot struct {
	Type    VerificationHubspotType     `json:"type,omitempty"`
	Configs *VerificationHubspotConfigs `json:"configs,omitempty"`
}

// The verification configs for Hubspot. Only included if the ?include=verification.configs query param is present
type VerificationHubspotConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationHubspotType string

const (
	VerificationHubspotTypeHubspot VerificationHubspotType = "hubspot"
)

func NewVerificationHubspotTypeFromString(s string) (VerificationHubspotType, error) {
	switch s {
	case "hubspot":
		return VerificationHubspotTypeHubspot, nil
	}
	var t VerificationHubspotType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationHubspotType) Ptr() *VerificationHubspotType {
	return &v
}

type VerificationLinear struct {
	Type    VerificationLinearType     `json:"type,omitempty"`
	Configs *VerificationLinearConfigs `json:"configs,omitempty"`
}

// The verification configs for Linear. Only included if the ?include=verification.configs query param is present
type VerificationLinearConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationLinearType string

const (
	VerificationLinearTypeLinear VerificationLinearType = "linear"
)

func NewVerificationLinearTypeFromString(s string) (VerificationLinearType, error) {
	switch s {
	case "linear":
		return VerificationLinearTypeLinear, nil
	}
	var t VerificationLinearType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationLinearType) Ptr() *VerificationLinearType {
	return &v
}

type VerificationMailgun struct {
	Type    VerificationMailgunType     `json:"type,omitempty"`
	Configs *VerificationMailgunConfigs `json:"configs,omitempty"`
}

// The verification configs for Mailgun. Only included if the ?include=verification.configs query param is present
type VerificationMailgunConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationMailgunType string

const (
	VerificationMailgunTypeMailgun VerificationMailgunType = "mailgun"
)

func NewVerificationMailgunTypeFromString(s string) (VerificationMailgunType, error) {
	switch s {
	case "mailgun":
		return VerificationMailgunTypeMailgun, nil
	}
	var t VerificationMailgunType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationMailgunType) Ptr() *VerificationMailgunType {
	return &v
}

type VerificationNmiPaymentGateway struct {
	Type    VerificationNmiPaymentGatewayType     `json:"type,omitempty"`
	Configs *VerificationNmiPaymentGatewayConfigs `json:"configs,omitempty"`
}

// The verification configs for NMI Payment Gateway. Only included if the ?include=verification.configs query param is present
type VerificationNmiPaymentGatewayConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationNmiPaymentGatewayType string

const (
	VerificationNmiPaymentGatewayTypeNmi VerificationNmiPaymentGatewayType = "nmi"
)

func NewVerificationNmiPaymentGatewayTypeFromString(s string) (VerificationNmiPaymentGatewayType, error) {
	switch s {
	case "nmi":
		return VerificationNmiPaymentGatewayTypeNmi, nil
	}
	var t VerificationNmiPaymentGatewayType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationNmiPaymentGatewayType) Ptr() *VerificationNmiPaymentGatewayType {
	return &v
}

type VerificationOrb struct {
	Type    VerificationOrbType     `json:"type,omitempty"`
	Configs *VerificationOrbConfigs `json:"configs,omitempty"`
}

// The verification configs for Orb. Only included if the ?include=verification.configs query param is present
type VerificationOrbConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationOrbType string

const (
	VerificationOrbTypeOrb VerificationOrbType = "orb"
)

func NewVerificationOrbTypeFromString(s string) (VerificationOrbType, error) {
	switch s {
	case "orb":
		return VerificationOrbTypeOrb, nil
	}
	var t VerificationOrbType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationOrbType) Ptr() *VerificationOrbType {
	return &v
}

type VerificationOura struct {
	Type    VerificationOuraType     `json:"type,omitempty"`
	Configs *VerificationOuraConfigs `json:"configs,omitempty"`
}

// The verification configs for Oura. Only included if the ?include=verification.configs query param is present
type VerificationOuraConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationOuraType string

const (
	VerificationOuraTypeOura VerificationOuraType = "oura"
)

func NewVerificationOuraTypeFromString(s string) (VerificationOuraType, error) {
	switch s {
	case "oura":
		return VerificationOuraTypeOura, nil
	}
	var t VerificationOuraType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationOuraType) Ptr() *VerificationOuraType {
	return &v
}

type VerificationPersona struct {
	Type    VerificationPersonaType     `json:"type,omitempty"`
	Configs *VerificationPersonaConfigs `json:"configs,omitempty"`
}

// The verification configs for Persona. Only included if the ?include=verification.configs query param is present
type VerificationPersonaConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationPersonaType string

const (
	VerificationPersonaTypePersona VerificationPersonaType = "persona"
)

func NewVerificationPersonaTypeFromString(s string) (VerificationPersonaType, error) {
	switch s {
	case "persona":
		return VerificationPersonaTypePersona, nil
	}
	var t VerificationPersonaType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationPersonaType) Ptr() *VerificationPersonaType {
	return &v
}

type VerificationPipedrive struct {
	Type    VerificationPipedriveType     `json:"type,omitempty"`
	Configs *VerificationPipedriveConfigs `json:"configs,omitempty"`
}

// The verification configs for Pipedrive. Only included if the ?include=verification.configs query param is present
type VerificationPipedriveConfigs struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

type VerificationPipedriveType string

const (
	VerificationPipedriveTypePipedrive VerificationPipedriveType = "pipedrive"
)

func NewVerificationPipedriveTypeFromString(s string) (VerificationPipedriveType, error) {
	switch s {
	case "pipedrive":
		return VerificationPipedriveTypePipedrive, nil
	}
	var t VerificationPipedriveType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationPipedriveType) Ptr() *VerificationPipedriveType {
	return &v
}

type VerificationPostmark struct {
	Type    VerificationPostmarkType     `json:"type,omitempty"`
	Configs *VerificationPostmarkConfigs `json:"configs,omitempty"`
}

// The verification configs for Postmark. Only included if the ?include=verification.configs query param is present
type VerificationPostmarkConfigs struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

type VerificationPostmarkType string

const (
	VerificationPostmarkTypePostmark VerificationPostmarkType = "postmark"
)

func NewVerificationPostmarkTypeFromString(s string) (VerificationPostmarkType, error) {
	switch s {
	case "postmark":
		return VerificationPostmarkTypePostmark, nil
	}
	var t VerificationPostmarkType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationPostmarkType) Ptr() *VerificationPostmarkType {
	return &v
}

type VerificationPropertyFinder struct {
	Type    string                             `json:"type"`
	Configs *VerificationPropertyFinderConfigs `json:"configs,omitempty"`
}

// The verification configs for Property Finder. Only included if the ?include=verification.configs query param is present
type VerificationPropertyFinderConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationPylon struct {
	Type    VerificationPylonType     `json:"type,omitempty"`
	Configs *VerificationPylonConfigs `json:"configs,omitempty"`
}

// The verification configs for Pylon. Only included if the ?include=verification.configs query param is present
type VerificationPylonConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationPylonType string

const (
	VerificationPylonTypePylon VerificationPylonType = "pylon"
)

func NewVerificationPylonTypeFromString(s string) (VerificationPylonType, error) {
	switch s {
	case "pylon":
		return VerificationPylonTypePylon, nil
	}
	var t VerificationPylonType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationPylonType) Ptr() *VerificationPylonType {
	return &v
}

type VerificationRecharge struct {
	Type    VerificationRechargeType     `json:"type,omitempty"`
	Configs *VerificationRechargeConfigs `json:"configs,omitempty"`
}

// The verification configs for Recharge. Only included if the ?include=verification.configs query param is present
type VerificationRechargeConfigs struct {
	WebhookSecretKey string                              `json:"webhook_secret_key"`
	Algorithm        HmacAlgorithms                      `json:"algorithm,omitempty"`
	HeaderKey        string                              `json:"header_key"`
	Encoding         VerificationRechargeConfigsEncoding `json:"encoding,omitempty"`
}

type VerificationRechargeConfigsEncoding string

const (
	VerificationRechargeConfigsEncodingBase64    VerificationRechargeConfigsEncoding = "base64"
	VerificationRechargeConfigsEncodingBase64Url VerificationRechargeConfigsEncoding = "base64url"
	VerificationRechargeConfigsEncodingHex       VerificationRechargeConfigsEncoding = "hex"
)

func NewVerificationRechargeConfigsEncodingFromString(s string) (VerificationRechargeConfigsEncoding, error) {
	switch s {
	case "base64":
		return VerificationRechargeConfigsEncodingBase64, nil
	case "base64url":
		return VerificationRechargeConfigsEncodingBase64Url, nil
	case "hex":
		return VerificationRechargeConfigsEncodingHex, nil
	}
	var t VerificationRechargeConfigsEncoding
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationRechargeConfigsEncoding) Ptr() *VerificationRechargeConfigsEncoding {
	return &v
}

type VerificationRechargeType string

const (
	VerificationRechargeTypeRecharge VerificationRechargeType = "recharge"
)

func NewVerificationRechargeTypeFromString(s string) (VerificationRechargeType, error) {
	switch s {
	case "recharge":
		return VerificationRechargeTypeRecharge, nil
	}
	var t VerificationRechargeType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationRechargeType) Ptr() *VerificationRechargeType {
	return &v
}

type VerificationRepay struct {
	Type    VerificationRepayType     `json:"type,omitempty"`
	Configs *VerificationRepayConfigs `json:"configs,omitempty"`
}

// The verification configs for Repay. Only included if the ?include=verification.configs query param is present
type VerificationRepayConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationRepayType string

const (
	VerificationRepayTypeRepay VerificationRepayType = "repay"
)

func NewVerificationRepayTypeFromString(s string) (VerificationRepayType, error) {
	switch s {
	case "repay":
		return VerificationRepayTypeRepay, nil
	}
	var t VerificationRepayType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationRepayType) Ptr() *VerificationRepayType {
	return &v
}

type VerificationSanity struct {
	Type    VerificationSanityType     `json:"type,omitempty"`
	Configs *VerificationSanityConfigs `json:"configs,omitempty"`
}

// The verification configs for Sanity. Only included if the ?include=verification.configs query param is present
type VerificationSanityConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationSanityType string

const (
	VerificationSanityTypeSanity VerificationSanityType = "sanity"
)

func NewVerificationSanityTypeFromString(s string) (VerificationSanityType, error) {
	switch s {
	case "sanity":
		return VerificationSanityTypeSanity, nil
	}
	var t VerificationSanityType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationSanityType) Ptr() *VerificationSanityType {
	return &v
}

type VerificationSendGrid struct {
	Type    VerificationSendGridType     `json:"type,omitempty"`
	Configs *VerificationSendGridConfigs `json:"configs,omitempty"`
}

// The verification configs for SendGrid. Only included if the ?include=verification.configs query param is present
type VerificationSendGridConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationSendGridType string

const (
	VerificationSendGridTypeSendgrid VerificationSendGridType = "sendgrid"
)

func NewVerificationSendGridTypeFromString(s string) (VerificationSendGridType, error) {
	switch s {
	case "sendgrid":
		return VerificationSendGridTypeSendgrid, nil
	}
	var t VerificationSendGridType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationSendGridType) Ptr() *VerificationSendGridType {
	return &v
}

type VerificationShopify struct {
	Type    VerificationShopifyType     `json:"type,omitempty"`
	Configs *VerificationShopifyConfigs `json:"configs,omitempty"`
}

// The verification configs for Shopify. Only included if the ?include=verification.configs query param is present
type VerificationShopifyConfigs struct {
	WebhookSecretKey string                                     `json:"webhook_secret_key"`
	RateLimitPeriod  *VerificationShopifyConfigsRateLimitPeriod `json:"rate_limit_period,omitempty"`
	RateLimit        *float64                                   `json:"rate_limit,omitempty"`
	ApiKey           *string                                    `json:"api_key,omitempty"`
	ApiSecret        *string                                    `json:"api_secret,omitempty"`
	Shop             *string                                    `json:"shop,omitempty"`
}

type VerificationShopifyConfigsRateLimitPeriod string

const (
	VerificationShopifyConfigsRateLimitPeriodMinute VerificationShopifyConfigsRateLimitPeriod = "minute"
	VerificationShopifyConfigsRateLimitPeriodSecond VerificationShopifyConfigsRateLimitPeriod = "second"
)

func NewVerificationShopifyConfigsRateLimitPeriodFromString(s string) (VerificationShopifyConfigsRateLimitPeriod, error) {
	switch s {
	case "minute":
		return VerificationShopifyConfigsRateLimitPeriodMinute, nil
	case "second":
		return VerificationShopifyConfigsRateLimitPeriodSecond, nil
	}
	var t VerificationShopifyConfigsRateLimitPeriod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationShopifyConfigsRateLimitPeriod) Ptr() *VerificationShopifyConfigsRateLimitPeriod {
	return &v
}

type VerificationShopifyType string

const (
	VerificationShopifyTypeShopify VerificationShopifyType = "shopify"
)

func NewVerificationShopifyTypeFromString(s string) (VerificationShopifyType, error) {
	switch s {
	case "shopify":
		return VerificationShopifyTypeShopify, nil
	}
	var t VerificationShopifyType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationShopifyType) Ptr() *VerificationShopifyType {
	return &v
}

type VerificationShopline struct {
	Type    VerificationShoplineType     `json:"type,omitempty"`
	Configs *VerificationShoplineConfigs `json:"configs,omitempty"`
}

// The verification configs for Shopline. Only included if the ?include=verification.configs query param is present
type VerificationShoplineConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationShoplineType string

const (
	VerificationShoplineTypeShopline VerificationShoplineType = "shopline"
)

func NewVerificationShoplineTypeFromString(s string) (VerificationShoplineType, error) {
	switch s {
	case "shopline":
		return VerificationShoplineTypeShopline, nil
	}
	var t VerificationShoplineType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationShoplineType) Ptr() *VerificationShoplineType {
	return &v
}

type VerificationSolidGate struct {
	Type    VerificationSolidGateType     `json:"type,omitempty"`
	Configs *VerificationSolidGateConfigs `json:"configs,omitempty"`
}

// The verification configs for SolidGate. Only included if the ?include=verification.configs query param is present
type VerificationSolidGateConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationSolidGateType string

const (
	VerificationSolidGateTypeSolidgate VerificationSolidGateType = "solidgate"
)

func NewVerificationSolidGateTypeFromString(s string) (VerificationSolidGateType, error) {
	switch s {
	case "solidgate":
		return VerificationSolidGateTypeSolidgate, nil
	}
	var t VerificationSolidGateType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationSolidGateType) Ptr() *VerificationSolidGateType {
	return &v
}

type VerificationSquare struct {
	Type    VerificationSquareType     `json:"type,omitempty"`
	Configs *VerificationSquareConfigs `json:"configs,omitempty"`
}

// The verification configs for Square. Only included if the ?include=verification.configs query param is present
type VerificationSquareConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationSquareType string

const (
	VerificationSquareTypeSquare VerificationSquareType = "square"
)

func NewVerificationSquareTypeFromString(s string) (VerificationSquareType, error) {
	switch s {
	case "square":
		return VerificationSquareTypeSquare, nil
	}
	var t VerificationSquareType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationSquareType) Ptr() *VerificationSquareType {
	return &v
}

type VerificationStripe struct {
	Type    VerificationStripeType     `json:"type,omitempty"`
	Configs *VerificationStripeConfigs `json:"configs,omitempty"`
}

// The verification configs for Stripe. Only included if the ?include=verification.configs query param is present
type VerificationStripeConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationStripeType string

const (
	VerificationStripeTypeStripe VerificationStripeType = "stripe"
)

func NewVerificationStripeTypeFromString(s string) (VerificationStripeType, error) {
	switch s {
	case "stripe":
		return VerificationStripeTypeStripe, nil
	}
	var t VerificationStripeType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationStripeType) Ptr() *VerificationStripeType {
	return &v
}

type VerificationSvix struct {
	Type    VerificationSvixType     `json:"type,omitempty"`
	Configs *VerificationSvixConfigs `json:"configs,omitempty"`
}

// The verification configs for Svix. Only included if the ?include=verification.configs query param is present
type VerificationSvixConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationSvixType string

const (
	VerificationSvixTypeSvix VerificationSvixType = "svix"
)

func NewVerificationSvixTypeFromString(s string) (VerificationSvixType, error) {
	switch s {
	case "svix":
		return VerificationSvixTypeSvix, nil
	}
	var t VerificationSvixType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationSvixType) Ptr() *VerificationSvixType {
	return &v
}

type VerificationSynctera struct {
	Type    VerificationSyncteraType     `json:"type,omitempty"`
	Configs *VerificationSyncteraConfigs `json:"configs,omitempty"`
}

// The verification configs for Synctera. Only included if the ?include=verification.configs query param is present
type VerificationSyncteraConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationSyncteraType string

const (
	VerificationSyncteraTypeSynctera VerificationSyncteraType = "synctera"
)

func NewVerificationSyncteraTypeFromString(s string) (VerificationSyncteraType, error) {
	switch s {
	case "synctera":
		return VerificationSyncteraTypeSynctera, nil
	}
	var t VerificationSyncteraType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationSyncteraType) Ptr() *VerificationSyncteraType {
	return &v
}

type VerificationTelnyx struct {
	Type    VerificationTelnyxType     `json:"type,omitempty"`
	Configs *VerificationTelnyxConfigs `json:"configs,omitempty"`
}

// The verification configs for Telnyx. Only included if the ?include=verification.configs query param is present
type VerificationTelnyxConfigs struct {
	PublicKey string `json:"public_key"`
}

type VerificationTelnyxType string

const (
	VerificationTelnyxTypeTelnyx VerificationTelnyxType = "telnyx"
)

func NewVerificationTelnyxTypeFromString(s string) (VerificationTelnyxType, error) {
	switch s {
	case "telnyx":
		return VerificationTelnyxTypeTelnyx, nil
	}
	var t VerificationTelnyxType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationTelnyxType) Ptr() *VerificationTelnyxType {
	return &v
}

type VerificationTokenIo struct {
	Type    VerificationTokenIoType     `json:"type,omitempty"`
	Configs *VerificationTokenIoConfigs `json:"configs,omitempty"`
}

// The verification configs for TokenIO. Only included if the ?include=verification.configs query param is present
type VerificationTokenIoConfigs struct {
	PublicKey string `json:"public_key"`
}

type VerificationTokenIoType string

const (
	VerificationTokenIoTypeTokenio VerificationTokenIoType = "tokenio"
)

func NewVerificationTokenIoTypeFromString(s string) (VerificationTokenIoType, error) {
	switch s {
	case "tokenio":
		return VerificationTokenIoTypeTokenio, nil
	}
	var t VerificationTokenIoType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationTokenIoType) Ptr() *VerificationTokenIoType {
	return &v
}

type VerificationTrello struct {
	Type    VerificationTrelloType     `json:"type,omitempty"`
	Configs *VerificationTrelloConfigs `json:"configs,omitempty"`
}

// The verification configs for Trello. Only included if the ?include=verification.configs query param is present
type VerificationTrelloConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationTrelloType string

const (
	VerificationTrelloTypeTrello VerificationTrelloType = "trello"
)

func NewVerificationTrelloTypeFromString(s string) (VerificationTrelloType, error) {
	switch s {
	case "trello":
		return VerificationTrelloTypeTrello, nil
	}
	var t VerificationTrelloType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationTrelloType) Ptr() *VerificationTrelloType {
	return &v
}

type VerificationTwilio struct {
	Type    VerificationTwilioType     `json:"type,omitempty"`
	Configs *VerificationTwilioConfigs `json:"configs,omitempty"`
}

// The verification configs for Twilio. Only included if the ?include=verification.configs query param is present
type VerificationTwilioConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationTwilioType string

const (
	VerificationTwilioTypeTwilio VerificationTwilioType = "twilio"
)

func NewVerificationTwilioTypeFromString(s string) (VerificationTwilioType, error) {
	switch s {
	case "twilio":
		return VerificationTwilioTypeTwilio, nil
	}
	var t VerificationTwilioType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationTwilioType) Ptr() *VerificationTwilioType {
	return &v
}

type VerificationTwitch struct {
	Type    VerificationTwitchType     `json:"type,omitempty"`
	Configs *VerificationTwitchConfigs `json:"configs,omitempty"`
}

// The verification configs for Twitch. Only included if the ?include=verification.configs query param is present
type VerificationTwitchConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationTwitchType string

const (
	VerificationTwitchTypeTwitch VerificationTwitchType = "twitch"
)

func NewVerificationTwitchTypeFromString(s string) (VerificationTwitchType, error) {
	switch s {
	case "twitch":
		return VerificationTwitchTypeTwitch, nil
	}
	var t VerificationTwitchType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationTwitchType) Ptr() *VerificationTwitchType {
	return &v
}

type VerificationTwitter struct {
	Type    VerificationTwitterType     `json:"type,omitempty"`
	Configs *VerificationTwitterConfigs `json:"configs,omitempty"`
}

// The verification configs for Twitter. Only included if the ?include=verification.configs query param is present
type VerificationTwitterConfigs struct {
	ApiKey string `json:"api_key"`
}

type VerificationTwitterType string

const (
	VerificationTwitterTypeTwitter VerificationTwitterType = "twitter"
)

func NewVerificationTwitterTypeFromString(s string) (VerificationTwitterType, error) {
	switch s {
	case "twitter":
		return VerificationTwitterTypeTwitter, nil
	}
	var t VerificationTwitterType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationTwitterType) Ptr() *VerificationTwitterType {
	return &v
}

type VerificationTypeform struct {
	Type    VerificationTypeformType     `json:"type,omitempty"`
	Configs *VerificationTypeformConfigs `json:"configs,omitempty"`
}

// The verification configs for Typeform. Only included if the ?include=verification.configs query param is present
type VerificationTypeformConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationTypeformType string

const (
	VerificationTypeformTypeTypeform VerificationTypeformType = "typeform"
)

func NewVerificationTypeformTypeFromString(s string) (VerificationTypeformType, error) {
	switch s {
	case "typeform":
		return VerificationTypeformTypeTypeform, nil
	}
	var t VerificationTypeformType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationTypeformType) Ptr() *VerificationTypeformType {
	return &v
}

type VerificationWix struct {
	Type    VerificationWixType     `json:"type,omitempty"`
	Configs *VerificationWixConfigs `json:"configs,omitempty"`
}

// The verification configs for Wix. Only included if the ?include=verification.configs query param is present
type VerificationWixConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationWixType string

const (
	VerificationWixTypeWix VerificationWixType = "wix"
)

func NewVerificationWixTypeFromString(s string) (VerificationWixType, error) {
	switch s {
	case "wix":
		return VerificationWixTypeWix, nil
	}
	var t VerificationWixType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationWixType) Ptr() *VerificationWixType {
	return &v
}

type VerificationWooCommerce struct {
	Type    VerificationWooCommerceType     `json:"type,omitempty"`
	Configs *VerificationWooCommerceConfigs `json:"configs,omitempty"`
}

// The verification configs for WooCommerce. Only included if the ?include=verification.configs query param is present
type VerificationWooCommerceConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationWooCommerceType string

const (
	VerificationWooCommerceTypeWoocommerce VerificationWooCommerceType = "woocommerce"
)

func NewVerificationWooCommerceTypeFromString(s string) (VerificationWooCommerceType, error) {
	switch s {
	case "woocommerce":
		return VerificationWooCommerceTypeWoocommerce, nil
	}
	var t VerificationWooCommerceType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationWooCommerceType) Ptr() *VerificationWooCommerceType {
	return &v
}

type VerificationWorkOs struct {
	Type    VerificationWorkOsType     `json:"type,omitempty"`
	Configs *VerificationWorkOsConfigs `json:"configs,omitempty"`
}

// The verification configs for WorkOS. Only included if the ?include=verification.configs query param is present
type VerificationWorkOsConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationWorkOsType string

const (
	VerificationWorkOsTypeWorkos VerificationWorkOsType = "workos"
)

func NewVerificationWorkOsTypeFromString(s string) (VerificationWorkOsType, error) {
	switch s {
	case "workos":
		return VerificationWorkOsTypeWorkos, nil
	}
	var t VerificationWorkOsType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationWorkOsType) Ptr() *VerificationWorkOsType {
	return &v
}

type VerificationXero struct {
	Type    VerificationXeroType     `json:"type,omitempty"`
	Configs *VerificationXeroConfigs `json:"configs,omitempty"`
}

// The verification configs for Xero. Only included if the ?include=verification.configs query param is present
type VerificationXeroConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationXeroType string

const (
	VerificationXeroTypeXero VerificationXeroType = "xero"
)

func NewVerificationXeroTypeFromString(s string) (VerificationXeroType, error) {
	switch s {
	case "xero":
		return VerificationXeroTypeXero, nil
	}
	var t VerificationXeroType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationXeroType) Ptr() *VerificationXeroType {
	return &v
}

type VerificationZoom struct {
	Type    VerificationZoomType     `json:"type,omitempty"`
	Configs *VerificationZoomConfigs `json:"configs,omitempty"`
}

// The verification configs for Zoom. Only included if the ?include=verification.configs query param is present
type VerificationZoomConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationZoomType string

const (
	VerificationZoomTypeZoom VerificationZoomType = "zoom"
)

func NewVerificationZoomTypeFromString(s string) (VerificationZoomType, error) {
	switch s {
	case "zoom":
		return VerificationZoomTypeZoom, nil
	}
	var t VerificationZoomType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationZoomType) Ptr() *VerificationZoomType {
	return &v
}

// Period to rate limit attempts
type ConnectionCreateRequestDestinationRateLimitPeriod string

const (
	ConnectionCreateRequestDestinationRateLimitPeriodSecond ConnectionCreateRequestDestinationRateLimitPeriod = "second"
	ConnectionCreateRequestDestinationRateLimitPeriodMinute ConnectionCreateRequestDestinationRateLimitPeriod = "minute"
	ConnectionCreateRequestDestinationRateLimitPeriodHour   ConnectionCreateRequestDestinationRateLimitPeriod = "hour"
)

func NewConnectionCreateRequestDestinationRateLimitPeriodFromString(s string) (ConnectionCreateRequestDestinationRateLimitPeriod, error) {
	switch s {
	case "second":
		return ConnectionCreateRequestDestinationRateLimitPeriodSecond, nil
	case "minute":
		return ConnectionCreateRequestDestinationRateLimitPeriodMinute, nil
	case "hour":
		return ConnectionCreateRequestDestinationRateLimitPeriodHour, nil
	}
	var t ConnectionCreateRequestDestinationRateLimitPeriod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConnectionCreateRequestDestinationRateLimitPeriod) Ptr() *ConnectionCreateRequestDestinationRateLimitPeriod {
	return &c
}

// Period to rate limit attempts
type ConnectionUpsertRequestDestinationRateLimitPeriod string

const (
	ConnectionUpsertRequestDestinationRateLimitPeriodSecond ConnectionUpsertRequestDestinationRateLimitPeriod = "second"
	ConnectionUpsertRequestDestinationRateLimitPeriodMinute ConnectionUpsertRequestDestinationRateLimitPeriod = "minute"
	ConnectionUpsertRequestDestinationRateLimitPeriodHour   ConnectionUpsertRequestDestinationRateLimitPeriod = "hour"
)

func NewConnectionUpsertRequestDestinationRateLimitPeriodFromString(s string) (ConnectionUpsertRequestDestinationRateLimitPeriod, error) {
	switch s {
	case "second":
		return ConnectionUpsertRequestDestinationRateLimitPeriodSecond, nil
	case "minute":
		return ConnectionUpsertRequestDestinationRateLimitPeriodMinute, nil
	case "hour":
		return ConnectionUpsertRequestDestinationRateLimitPeriodHour, nil
	}
	var t ConnectionUpsertRequestDestinationRateLimitPeriod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConnectionUpsertRequestDestinationRateLimitPeriod) Ptr() *ConnectionUpsertRequestDestinationRateLimitPeriod {
	return &c
}

// Filter by number of attempts
type EventBulkRetryCreateRequestQueryAttempts struct {
	typeName                                    string
	Integer                                     int
	EventBulkRetryCreateRequestQueryAttemptsAll *EventBulkRetryCreateRequestQueryAttemptsAll
}

func NewEventBulkRetryCreateRequestQueryAttemptsFromInteger(value int) *EventBulkRetryCreateRequestQueryAttempts {
	return &EventBulkRetryCreateRequestQueryAttempts{typeName: "integer", Integer: value}
}

func NewEventBulkRetryCreateRequestQueryAttemptsFromEventBulkRetryCreateRequestQueryAttemptsAll(value *EventBulkRetryCreateRequestQueryAttemptsAll) *EventBulkRetryCreateRequestQueryAttempts {
	return &EventBulkRetryCreateRequestQueryAttempts{typeName: "eventBulkRetryCreateRequestQueryAttemptsAll", EventBulkRetryCreateRequestQueryAttemptsAll: value}
}

func (e *EventBulkRetryCreateRequestQueryAttempts) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		e.typeName = "integer"
		e.Integer = valueInteger
		return nil
	}
	valueEventBulkRetryCreateRequestQueryAttemptsAll := new(EventBulkRetryCreateRequestQueryAttemptsAll)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQueryAttemptsAll); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQueryAttemptsAll"
		e.EventBulkRetryCreateRequestQueryAttemptsAll = valueEventBulkRetryCreateRequestQueryAttemptsAll
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryAttempts) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "integer":
		return json.Marshal(e.Integer)
	case "eventBulkRetryCreateRequestQueryAttemptsAll":
		return json.Marshal(e.EventBulkRetryCreateRequestQueryAttemptsAll)
	}
}

type EventBulkRetryCreateRequestQueryAttemptsVisitor interface {
	VisitInteger(int) error
	VisitEventBulkRetryCreateRequestQueryAttemptsAll(*EventBulkRetryCreateRequestQueryAttemptsAll) error
}

func (e *EventBulkRetryCreateRequestQueryAttempts) Accept(visitor EventBulkRetryCreateRequestQueryAttemptsVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "integer":
		return visitor.VisitInteger(e.Integer)
	case "eventBulkRetryCreateRequestQueryAttemptsAll":
		return visitor.VisitEventBulkRetryCreateRequestQueryAttemptsAll(e.EventBulkRetryCreateRequestQueryAttemptsAll)
	}
}

type EventBulkRetryCreateRequestQueryAttemptsAll struct {
	Gt       *int  `json:"gt,omitempty"`
	Gte      *int  `json:"gte,omitempty"`
	Le       *int  `json:"le,omitempty"`
	Lte      *int  `json:"lte,omitempty"`
	Any      *bool `json:"any,omitempty"`
	All      *bool `json:"all,omitempty"`
	Contains *int  `json:"contains,omitempty"`
}

// URL Encoded string of the JSON to match to the data body
type EventBulkRetryCreateRequestQueryBody struct {
	typeName                                string
	String                                  string
	EventBulkRetryCreateRequestQueryBodyOne *EventBulkRetryCreateRequestQueryBodyOne
}

func NewEventBulkRetryCreateRequestQueryBodyFromString(value string) *EventBulkRetryCreateRequestQueryBody {
	return &EventBulkRetryCreateRequestQueryBody{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryBodyFromEventBulkRetryCreateRequestQueryBodyOne(value *EventBulkRetryCreateRequestQueryBodyOne) *EventBulkRetryCreateRequestQueryBody {
	return &EventBulkRetryCreateRequestQueryBody{typeName: "eventBulkRetryCreateRequestQueryBodyOne", EventBulkRetryCreateRequestQueryBodyOne: value}
}

func (e *EventBulkRetryCreateRequestQueryBody) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEventBulkRetryCreateRequestQueryBodyOne := new(EventBulkRetryCreateRequestQueryBodyOne)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQueryBodyOne); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQueryBodyOne"
		e.EventBulkRetryCreateRequestQueryBodyOne = valueEventBulkRetryCreateRequestQueryBodyOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryBody) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "eventBulkRetryCreateRequestQueryBodyOne":
		return json.Marshal(e.EventBulkRetryCreateRequestQueryBodyOne)
	}
}

type EventBulkRetryCreateRequestQueryBodyVisitor interface {
	VisitString(string) error
	VisitEventBulkRetryCreateRequestQueryBodyOne(*EventBulkRetryCreateRequestQueryBodyOne) error
}

func (e *EventBulkRetryCreateRequestQueryBody) Accept(visitor EventBulkRetryCreateRequestQueryBodyVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "eventBulkRetryCreateRequestQueryBodyOne":
		return visitor.VisitEventBulkRetryCreateRequestQueryBodyOne(e.EventBulkRetryCreateRequestQueryBodyOne)
	}
}

type EventBulkRetryCreateRequestQueryBodyOne struct {
}

type EventBulkRetryCreateRequestQueryBulkRetryId struct {
	typeName   string
	String     string
	StringList []string
}

func NewEventBulkRetryCreateRequestQueryBulkRetryIdFromString(value string) *EventBulkRetryCreateRequestQueryBulkRetryId {
	return &EventBulkRetryCreateRequestQueryBulkRetryId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryBulkRetryIdFromStringList(value []string) *EventBulkRetryCreateRequestQueryBulkRetryId {
	return &EventBulkRetryCreateRequestQueryBulkRetryId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQueryBulkRetryId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryBulkRetryId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryBulkRetryIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQueryBulkRetryId) Accept(visitor EventBulkRetryCreateRequestQueryBulkRetryIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

// Filter by CLI IDs. `?[any]=true` operator for any CLI.
type EventBulkRetryCreateRequestQueryCliId struct {
	typeName                                 string
	String                                   string
	EventBulkRetryCreateRequestQueryCliIdAll *EventBulkRetryCreateRequestQueryCliIdAll
	StringList                               []string
}

func NewEventBulkRetryCreateRequestQueryCliIdFromString(value string) *EventBulkRetryCreateRequestQueryCliId {
	return &EventBulkRetryCreateRequestQueryCliId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryCliIdFromEventBulkRetryCreateRequestQueryCliIdAll(value *EventBulkRetryCreateRequestQueryCliIdAll) *EventBulkRetryCreateRequestQueryCliId {
	return &EventBulkRetryCreateRequestQueryCliId{typeName: "eventBulkRetryCreateRequestQueryCliIdAll", EventBulkRetryCreateRequestQueryCliIdAll: value}
}

func NewEventBulkRetryCreateRequestQueryCliIdFromStringList(value []string) *EventBulkRetryCreateRequestQueryCliId {
	return &EventBulkRetryCreateRequestQueryCliId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQueryCliId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEventBulkRetryCreateRequestQueryCliIdAll := new(EventBulkRetryCreateRequestQueryCliIdAll)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQueryCliIdAll); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQueryCliIdAll"
		e.EventBulkRetryCreateRequestQueryCliIdAll = valueEventBulkRetryCreateRequestQueryCliIdAll
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryCliId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "eventBulkRetryCreateRequestQueryCliIdAll":
		return json.Marshal(e.EventBulkRetryCreateRequestQueryCliIdAll)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryCliIdVisitor interface {
	VisitString(string) error
	VisitEventBulkRetryCreateRequestQueryCliIdAll(*EventBulkRetryCreateRequestQueryCliIdAll) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQueryCliId) Accept(visitor EventBulkRetryCreateRequestQueryCliIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "eventBulkRetryCreateRequestQueryCliIdAll":
		return visitor.VisitEventBulkRetryCreateRequestQueryCliIdAll(e.EventBulkRetryCreateRequestQueryCliIdAll)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryCliIdAll struct {
	Any *bool `json:"any,omitempty"`
	All *bool `json:"all,omitempty"`
}

type EventBulkRetryCreateRequestQueryCliUserId struct {
	typeName   string
	String     string
	StringList []string
}

func NewEventBulkRetryCreateRequestQueryCliUserIdFromString(value string) *EventBulkRetryCreateRequestQueryCliUserId {
	return &EventBulkRetryCreateRequestQueryCliUserId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryCliUserIdFromStringList(value []string) *EventBulkRetryCreateRequestQueryCliUserId {
	return &EventBulkRetryCreateRequestQueryCliUserId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQueryCliUserId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryCliUserId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryCliUserIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQueryCliUserId) Accept(visitor EventBulkRetryCreateRequestQueryCliUserIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

// Filter by `created_at` date using a date operator
type EventBulkRetryCreateRequestQueryCreatedAt struct {
	typeName                                     string
	DateTime                                     time.Time
	EventBulkRetryCreateRequestQueryCreatedAtAny *EventBulkRetryCreateRequestQueryCreatedAtAny
}

func NewEventBulkRetryCreateRequestQueryCreatedAtFromDateTime(value time.Time) *EventBulkRetryCreateRequestQueryCreatedAt {
	return &EventBulkRetryCreateRequestQueryCreatedAt{typeName: "dateTime", DateTime: value}
}

func NewEventBulkRetryCreateRequestQueryCreatedAtFromEventBulkRetryCreateRequestQueryCreatedAtAny(value *EventBulkRetryCreateRequestQueryCreatedAtAny) *EventBulkRetryCreateRequestQueryCreatedAt {
	return &EventBulkRetryCreateRequestQueryCreatedAt{typeName: "eventBulkRetryCreateRequestQueryCreatedAtAny", EventBulkRetryCreateRequestQueryCreatedAtAny: value}
}

func (e *EventBulkRetryCreateRequestQueryCreatedAt) UnmarshalJSON(data []byte) error {
	var valueDateTime time.Time
	if err := json.Unmarshal(data, &valueDateTime); err == nil {
		e.typeName = "dateTime"
		e.DateTime = valueDateTime
		return nil
	}
	valueEventBulkRetryCreateRequestQueryCreatedAtAny := new(EventBulkRetryCreateRequestQueryCreatedAtAny)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQueryCreatedAtAny); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQueryCreatedAtAny"
		e.EventBulkRetryCreateRequestQueryCreatedAtAny = valueEventBulkRetryCreateRequestQueryCreatedAtAny
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryCreatedAt) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "dateTime":
		return json.Marshal(e.DateTime)
	case "eventBulkRetryCreateRequestQueryCreatedAtAny":
		return json.Marshal(e.EventBulkRetryCreateRequestQueryCreatedAtAny)
	}
}

type EventBulkRetryCreateRequestQueryCreatedAtVisitor interface {
	VisitDateTime(time.Time) error
	VisitEventBulkRetryCreateRequestQueryCreatedAtAny(*EventBulkRetryCreateRequestQueryCreatedAtAny) error
}

func (e *EventBulkRetryCreateRequestQueryCreatedAt) Accept(visitor EventBulkRetryCreateRequestQueryCreatedAtVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "dateTime":
		return visitor.VisitDateTime(e.DateTime)
	case "eventBulkRetryCreateRequestQueryCreatedAtAny":
		return visitor.VisitEventBulkRetryCreateRequestQueryCreatedAtAny(e.EventBulkRetryCreateRequestQueryCreatedAtAny)
	}
}

type EventBulkRetryCreateRequestQueryCreatedAtAny struct {
	Gt  *time.Time `json:"gt,omitempty"`
	Gte *time.Time `json:"gte,omitempty"`
	Le  *time.Time `json:"le,omitempty"`
	Lte *time.Time `json:"lte,omitempty"`
	Any *bool      `json:"any,omitempty"`
}

// Filter by destination IDs
type EventBulkRetryCreateRequestQueryDestinationId struct {
	typeName string
	// Destination ID
	String     string
	StringList []string
}

func NewEventBulkRetryCreateRequestQueryDestinationIdFromString(value string) *EventBulkRetryCreateRequestQueryDestinationId {
	return &EventBulkRetryCreateRequestQueryDestinationId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryDestinationIdFromStringList(value []string) *EventBulkRetryCreateRequestQueryDestinationId {
	return &EventBulkRetryCreateRequestQueryDestinationId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQueryDestinationId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryDestinationId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryDestinationIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQueryDestinationId) Accept(visitor EventBulkRetryCreateRequestQueryDestinationIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

// Filter by error code code
type EventBulkRetryCreateRequestQueryErrorCode struct {
	typeName              string
	AttemptErrorCodes     AttemptErrorCodes
	AttemptErrorCodesList []AttemptErrorCodes
}

func NewEventBulkRetryCreateRequestQueryErrorCodeFromAttemptErrorCodes(value AttemptErrorCodes) *EventBulkRetryCreateRequestQueryErrorCode {
	return &EventBulkRetryCreateRequestQueryErrorCode{typeName: "attemptErrorCodes", AttemptErrorCodes: value}
}

func NewEventBulkRetryCreateRequestQueryErrorCodeFromAttemptErrorCodesList(value []AttemptErrorCodes) *EventBulkRetryCreateRequestQueryErrorCode {
	return &EventBulkRetryCreateRequestQueryErrorCode{typeName: "attemptErrorCodesList", AttemptErrorCodesList: value}
}

func (e *EventBulkRetryCreateRequestQueryErrorCode) UnmarshalJSON(data []byte) error {
	var valueAttemptErrorCodes AttemptErrorCodes
	if err := json.Unmarshal(data, &valueAttemptErrorCodes); err == nil {
		e.typeName = "attemptErrorCodes"
		e.AttemptErrorCodes = valueAttemptErrorCodes
		return nil
	}
	var valueAttemptErrorCodesList []AttemptErrorCodes
	if err := json.Unmarshal(data, &valueAttemptErrorCodesList); err == nil {
		e.typeName = "attemptErrorCodesList"
		e.AttemptErrorCodesList = valueAttemptErrorCodesList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryErrorCode) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "attemptErrorCodes":
		return json.Marshal(e.AttemptErrorCodes)
	case "attemptErrorCodesList":
		return json.Marshal(e.AttemptErrorCodesList)
	}
}

type EventBulkRetryCreateRequestQueryErrorCodeVisitor interface {
	VisitAttemptErrorCodes(AttemptErrorCodes) error
	VisitAttemptErrorCodesList([]AttemptErrorCodes) error
}

func (e *EventBulkRetryCreateRequestQueryErrorCode) Accept(visitor EventBulkRetryCreateRequestQueryErrorCodeVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "attemptErrorCodes":
		return visitor.VisitAttemptErrorCodes(e.AttemptErrorCodes)
	case "attemptErrorCodesList":
		return visitor.VisitAttemptErrorCodesList(e.AttemptErrorCodesList)
	}
}

type EventBulkRetryCreateRequestQueryEventDataId struct {
	typeName   string
	String     string
	StringList []string
}

func NewEventBulkRetryCreateRequestQueryEventDataIdFromString(value string) *EventBulkRetryCreateRequestQueryEventDataId {
	return &EventBulkRetryCreateRequestQueryEventDataId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryEventDataIdFromStringList(value []string) *EventBulkRetryCreateRequestQueryEventDataId {
	return &EventBulkRetryCreateRequestQueryEventDataId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQueryEventDataId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryEventDataId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryEventDataIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQueryEventDataId) Accept(visitor EventBulkRetryCreateRequestQueryEventDataIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

// URL Encoded string of the JSON to match to the data headers
type EventBulkRetryCreateRequestQueryHeaders struct {
	typeName                                   string
	String                                     string
	EventBulkRetryCreateRequestQueryHeadersOne *EventBulkRetryCreateRequestQueryHeadersOne
}

func NewEventBulkRetryCreateRequestQueryHeadersFromString(value string) *EventBulkRetryCreateRequestQueryHeaders {
	return &EventBulkRetryCreateRequestQueryHeaders{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryHeadersFromEventBulkRetryCreateRequestQueryHeadersOne(value *EventBulkRetryCreateRequestQueryHeadersOne) *EventBulkRetryCreateRequestQueryHeaders {
	return &EventBulkRetryCreateRequestQueryHeaders{typeName: "eventBulkRetryCreateRequestQueryHeadersOne", EventBulkRetryCreateRequestQueryHeadersOne: value}
}

func (e *EventBulkRetryCreateRequestQueryHeaders) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEventBulkRetryCreateRequestQueryHeadersOne := new(EventBulkRetryCreateRequestQueryHeadersOne)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQueryHeadersOne); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQueryHeadersOne"
		e.EventBulkRetryCreateRequestQueryHeadersOne = valueEventBulkRetryCreateRequestQueryHeadersOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryHeaders) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "eventBulkRetryCreateRequestQueryHeadersOne":
		return json.Marshal(e.EventBulkRetryCreateRequestQueryHeadersOne)
	}
}

type EventBulkRetryCreateRequestQueryHeadersVisitor interface {
	VisitString(string) error
	VisitEventBulkRetryCreateRequestQueryHeadersOne(*EventBulkRetryCreateRequestQueryHeadersOne) error
}

func (e *EventBulkRetryCreateRequestQueryHeaders) Accept(visitor EventBulkRetryCreateRequestQueryHeadersVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "eventBulkRetryCreateRequestQueryHeadersOne":
		return visitor.VisitEventBulkRetryCreateRequestQueryHeadersOne(e.EventBulkRetryCreateRequestQueryHeadersOne)
	}
}

type EventBulkRetryCreateRequestQueryHeadersOne struct {
}

// Filter by event IDs
type EventBulkRetryCreateRequestQueryId struct {
	typeName string
	// Event ID
	String     string
	StringList []string
}

func NewEventBulkRetryCreateRequestQueryIdFromString(value string) *EventBulkRetryCreateRequestQueryId {
	return &EventBulkRetryCreateRequestQueryId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryIdFromStringList(value []string) *EventBulkRetryCreateRequestQueryId {
	return &EventBulkRetryCreateRequestQueryId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQueryId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQueryId) Accept(visitor EventBulkRetryCreateRequestQueryIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryIssueId struct {
	typeName   string
	String     string
	StringList []string
}

func NewEventBulkRetryCreateRequestQueryIssueIdFromString(value string) *EventBulkRetryCreateRequestQueryIssueId {
	return &EventBulkRetryCreateRequestQueryIssueId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryIssueIdFromStringList(value []string) *EventBulkRetryCreateRequestQueryIssueId {
	return &EventBulkRetryCreateRequestQueryIssueId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQueryIssueId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryIssueId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryIssueIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQueryIssueId) Accept(visitor EventBulkRetryCreateRequestQueryIssueIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

// Filter by `last_attempt_at` date using a date operator
type EventBulkRetryCreateRequestQueryLastAttemptAt struct {
	typeName                                         string
	DateTime                                         time.Time
	EventBulkRetryCreateRequestQueryLastAttemptAtAny *EventBulkRetryCreateRequestQueryLastAttemptAtAny
}

func NewEventBulkRetryCreateRequestQueryLastAttemptAtFromDateTime(value time.Time) *EventBulkRetryCreateRequestQueryLastAttemptAt {
	return &EventBulkRetryCreateRequestQueryLastAttemptAt{typeName: "dateTime", DateTime: value}
}

func NewEventBulkRetryCreateRequestQueryLastAttemptAtFromEventBulkRetryCreateRequestQueryLastAttemptAtAny(value *EventBulkRetryCreateRequestQueryLastAttemptAtAny) *EventBulkRetryCreateRequestQueryLastAttemptAt {
	return &EventBulkRetryCreateRequestQueryLastAttemptAt{typeName: "eventBulkRetryCreateRequestQueryLastAttemptAtAny", EventBulkRetryCreateRequestQueryLastAttemptAtAny: value}
}

func (e *EventBulkRetryCreateRequestQueryLastAttemptAt) UnmarshalJSON(data []byte) error {
	var valueDateTime time.Time
	if err := json.Unmarshal(data, &valueDateTime); err == nil {
		e.typeName = "dateTime"
		e.DateTime = valueDateTime
		return nil
	}
	valueEventBulkRetryCreateRequestQueryLastAttemptAtAny := new(EventBulkRetryCreateRequestQueryLastAttemptAtAny)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQueryLastAttemptAtAny); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQueryLastAttemptAtAny"
		e.EventBulkRetryCreateRequestQueryLastAttemptAtAny = valueEventBulkRetryCreateRequestQueryLastAttemptAtAny
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryLastAttemptAt) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "dateTime":
		return json.Marshal(e.DateTime)
	case "eventBulkRetryCreateRequestQueryLastAttemptAtAny":
		return json.Marshal(e.EventBulkRetryCreateRequestQueryLastAttemptAtAny)
	}
}

type EventBulkRetryCreateRequestQueryLastAttemptAtVisitor interface {
	VisitDateTime(time.Time) error
	VisitEventBulkRetryCreateRequestQueryLastAttemptAtAny(*EventBulkRetryCreateRequestQueryLastAttemptAtAny) error
}

func (e *EventBulkRetryCreateRequestQueryLastAttemptAt) Accept(visitor EventBulkRetryCreateRequestQueryLastAttemptAtVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "dateTime":
		return visitor.VisitDateTime(e.DateTime)
	case "eventBulkRetryCreateRequestQueryLastAttemptAtAny":
		return visitor.VisitEventBulkRetryCreateRequestQueryLastAttemptAtAny(e.EventBulkRetryCreateRequestQueryLastAttemptAtAny)
	}
}

type EventBulkRetryCreateRequestQueryLastAttemptAtAny struct {
	Gt  *time.Time `json:"gt,omitempty"`
	Gte *time.Time `json:"gte,omitempty"`
	Le  *time.Time `json:"le,omitempty"`
	Lte *time.Time `json:"lte,omitempty"`
	Any *bool      `json:"any,omitempty"`
}

// URL Encoded string of the JSON to match to the parsed query (JSON representation of the query)
type EventBulkRetryCreateRequestQueryParsedQuery struct {
	typeName                                       string
	String                                         string
	EventBulkRetryCreateRequestQueryParsedQueryOne *EventBulkRetryCreateRequestQueryParsedQueryOne
}

func NewEventBulkRetryCreateRequestQueryParsedQueryFromString(value string) *EventBulkRetryCreateRequestQueryParsedQuery {
	return &EventBulkRetryCreateRequestQueryParsedQuery{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryParsedQueryFromEventBulkRetryCreateRequestQueryParsedQueryOne(value *EventBulkRetryCreateRequestQueryParsedQueryOne) *EventBulkRetryCreateRequestQueryParsedQuery {
	return &EventBulkRetryCreateRequestQueryParsedQuery{typeName: "eventBulkRetryCreateRequestQueryParsedQueryOne", EventBulkRetryCreateRequestQueryParsedQueryOne: value}
}

func (e *EventBulkRetryCreateRequestQueryParsedQuery) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEventBulkRetryCreateRequestQueryParsedQueryOne := new(EventBulkRetryCreateRequestQueryParsedQueryOne)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQueryParsedQueryOne); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQueryParsedQueryOne"
		e.EventBulkRetryCreateRequestQueryParsedQueryOne = valueEventBulkRetryCreateRequestQueryParsedQueryOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryParsedQuery) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "eventBulkRetryCreateRequestQueryParsedQueryOne":
		return json.Marshal(e.EventBulkRetryCreateRequestQueryParsedQueryOne)
	}
}

type EventBulkRetryCreateRequestQueryParsedQueryVisitor interface {
	VisitString(string) error
	VisitEventBulkRetryCreateRequestQueryParsedQueryOne(*EventBulkRetryCreateRequestQueryParsedQueryOne) error
}

func (e *EventBulkRetryCreateRequestQueryParsedQuery) Accept(visitor EventBulkRetryCreateRequestQueryParsedQueryVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "eventBulkRetryCreateRequestQueryParsedQueryOne":
		return visitor.VisitEventBulkRetryCreateRequestQueryParsedQueryOne(e.EventBulkRetryCreateRequestQueryParsedQueryOne)
	}
}

type EventBulkRetryCreateRequestQueryParsedQueryOne struct {
}

// Filter by HTTP response status code
type EventBulkRetryCreateRequestQueryResponseStatus struct {
	typeName                                          string
	Integer                                           int
	EventBulkRetryCreateRequestQueryResponseStatusAll *EventBulkRetryCreateRequestQueryResponseStatusAll
	IntegerList                                       []int
}

func NewEventBulkRetryCreateRequestQueryResponseStatusFromInteger(value int) *EventBulkRetryCreateRequestQueryResponseStatus {
	return &EventBulkRetryCreateRequestQueryResponseStatus{typeName: "integer", Integer: value}
}

func NewEventBulkRetryCreateRequestQueryResponseStatusFromEventBulkRetryCreateRequestQueryResponseStatusAll(value *EventBulkRetryCreateRequestQueryResponseStatusAll) *EventBulkRetryCreateRequestQueryResponseStatus {
	return &EventBulkRetryCreateRequestQueryResponseStatus{typeName: "eventBulkRetryCreateRequestQueryResponseStatusAll", EventBulkRetryCreateRequestQueryResponseStatusAll: value}
}

func NewEventBulkRetryCreateRequestQueryResponseStatusFromIntegerList(value []int) *EventBulkRetryCreateRequestQueryResponseStatus {
	return &EventBulkRetryCreateRequestQueryResponseStatus{typeName: "integerList", IntegerList: value}
}

func (e *EventBulkRetryCreateRequestQueryResponseStatus) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		e.typeName = "integer"
		e.Integer = valueInteger
		return nil
	}
	valueEventBulkRetryCreateRequestQueryResponseStatusAll := new(EventBulkRetryCreateRequestQueryResponseStatusAll)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQueryResponseStatusAll); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQueryResponseStatusAll"
		e.EventBulkRetryCreateRequestQueryResponseStatusAll = valueEventBulkRetryCreateRequestQueryResponseStatusAll
		return nil
	}
	var valueIntegerList []int
	if err := json.Unmarshal(data, &valueIntegerList); err == nil {
		e.typeName = "integerList"
		e.IntegerList = valueIntegerList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryResponseStatus) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "integer":
		return json.Marshal(e.Integer)
	case "eventBulkRetryCreateRequestQueryResponseStatusAll":
		return json.Marshal(e.EventBulkRetryCreateRequestQueryResponseStatusAll)
	case "integerList":
		return json.Marshal(e.IntegerList)
	}
}

type EventBulkRetryCreateRequestQueryResponseStatusVisitor interface {
	VisitInteger(int) error
	VisitEventBulkRetryCreateRequestQueryResponseStatusAll(*EventBulkRetryCreateRequestQueryResponseStatusAll) error
	VisitIntegerList([]int) error
}

func (e *EventBulkRetryCreateRequestQueryResponseStatus) Accept(visitor EventBulkRetryCreateRequestQueryResponseStatusVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "integer":
		return visitor.VisitInteger(e.Integer)
	case "eventBulkRetryCreateRequestQueryResponseStatusAll":
		return visitor.VisitEventBulkRetryCreateRequestQueryResponseStatusAll(e.EventBulkRetryCreateRequestQueryResponseStatusAll)
	case "integerList":
		return visitor.VisitIntegerList(e.IntegerList)
	}
}

type EventBulkRetryCreateRequestQueryResponseStatusAll struct {
	Gt       *int  `json:"gt,omitempty"`
	Gte      *int  `json:"gte,omitempty"`
	Le       *int  `json:"le,omitempty"`
	Lte      *int  `json:"lte,omitempty"`
	Any      *bool `json:"any,omitempty"`
	All      *bool `json:"all,omitempty"`
	Contains *int  `json:"contains,omitempty"`
}

// Filter by source IDs
type EventBulkRetryCreateRequestQuerySourceId struct {
	typeName string
	// Source ID
	String     string
	StringList []string
}

func NewEventBulkRetryCreateRequestQuerySourceIdFromString(value string) *EventBulkRetryCreateRequestQuerySourceId {
	return &EventBulkRetryCreateRequestQuerySourceId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQuerySourceIdFromStringList(value []string) *EventBulkRetryCreateRequestQuerySourceId {
	return &EventBulkRetryCreateRequestQuerySourceId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQuerySourceId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQuerySourceId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQuerySourceIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQuerySourceId) Accept(visitor EventBulkRetryCreateRequestQuerySourceIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

// Lifecyle status of the event
type EventBulkRetryCreateRequestQueryStatus struct {
	typeName        string
	EventStatus     EventStatus
	EventStatusList []EventStatus
}

func NewEventBulkRetryCreateRequestQueryStatusFromEventStatus(value EventStatus) *EventBulkRetryCreateRequestQueryStatus {
	return &EventBulkRetryCreateRequestQueryStatus{typeName: "eventStatus", EventStatus: value}
}

func NewEventBulkRetryCreateRequestQueryStatusFromEventStatusList(value []EventStatus) *EventBulkRetryCreateRequestQueryStatus {
	return &EventBulkRetryCreateRequestQueryStatus{typeName: "eventStatusList", EventStatusList: value}
}

func (e *EventBulkRetryCreateRequestQueryStatus) UnmarshalJSON(data []byte) error {
	var valueEventStatus EventStatus
	if err := json.Unmarshal(data, &valueEventStatus); err == nil {
		e.typeName = "eventStatus"
		e.EventStatus = valueEventStatus
		return nil
	}
	var valueEventStatusList []EventStatus
	if err := json.Unmarshal(data, &valueEventStatusList); err == nil {
		e.typeName = "eventStatusList"
		e.EventStatusList = valueEventStatusList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryStatus) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "eventStatus":
		return json.Marshal(e.EventStatus)
	case "eventStatusList":
		return json.Marshal(e.EventStatusList)
	}
}

type EventBulkRetryCreateRequestQueryStatusVisitor interface {
	VisitEventStatus(EventStatus) error
	VisitEventStatusList([]EventStatus) error
}

func (e *EventBulkRetryCreateRequestQueryStatus) Accept(visitor EventBulkRetryCreateRequestQueryStatusVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "eventStatus":
		return visitor.VisitEventStatus(e.EventStatus)
	case "eventStatusList":
		return visitor.VisitEventStatusList(e.EventStatusList)
	}
}

// Filter by `successful_at` date using a date operator
type EventBulkRetryCreateRequestQuerySuccessfulAt struct {
	typeName                                        string
	DateTime                                        time.Time
	EventBulkRetryCreateRequestQuerySuccessfulAtAny *EventBulkRetryCreateRequestQuerySuccessfulAtAny
}

func NewEventBulkRetryCreateRequestQuerySuccessfulAtFromDateTime(value time.Time) *EventBulkRetryCreateRequestQuerySuccessfulAt {
	return &EventBulkRetryCreateRequestQuerySuccessfulAt{typeName: "dateTime", DateTime: value}
}

func NewEventBulkRetryCreateRequestQuerySuccessfulAtFromEventBulkRetryCreateRequestQuerySuccessfulAtAny(value *EventBulkRetryCreateRequestQuerySuccessfulAtAny) *EventBulkRetryCreateRequestQuerySuccessfulAt {
	return &EventBulkRetryCreateRequestQuerySuccessfulAt{typeName: "eventBulkRetryCreateRequestQuerySuccessfulAtAny", EventBulkRetryCreateRequestQuerySuccessfulAtAny: value}
}

func (e *EventBulkRetryCreateRequestQuerySuccessfulAt) UnmarshalJSON(data []byte) error {
	var valueDateTime time.Time
	if err := json.Unmarshal(data, &valueDateTime); err == nil {
		e.typeName = "dateTime"
		e.DateTime = valueDateTime
		return nil
	}
	valueEventBulkRetryCreateRequestQuerySuccessfulAtAny := new(EventBulkRetryCreateRequestQuerySuccessfulAtAny)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQuerySuccessfulAtAny); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQuerySuccessfulAtAny"
		e.EventBulkRetryCreateRequestQuerySuccessfulAtAny = valueEventBulkRetryCreateRequestQuerySuccessfulAtAny
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQuerySuccessfulAt) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "dateTime":
		return json.Marshal(e.DateTime)
	case "eventBulkRetryCreateRequestQuerySuccessfulAtAny":
		return json.Marshal(e.EventBulkRetryCreateRequestQuerySuccessfulAtAny)
	}
}

type EventBulkRetryCreateRequestQuerySuccessfulAtVisitor interface {
	VisitDateTime(time.Time) error
	VisitEventBulkRetryCreateRequestQuerySuccessfulAtAny(*EventBulkRetryCreateRequestQuerySuccessfulAtAny) error
}

func (e *EventBulkRetryCreateRequestQuerySuccessfulAt) Accept(visitor EventBulkRetryCreateRequestQuerySuccessfulAtVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "dateTime":
		return visitor.VisitDateTime(e.DateTime)
	case "eventBulkRetryCreateRequestQuerySuccessfulAtAny":
		return visitor.VisitEventBulkRetryCreateRequestQuerySuccessfulAtAny(e.EventBulkRetryCreateRequestQuerySuccessfulAtAny)
	}
}

type EventBulkRetryCreateRequestQuerySuccessfulAtAny struct {
	Gt  *time.Time `json:"gt,omitempty"`
	Gte *time.Time `json:"gte,omitempty"`
	Le  *time.Time `json:"le,omitempty"`
	Lte *time.Time `json:"lte,omitempty"`
	Any *bool      `json:"any,omitempty"`
}

// Filter by webhook connection IDs
type EventBulkRetryCreateRequestQueryWebhookId struct {
	typeName string
	// Webhook ID
	String     string
	StringList []string
}

func NewEventBulkRetryCreateRequestQueryWebhookIdFromString(value string) *EventBulkRetryCreateRequestQueryWebhookId {
	return &EventBulkRetryCreateRequestQueryWebhookId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryWebhookIdFromStringList(value []string) *EventBulkRetryCreateRequestQueryWebhookId {
	return &EventBulkRetryCreateRequestQueryWebhookId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQueryWebhookId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryWebhookId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryWebhookIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQueryWebhookId) Accept(visitor EventBulkRetryCreateRequestQueryWebhookIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

// The cause of the ignored event
type IgnoredEventBulkRetryCreateRequestQueryCause struct {
	typeName   string
	String     string
	StringList []string
}

func NewIgnoredEventBulkRetryCreateRequestQueryCauseFromString(value string) *IgnoredEventBulkRetryCreateRequestQueryCause {
	return &IgnoredEventBulkRetryCreateRequestQueryCause{typeName: "string", String: value}
}

func NewIgnoredEventBulkRetryCreateRequestQueryCauseFromStringList(value []string) *IgnoredEventBulkRetryCreateRequestQueryCause {
	return &IgnoredEventBulkRetryCreateRequestQueryCause{typeName: "stringList", StringList: value}
}

func (i *IgnoredEventBulkRetryCreateRequestQueryCause) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		i.typeName = "stringList"
		i.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IgnoredEventBulkRetryCreateRequestQueryCause) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "stringList":
		return json.Marshal(i.StringList)
	}
}

type IgnoredEventBulkRetryCreateRequestQueryCauseVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (i *IgnoredEventBulkRetryCreateRequestQueryCause) Accept(visitor IgnoredEventBulkRetryCreateRequestQueryCauseVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "stringList":
		return visitor.VisitStringList(i.StringList)
	}
}

// Connection ID of the ignored event
type IgnoredEventBulkRetryCreateRequestQueryWebhookId struct {
	typeName   string
	String     string
	StringList []string
}

func NewIgnoredEventBulkRetryCreateRequestQueryWebhookIdFromString(value string) *IgnoredEventBulkRetryCreateRequestQueryWebhookId {
	return &IgnoredEventBulkRetryCreateRequestQueryWebhookId{typeName: "string", String: value}
}

func NewIgnoredEventBulkRetryCreateRequestQueryWebhookIdFromStringList(value []string) *IgnoredEventBulkRetryCreateRequestQueryWebhookId {
	return &IgnoredEventBulkRetryCreateRequestQueryWebhookId{typeName: "stringList", StringList: value}
}

func (i *IgnoredEventBulkRetryCreateRequestQueryWebhookId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		i.typeName = "stringList"
		i.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IgnoredEventBulkRetryCreateRequestQueryWebhookId) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "stringList":
		return json.Marshal(i.StringList)
	}
}

type IgnoredEventBulkRetryCreateRequestQueryWebhookIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (i *IgnoredEventBulkRetryCreateRequestQueryWebhookId) Accept(visitor IgnoredEventBulkRetryCreateRequestQueryWebhookIdVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "stringList":
		return visitor.VisitStringList(i.StringList)
	}
}

// URL Encoded string of the JSON to match to the data body
type RequestBulkRetryCreateRequestQueryBody struct {
	typeName                                  string
	String                                    string
	RequestBulkRetryCreateRequestQueryBodyOne *RequestBulkRetryCreateRequestQueryBodyOne
}

func NewRequestBulkRetryCreateRequestQueryBodyFromString(value string) *RequestBulkRetryCreateRequestQueryBody {
	return &RequestBulkRetryCreateRequestQueryBody{typeName: "string", String: value}
}

func NewRequestBulkRetryCreateRequestQueryBodyFromRequestBulkRetryCreateRequestQueryBodyOne(value *RequestBulkRetryCreateRequestQueryBodyOne) *RequestBulkRetryCreateRequestQueryBody {
	return &RequestBulkRetryCreateRequestQueryBody{typeName: "requestBulkRetryCreateRequestQueryBodyOne", RequestBulkRetryCreateRequestQueryBodyOne: value}
}

func (r *RequestBulkRetryCreateRequestQueryBody) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	valueRequestBulkRetryCreateRequestQueryBodyOne := new(RequestBulkRetryCreateRequestQueryBodyOne)
	if err := json.Unmarshal(data, &valueRequestBulkRetryCreateRequestQueryBodyOne); err == nil {
		r.typeName = "requestBulkRetryCreateRequestQueryBodyOne"
		r.RequestBulkRetryCreateRequestQueryBodyOne = valueRequestBulkRetryCreateRequestQueryBodyOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryBody) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return json.Marshal(r.String)
	case "requestBulkRetryCreateRequestQueryBodyOne":
		return json.Marshal(r.RequestBulkRetryCreateRequestQueryBodyOne)
	}
}

type RequestBulkRetryCreateRequestQueryBodyVisitor interface {
	VisitString(string) error
	VisitRequestBulkRetryCreateRequestQueryBodyOne(*RequestBulkRetryCreateRequestQueryBodyOne) error
}

func (r *RequestBulkRetryCreateRequestQueryBody) Accept(visitor RequestBulkRetryCreateRequestQueryBodyVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return visitor.VisitString(r.String)
	case "requestBulkRetryCreateRequestQueryBodyOne":
		return visitor.VisitRequestBulkRetryCreateRequestQueryBodyOne(r.RequestBulkRetryCreateRequestQueryBodyOne)
	}
}

type RequestBulkRetryCreateRequestQueryBodyOne struct {
}

type RequestBulkRetryCreateRequestQueryBulkRetryId struct {
	typeName   string
	String     string
	StringList []string
}

func NewRequestBulkRetryCreateRequestQueryBulkRetryIdFromString(value string) *RequestBulkRetryCreateRequestQueryBulkRetryId {
	return &RequestBulkRetryCreateRequestQueryBulkRetryId{typeName: "string", String: value}
}

func NewRequestBulkRetryCreateRequestQueryBulkRetryIdFromStringList(value []string) *RequestBulkRetryCreateRequestQueryBulkRetryId {
	return &RequestBulkRetryCreateRequestQueryBulkRetryId{typeName: "stringList", StringList: value}
}

func (r *RequestBulkRetryCreateRequestQueryBulkRetryId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		r.typeName = "stringList"
		r.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryBulkRetryId) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return json.Marshal(r.String)
	case "stringList":
		return json.Marshal(r.StringList)
	}
}

type RequestBulkRetryCreateRequestQueryBulkRetryIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (r *RequestBulkRetryCreateRequestQueryBulkRetryId) Accept(visitor RequestBulkRetryCreateRequestQueryBulkRetryIdVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return visitor.VisitString(r.String)
	case "stringList":
		return visitor.VisitStringList(r.StringList)
	}
}

// Filter by count of events
type RequestBulkRetryCreateRequestQueryEventsCount struct {
	typeName                                         string
	Integer                                          int
	RequestBulkRetryCreateRequestQueryEventsCountAll *RequestBulkRetryCreateRequestQueryEventsCountAll
	IntegerList                                      []int
}

func NewRequestBulkRetryCreateRequestQueryEventsCountFromInteger(value int) *RequestBulkRetryCreateRequestQueryEventsCount {
	return &RequestBulkRetryCreateRequestQueryEventsCount{typeName: "integer", Integer: value}
}

func NewRequestBulkRetryCreateRequestQueryEventsCountFromRequestBulkRetryCreateRequestQueryEventsCountAll(value *RequestBulkRetryCreateRequestQueryEventsCountAll) *RequestBulkRetryCreateRequestQueryEventsCount {
	return &RequestBulkRetryCreateRequestQueryEventsCount{typeName: "requestBulkRetryCreateRequestQueryEventsCountAll", RequestBulkRetryCreateRequestQueryEventsCountAll: value}
}

func NewRequestBulkRetryCreateRequestQueryEventsCountFromIntegerList(value []int) *RequestBulkRetryCreateRequestQueryEventsCount {
	return &RequestBulkRetryCreateRequestQueryEventsCount{typeName: "integerList", IntegerList: value}
}

func (r *RequestBulkRetryCreateRequestQueryEventsCount) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		r.typeName = "integer"
		r.Integer = valueInteger
		return nil
	}
	valueRequestBulkRetryCreateRequestQueryEventsCountAll := new(RequestBulkRetryCreateRequestQueryEventsCountAll)
	if err := json.Unmarshal(data, &valueRequestBulkRetryCreateRequestQueryEventsCountAll); err == nil {
		r.typeName = "requestBulkRetryCreateRequestQueryEventsCountAll"
		r.RequestBulkRetryCreateRequestQueryEventsCountAll = valueRequestBulkRetryCreateRequestQueryEventsCountAll
		return nil
	}
	var valueIntegerList []int
	if err := json.Unmarshal(data, &valueIntegerList); err == nil {
		r.typeName = "integerList"
		r.IntegerList = valueIntegerList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryEventsCount) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "integer":
		return json.Marshal(r.Integer)
	case "requestBulkRetryCreateRequestQueryEventsCountAll":
		return json.Marshal(r.RequestBulkRetryCreateRequestQueryEventsCountAll)
	case "integerList":
		return json.Marshal(r.IntegerList)
	}
}

type RequestBulkRetryCreateRequestQueryEventsCountVisitor interface {
	VisitInteger(int) error
	VisitRequestBulkRetryCreateRequestQueryEventsCountAll(*RequestBulkRetryCreateRequestQueryEventsCountAll) error
	VisitIntegerList([]int) error
}

func (r *RequestBulkRetryCreateRequestQueryEventsCount) Accept(visitor RequestBulkRetryCreateRequestQueryEventsCountVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "integer":
		return visitor.VisitInteger(r.Integer)
	case "requestBulkRetryCreateRequestQueryEventsCountAll":
		return visitor.VisitRequestBulkRetryCreateRequestQueryEventsCountAll(r.RequestBulkRetryCreateRequestQueryEventsCountAll)
	case "integerList":
		return visitor.VisitIntegerList(r.IntegerList)
	}
}

type RequestBulkRetryCreateRequestQueryEventsCountAll struct {
	Gt       *int  `json:"gt,omitempty"`
	Gte      *int  `json:"gte,omitempty"`
	Le       *int  `json:"le,omitempty"`
	Lte      *int  `json:"lte,omitempty"`
	Any      *bool `json:"any,omitempty"`
	All      *bool `json:"all,omitempty"`
	Contains *int  `json:"contains,omitempty"`
}

// URL Encoded string of the JSON to match to the data headers
type RequestBulkRetryCreateRequestQueryHeaders struct {
	typeName                                     string
	String                                       string
	RequestBulkRetryCreateRequestQueryHeadersOne *RequestBulkRetryCreateRequestQueryHeadersOne
}

func NewRequestBulkRetryCreateRequestQueryHeadersFromString(value string) *RequestBulkRetryCreateRequestQueryHeaders {
	return &RequestBulkRetryCreateRequestQueryHeaders{typeName: "string", String: value}
}

func NewRequestBulkRetryCreateRequestQueryHeadersFromRequestBulkRetryCreateRequestQueryHeadersOne(value *RequestBulkRetryCreateRequestQueryHeadersOne) *RequestBulkRetryCreateRequestQueryHeaders {
	return &RequestBulkRetryCreateRequestQueryHeaders{typeName: "requestBulkRetryCreateRequestQueryHeadersOne", RequestBulkRetryCreateRequestQueryHeadersOne: value}
}

func (r *RequestBulkRetryCreateRequestQueryHeaders) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	valueRequestBulkRetryCreateRequestQueryHeadersOne := new(RequestBulkRetryCreateRequestQueryHeadersOne)
	if err := json.Unmarshal(data, &valueRequestBulkRetryCreateRequestQueryHeadersOne); err == nil {
		r.typeName = "requestBulkRetryCreateRequestQueryHeadersOne"
		r.RequestBulkRetryCreateRequestQueryHeadersOne = valueRequestBulkRetryCreateRequestQueryHeadersOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryHeaders) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return json.Marshal(r.String)
	case "requestBulkRetryCreateRequestQueryHeadersOne":
		return json.Marshal(r.RequestBulkRetryCreateRequestQueryHeadersOne)
	}
}

type RequestBulkRetryCreateRequestQueryHeadersVisitor interface {
	VisitString(string) error
	VisitRequestBulkRetryCreateRequestQueryHeadersOne(*RequestBulkRetryCreateRequestQueryHeadersOne) error
}

func (r *RequestBulkRetryCreateRequestQueryHeaders) Accept(visitor RequestBulkRetryCreateRequestQueryHeadersVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return visitor.VisitString(r.String)
	case "requestBulkRetryCreateRequestQueryHeadersOne":
		return visitor.VisitRequestBulkRetryCreateRequestQueryHeadersOne(r.RequestBulkRetryCreateRequestQueryHeadersOne)
	}
}

type RequestBulkRetryCreateRequestQueryHeadersOne struct {
}

// Filter by requests IDs
type RequestBulkRetryCreateRequestQueryId struct {
	typeName string
	// Request ID
	String     string
	StringList []string
}

func NewRequestBulkRetryCreateRequestQueryIdFromString(value string) *RequestBulkRetryCreateRequestQueryId {
	return &RequestBulkRetryCreateRequestQueryId{typeName: "string", String: value}
}

func NewRequestBulkRetryCreateRequestQueryIdFromStringList(value []string) *RequestBulkRetryCreateRequestQueryId {
	return &RequestBulkRetryCreateRequestQueryId{typeName: "stringList", StringList: value}
}

func (r *RequestBulkRetryCreateRequestQueryId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		r.typeName = "stringList"
		r.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryId) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return json.Marshal(r.String)
	case "stringList":
		return json.Marshal(r.StringList)
	}
}

type RequestBulkRetryCreateRequestQueryIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (r *RequestBulkRetryCreateRequestQueryId) Accept(visitor RequestBulkRetryCreateRequestQueryIdVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return visitor.VisitString(r.String)
	case "stringList":
		return visitor.VisitStringList(r.StringList)
	}
}

// Filter by count of ignored events
type RequestBulkRetryCreateRequestQueryIgnoredCount struct {
	typeName                                          string
	Integer                                           int
	RequestBulkRetryCreateRequestQueryIgnoredCountAll *RequestBulkRetryCreateRequestQueryIgnoredCountAll
	IntegerList                                       []int
}

func NewRequestBulkRetryCreateRequestQueryIgnoredCountFromInteger(value int) *RequestBulkRetryCreateRequestQueryIgnoredCount {
	return &RequestBulkRetryCreateRequestQueryIgnoredCount{typeName: "integer", Integer: value}
}

func NewRequestBulkRetryCreateRequestQueryIgnoredCountFromRequestBulkRetryCreateRequestQueryIgnoredCountAll(value *RequestBulkRetryCreateRequestQueryIgnoredCountAll) *RequestBulkRetryCreateRequestQueryIgnoredCount {
	return &RequestBulkRetryCreateRequestQueryIgnoredCount{typeName: "requestBulkRetryCreateRequestQueryIgnoredCountAll", RequestBulkRetryCreateRequestQueryIgnoredCountAll: value}
}

func NewRequestBulkRetryCreateRequestQueryIgnoredCountFromIntegerList(value []int) *RequestBulkRetryCreateRequestQueryIgnoredCount {
	return &RequestBulkRetryCreateRequestQueryIgnoredCount{typeName: "integerList", IntegerList: value}
}

func (r *RequestBulkRetryCreateRequestQueryIgnoredCount) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		r.typeName = "integer"
		r.Integer = valueInteger
		return nil
	}
	valueRequestBulkRetryCreateRequestQueryIgnoredCountAll := new(RequestBulkRetryCreateRequestQueryIgnoredCountAll)
	if err := json.Unmarshal(data, &valueRequestBulkRetryCreateRequestQueryIgnoredCountAll); err == nil {
		r.typeName = "requestBulkRetryCreateRequestQueryIgnoredCountAll"
		r.RequestBulkRetryCreateRequestQueryIgnoredCountAll = valueRequestBulkRetryCreateRequestQueryIgnoredCountAll
		return nil
	}
	var valueIntegerList []int
	if err := json.Unmarshal(data, &valueIntegerList); err == nil {
		r.typeName = "integerList"
		r.IntegerList = valueIntegerList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryIgnoredCount) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "integer":
		return json.Marshal(r.Integer)
	case "requestBulkRetryCreateRequestQueryIgnoredCountAll":
		return json.Marshal(r.RequestBulkRetryCreateRequestQueryIgnoredCountAll)
	case "integerList":
		return json.Marshal(r.IntegerList)
	}
}

type RequestBulkRetryCreateRequestQueryIgnoredCountVisitor interface {
	VisitInteger(int) error
	VisitRequestBulkRetryCreateRequestQueryIgnoredCountAll(*RequestBulkRetryCreateRequestQueryIgnoredCountAll) error
	VisitIntegerList([]int) error
}

func (r *RequestBulkRetryCreateRequestQueryIgnoredCount) Accept(visitor RequestBulkRetryCreateRequestQueryIgnoredCountVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "integer":
		return visitor.VisitInteger(r.Integer)
	case "requestBulkRetryCreateRequestQueryIgnoredCountAll":
		return visitor.VisitRequestBulkRetryCreateRequestQueryIgnoredCountAll(r.RequestBulkRetryCreateRequestQueryIgnoredCountAll)
	case "integerList":
		return visitor.VisitIntegerList(r.IntegerList)
	}
}

type RequestBulkRetryCreateRequestQueryIgnoredCountAll struct {
	Gt       *int  `json:"gt,omitempty"`
	Gte      *int  `json:"gte,omitempty"`
	Le       *int  `json:"le,omitempty"`
	Lte      *int  `json:"lte,omitempty"`
	Any      *bool `json:"any,omitempty"`
	All      *bool `json:"all,omitempty"`
	Contains *int  `json:"contains,omitempty"`
}

// Filter by event ingested date
type RequestBulkRetryCreateRequestQueryIngestedAt struct {
	typeName                                        string
	DateTime                                        time.Time
	RequestBulkRetryCreateRequestQueryIngestedAtAny *RequestBulkRetryCreateRequestQueryIngestedAtAny
}

func NewRequestBulkRetryCreateRequestQueryIngestedAtFromDateTime(value time.Time) *RequestBulkRetryCreateRequestQueryIngestedAt {
	return &RequestBulkRetryCreateRequestQueryIngestedAt{typeName: "dateTime", DateTime: value}
}

func NewRequestBulkRetryCreateRequestQueryIngestedAtFromRequestBulkRetryCreateRequestQueryIngestedAtAny(value *RequestBulkRetryCreateRequestQueryIngestedAtAny) *RequestBulkRetryCreateRequestQueryIngestedAt {
	return &RequestBulkRetryCreateRequestQueryIngestedAt{typeName: "requestBulkRetryCreateRequestQueryIngestedAtAny", RequestBulkRetryCreateRequestQueryIngestedAtAny: value}
}

func (r *RequestBulkRetryCreateRequestQueryIngestedAt) UnmarshalJSON(data []byte) error {
	var valueDateTime time.Time
	if err := json.Unmarshal(data, &valueDateTime); err == nil {
		r.typeName = "dateTime"
		r.DateTime = valueDateTime
		return nil
	}
	valueRequestBulkRetryCreateRequestQueryIngestedAtAny := new(RequestBulkRetryCreateRequestQueryIngestedAtAny)
	if err := json.Unmarshal(data, &valueRequestBulkRetryCreateRequestQueryIngestedAtAny); err == nil {
		r.typeName = "requestBulkRetryCreateRequestQueryIngestedAtAny"
		r.RequestBulkRetryCreateRequestQueryIngestedAtAny = valueRequestBulkRetryCreateRequestQueryIngestedAtAny
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryIngestedAt) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "dateTime":
		return json.Marshal(r.DateTime)
	case "requestBulkRetryCreateRequestQueryIngestedAtAny":
		return json.Marshal(r.RequestBulkRetryCreateRequestQueryIngestedAtAny)
	}
}

type RequestBulkRetryCreateRequestQueryIngestedAtVisitor interface {
	VisitDateTime(time.Time) error
	VisitRequestBulkRetryCreateRequestQueryIngestedAtAny(*RequestBulkRetryCreateRequestQueryIngestedAtAny) error
}

func (r *RequestBulkRetryCreateRequestQueryIngestedAt) Accept(visitor RequestBulkRetryCreateRequestQueryIngestedAtVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "dateTime":
		return visitor.VisitDateTime(r.DateTime)
	case "requestBulkRetryCreateRequestQueryIngestedAtAny":
		return visitor.VisitRequestBulkRetryCreateRequestQueryIngestedAtAny(r.RequestBulkRetryCreateRequestQueryIngestedAtAny)
	}
}

type RequestBulkRetryCreateRequestQueryIngestedAtAny struct {
	Gt  *time.Time `json:"gt,omitempty"`
	Gte *time.Time `json:"gte,omitempty"`
	Le  *time.Time `json:"le,omitempty"`
	Lte *time.Time `json:"lte,omitempty"`
	Any *bool      `json:"any,omitempty"`
}

// URL Encoded string of the JSON to match to the parsed query (JSON representation of the query)
type RequestBulkRetryCreateRequestQueryParsedQuery struct {
	typeName                                         string
	String                                           string
	RequestBulkRetryCreateRequestQueryParsedQueryOne *RequestBulkRetryCreateRequestQueryParsedQueryOne
}

func NewRequestBulkRetryCreateRequestQueryParsedQueryFromString(value string) *RequestBulkRetryCreateRequestQueryParsedQuery {
	return &RequestBulkRetryCreateRequestQueryParsedQuery{typeName: "string", String: value}
}

func NewRequestBulkRetryCreateRequestQueryParsedQueryFromRequestBulkRetryCreateRequestQueryParsedQueryOne(value *RequestBulkRetryCreateRequestQueryParsedQueryOne) *RequestBulkRetryCreateRequestQueryParsedQuery {
	return &RequestBulkRetryCreateRequestQueryParsedQuery{typeName: "requestBulkRetryCreateRequestQueryParsedQueryOne", RequestBulkRetryCreateRequestQueryParsedQueryOne: value}
}

func (r *RequestBulkRetryCreateRequestQueryParsedQuery) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	valueRequestBulkRetryCreateRequestQueryParsedQueryOne := new(RequestBulkRetryCreateRequestQueryParsedQueryOne)
	if err := json.Unmarshal(data, &valueRequestBulkRetryCreateRequestQueryParsedQueryOne); err == nil {
		r.typeName = "requestBulkRetryCreateRequestQueryParsedQueryOne"
		r.RequestBulkRetryCreateRequestQueryParsedQueryOne = valueRequestBulkRetryCreateRequestQueryParsedQueryOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryParsedQuery) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return json.Marshal(r.String)
	case "requestBulkRetryCreateRequestQueryParsedQueryOne":
		return json.Marshal(r.RequestBulkRetryCreateRequestQueryParsedQueryOne)
	}
}

type RequestBulkRetryCreateRequestQueryParsedQueryVisitor interface {
	VisitString(string) error
	VisitRequestBulkRetryCreateRequestQueryParsedQueryOne(*RequestBulkRetryCreateRequestQueryParsedQueryOne) error
}

func (r *RequestBulkRetryCreateRequestQueryParsedQuery) Accept(visitor RequestBulkRetryCreateRequestQueryParsedQueryVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return visitor.VisitString(r.String)
	case "requestBulkRetryCreateRequestQueryParsedQueryOne":
		return visitor.VisitRequestBulkRetryCreateRequestQueryParsedQueryOne(r.RequestBulkRetryCreateRequestQueryParsedQueryOne)
	}
}

type RequestBulkRetryCreateRequestQueryParsedQueryOne struct {
}

// Filter by rejection cause
type RequestBulkRetryCreateRequestQueryRejectionCause struct {
	typeName                  string
	RequestRejectionCause     RequestRejectionCause
	RequestRejectionCauseList []RequestRejectionCause
}

func NewRequestBulkRetryCreateRequestQueryRejectionCauseFromRequestRejectionCause(value RequestRejectionCause) *RequestBulkRetryCreateRequestQueryRejectionCause {
	return &RequestBulkRetryCreateRequestQueryRejectionCause{typeName: "requestRejectionCause", RequestRejectionCause: value}
}

func NewRequestBulkRetryCreateRequestQueryRejectionCauseFromRequestRejectionCauseList(value []RequestRejectionCause) *RequestBulkRetryCreateRequestQueryRejectionCause {
	return &RequestBulkRetryCreateRequestQueryRejectionCause{typeName: "requestRejectionCauseList", RequestRejectionCauseList: value}
}

func (r *RequestBulkRetryCreateRequestQueryRejectionCause) UnmarshalJSON(data []byte) error {
	var valueRequestRejectionCause RequestRejectionCause
	if err := json.Unmarshal(data, &valueRequestRejectionCause); err == nil {
		r.typeName = "requestRejectionCause"
		r.RequestRejectionCause = valueRequestRejectionCause
		return nil
	}
	var valueRequestRejectionCauseList []RequestRejectionCause
	if err := json.Unmarshal(data, &valueRequestRejectionCauseList); err == nil {
		r.typeName = "requestRejectionCauseList"
		r.RequestRejectionCauseList = valueRequestRejectionCauseList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryRejectionCause) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "requestRejectionCause":
		return json.Marshal(r.RequestRejectionCause)
	case "requestRejectionCauseList":
		return json.Marshal(r.RequestRejectionCauseList)
	}
}

type RequestBulkRetryCreateRequestQueryRejectionCauseVisitor interface {
	VisitRequestRejectionCause(RequestRejectionCause) error
	VisitRequestRejectionCauseList([]RequestRejectionCause) error
}

func (r *RequestBulkRetryCreateRequestQueryRejectionCause) Accept(visitor RequestBulkRetryCreateRequestQueryRejectionCauseVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "requestRejectionCause":
		return visitor.VisitRequestRejectionCause(r.RequestRejectionCause)
	case "requestRejectionCauseList":
		return visitor.VisitRequestRejectionCauseList(r.RequestRejectionCauseList)
	}
}

// Filter by source IDs
type RequestBulkRetryCreateRequestQuerySourceId struct {
	typeName string
	// Source ID
	String     string
	StringList []string
}

func NewRequestBulkRetryCreateRequestQuerySourceIdFromString(value string) *RequestBulkRetryCreateRequestQuerySourceId {
	return &RequestBulkRetryCreateRequestQuerySourceId{typeName: "string", String: value}
}

func NewRequestBulkRetryCreateRequestQuerySourceIdFromStringList(value []string) *RequestBulkRetryCreateRequestQuerySourceId {
	return &RequestBulkRetryCreateRequestQuerySourceId{typeName: "stringList", StringList: value}
}

func (r *RequestBulkRetryCreateRequestQuerySourceId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		r.typeName = "stringList"
		r.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQuerySourceId) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return json.Marshal(r.String)
	case "stringList":
		return json.Marshal(r.StringList)
	}
}

type RequestBulkRetryCreateRequestQuerySourceIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (r *RequestBulkRetryCreateRequestQuerySourceId) Accept(visitor RequestBulkRetryCreateRequestQuerySourceIdVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return visitor.VisitString(r.String)
	case "stringList":
		return visitor.VisitStringList(r.StringList)
	}
}

// Filter by status
type RequestBulkRetryCreateRequestQueryStatus string

const (
	RequestBulkRetryCreateRequestQueryStatusAccepted RequestBulkRetryCreateRequestQueryStatus = "accepted"
	RequestBulkRetryCreateRequestQueryStatusRejected RequestBulkRetryCreateRequestQueryStatus = "rejected"
)

func NewRequestBulkRetryCreateRequestQueryStatusFromString(s string) (RequestBulkRetryCreateRequestQueryStatus, error) {
	switch s {
	case "accepted":
		return RequestBulkRetryCreateRequestQueryStatusAccepted, nil
	case "rejected":
		return RequestBulkRetryCreateRequestQueryStatusRejected, nil
	}
	var t RequestBulkRetryCreateRequestQueryStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestBulkRetryCreateRequestQueryStatus) Ptr() *RequestBulkRetryCreateRequestQueryStatus {
	return &r
}

// Body of the request
type TransformationRunRequestRequestBody struct {
	typeName                                string
	TransformationRunRequestRequestBodyZero *TransformationRunRequestRequestBodyZero
	String                                  string
}

func NewTransformationRunRequestRequestBodyFromTransformationRunRequestRequestBodyZero(value *TransformationRunRequestRequestBodyZero) *TransformationRunRequestRequestBody {
	return &TransformationRunRequestRequestBody{typeName: "transformationRunRequestRequestBodyZero", TransformationRunRequestRequestBodyZero: value}
}

func NewTransformationRunRequestRequestBodyFromString(value string) *TransformationRunRequestRequestBody {
	return &TransformationRunRequestRequestBody{typeName: "string", String: value}
}

func (t *TransformationRunRequestRequestBody) UnmarshalJSON(data []byte) error {
	valueTransformationRunRequestRequestBodyZero := new(TransformationRunRequestRequestBodyZero)
	if err := json.Unmarshal(data, &valueTransformationRunRequestRequestBodyZero); err == nil {
		t.typeName = "transformationRunRequestRequestBodyZero"
		t.TransformationRunRequestRequestBodyZero = valueTransformationRunRequestRequestBodyZero
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransformationRunRequestRequestBody) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transformationRunRequestRequestBodyZero":
		return json.Marshal(t.TransformationRunRequestRequestBodyZero)
	case "string":
		return json.Marshal(t.String)
	}
}

type TransformationRunRequestRequestBodyVisitor interface {
	VisitTransformationRunRequestRequestBodyZero(*TransformationRunRequestRequestBodyZero) error
	VisitString(string) error
}

func (t *TransformationRunRequestRequestBody) Accept(visitor TransformationRunRequestRequestBodyVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transformationRunRequestRequestBodyZero":
		return visitor.VisitTransformationRunRequestRequestBodyZero(t.TransformationRunRequestRequestBodyZero)
	case "string":
		return visitor.VisitString(t.String)
	}
}

type TransformationRunRequestRequestBodyZero struct {
}

// JSON representation of the query params
type TransformationRunRequestRequestParsedQuery struct {
}
