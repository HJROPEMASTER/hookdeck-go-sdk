// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/hookdeck/hookdeck-go-sdk/core"
)

type CreateCollection struct {
	// Wait for operation commit timeout in seconds.
	// If timeout is reached - request will return with service error.
	Timeout *int                          `json:"-"`
	Vectors *core.Optional[VectorsConfig] `json:"vectors,omitempty"`
	// For auto sharding: Number of shards in collection. - Default is 1 for standalone, otherwise equal to the number of nodes - Minimum is 1 For custom sharding: Number of shards in collection per shard group. - Default is 1, meaning that each shard key will be mapped to a single shard - Minimum is 1
	ShardNumber *core.Optional[int] `json:"shard_number,omitempty"`
	// Sharding method Default is Auto - points are distributed across all available shards Custom - points are distributed across shards according to shard key
	ShardingMethod *core.Optional[CreateCollectionShardingMethod] `json:"sharding_method,omitempty"`
	// Number of shards replicas. Default is 1 Minimum is 1
	ReplicationFactor *core.Optional[int] `json:"replication_factor,omitempty"`
	// Defines how many replicas should apply the operation for us to consider it successful. Increasing this number will make the collection more resilient to inconsistencies, but will also make it fail if not enough replicas are available. Does not have any performance impact.
	WriteConsistencyFactor *core.Optional[int] `json:"write_consistency_factor,omitempty"`
	// If true - point's payload will not be stored in memory. It will be read from the disk every time it is requested. This setting saves RAM by (slightly) increasing the response time. Note: those payload values that are involved in filtering and are indexed - remain in RAM.
	OnDiskPayload *core.Optional[bool] `json:"on_disk_payload,omitempty"`
	// Custom params for HNSW index. If none - values from service configuration file are used.
	HnswConfig *core.Optional[CreateCollectionHnswConfig] `json:"hnsw_config,omitempty"`
	// Custom params for WAL. If none - values from service configuration file are used.
	WalConfig *core.Optional[CreateCollectionWalConfig] `json:"wal_config,omitempty"`
	// Custom params for Optimizers.  If none - values from service configuration file are used.
	OptimizersConfig *core.Optional[CreateCollectionOptimizersConfig] `json:"optimizers_config,omitempty"`
	// Specify other collection to copy data from.
	InitFrom *core.Optional[CreateCollectionInitFrom] `json:"init_from,omitempty"`
	// Quantization parameters. If none - quantization is disabled.
	QuantizationConfig *core.Optional[CreateCollectionQuantizationConfig] `json:"quantization_config,omitempty"`
	// Sparse vector data config.
	SparseVectors *core.Optional[map[string]*SparseVectorParams] `json:"sparse_vectors,omitempty"`
}

type CreateFieldIndex struct {
	// If true, wait for changes to actually happen
	Wait *bool `json:"-"`
	// define ordering guarantees for the operation
	Ordering    *WriteOrdering                              `json:"-"`
	FieldName   string                                      `json:"field_name"`
	FieldSchema *core.Optional[CreateFieldIndexFieldSchema] `json:"field_schema,omitempty"`
}

type CreateShardKeyRequest struct {
	// Wait for operation commit timeout in seconds.
	// If timeout is reached - request will return with service error.
	Timeout *int               `json:"-"`
	Body    *CreateShardingKey `json:"-"`
}

func (c *CreateShardKeyRequest) UnmarshalJSON(data []byte) error {
	body := new(CreateShardingKey)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	c.Body = body
	return nil
}

func (c *CreateShardKeyRequest) MarshalJSON() ([]byte, error) {
	return json.Marshal(c.Body)
}

type DeleteCollectionRequest struct {
	// Wait for operation commit timeout in seconds.
	// If timeout is reached - request will return with service error.
	Timeout *int `json:"-"`
}

type DeleteFieldIndexRequest struct {
	// If true, wait for changes to actually happen
	Wait *bool `json:"-"`
	// define ordering guarantees for the operation
	Ordering *WriteOrdering `json:"-"`
}

type DeleteShardKeyRequest struct {
	// Wait for operation commit timeout in seconds.
	// If timeout is reached - request will return with service error.
	Timeout *int             `json:"-"`
	Body    *DropShardingKey `json:"-"`
}

func (d *DeleteShardKeyRequest) UnmarshalJSON(data []byte) error {
	body := new(DropShardingKey)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	d.Body = body
	return nil
}

func (d *DeleteShardKeyRequest) MarshalJSON() ([]byte, error) {
	return json.Marshal(d.Body)
}

type CollectionClusterInfoResponse struct {
	// Time spent to process this request
	Time   *float64               `json:"time,omitempty"`
	Status *string                `json:"status,omitempty"`
	Result *CollectionClusterInfo `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CollectionClusterInfoResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CollectionClusterInfoResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CollectionClusterInfoResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CollectionClusterInfoResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Custom params for HNSW index. If none - values from service configuration file are used.
type CreateCollectionHnswConfig struct {
	typeName       string
	HnswConfigDiff *HnswConfigDiff
	Unknown        interface{}
}

func NewCreateCollectionHnswConfigFromHnswConfigDiff(value *HnswConfigDiff) *CreateCollectionHnswConfig {
	return &CreateCollectionHnswConfig{typeName: "hnswConfigDiff", HnswConfigDiff: value}
}

func NewCreateCollectionHnswConfigFromUnknown(value interface{}) *CreateCollectionHnswConfig {
	return &CreateCollectionHnswConfig{typeName: "unknown", Unknown: value}
}

func (c *CreateCollectionHnswConfig) UnmarshalJSON(data []byte) error {
	valueHnswConfigDiff := new(HnswConfigDiff)
	if err := json.Unmarshal(data, &valueHnswConfigDiff); err == nil {
		c.typeName = "hnswConfigDiff"
		c.HnswConfigDiff = valueHnswConfigDiff
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		c.typeName = "unknown"
		c.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateCollectionHnswConfig) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "hnswConfigDiff":
		return json.Marshal(c.HnswConfigDiff)
	case "unknown":
		return json.Marshal(c.Unknown)
	}
}

type CreateCollectionHnswConfigVisitor interface {
	VisitHnswConfigDiff(*HnswConfigDiff) error
	VisitUnknown(interface{}) error
}

func (c *CreateCollectionHnswConfig) Accept(visitor CreateCollectionHnswConfigVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "hnswConfigDiff":
		return visitor.VisitHnswConfigDiff(c.HnswConfigDiff)
	case "unknown":
		return visitor.VisitUnknown(c.Unknown)
	}
}

// Specify other collection to copy data from.
type CreateCollectionInitFrom struct {
	typeName string
	InitFrom *InitFrom
	Unknown  interface{}
}

func NewCreateCollectionInitFromFromInitFrom(value *InitFrom) *CreateCollectionInitFrom {
	return &CreateCollectionInitFrom{typeName: "initFrom", InitFrom: value}
}

func NewCreateCollectionInitFromFromUnknown(value interface{}) *CreateCollectionInitFrom {
	return &CreateCollectionInitFrom{typeName: "unknown", Unknown: value}
}

func (c *CreateCollectionInitFrom) UnmarshalJSON(data []byte) error {
	valueInitFrom := new(InitFrom)
	if err := json.Unmarshal(data, &valueInitFrom); err == nil {
		c.typeName = "initFrom"
		c.InitFrom = valueInitFrom
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		c.typeName = "unknown"
		c.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateCollectionInitFrom) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "initFrom":
		return json.Marshal(c.InitFrom)
	case "unknown":
		return json.Marshal(c.Unknown)
	}
}

type CreateCollectionInitFromVisitor interface {
	VisitInitFrom(*InitFrom) error
	VisitUnknown(interface{}) error
}

func (c *CreateCollectionInitFrom) Accept(visitor CreateCollectionInitFromVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "initFrom":
		return visitor.VisitInitFrom(c.InitFrom)
	case "unknown":
		return visitor.VisitUnknown(c.Unknown)
	}
}

// Custom params for Optimizers. If none - values from service configuration file are used.
type CreateCollectionOptimizersConfig struct {
	typeName             string
	OptimizersConfigDiff *OptimizersConfigDiff
	Unknown              interface{}
}

func NewCreateCollectionOptimizersConfigFromOptimizersConfigDiff(value *OptimizersConfigDiff) *CreateCollectionOptimizersConfig {
	return &CreateCollectionOptimizersConfig{typeName: "optimizersConfigDiff", OptimizersConfigDiff: value}
}

func NewCreateCollectionOptimizersConfigFromUnknown(value interface{}) *CreateCollectionOptimizersConfig {
	return &CreateCollectionOptimizersConfig{typeName: "unknown", Unknown: value}
}

func (c *CreateCollectionOptimizersConfig) UnmarshalJSON(data []byte) error {
	valueOptimizersConfigDiff := new(OptimizersConfigDiff)
	if err := json.Unmarshal(data, &valueOptimizersConfigDiff); err == nil {
		c.typeName = "optimizersConfigDiff"
		c.OptimizersConfigDiff = valueOptimizersConfigDiff
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		c.typeName = "unknown"
		c.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateCollectionOptimizersConfig) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "optimizersConfigDiff":
		return json.Marshal(c.OptimizersConfigDiff)
	case "unknown":
		return json.Marshal(c.Unknown)
	}
}

type CreateCollectionOptimizersConfigVisitor interface {
	VisitOptimizersConfigDiff(*OptimizersConfigDiff) error
	VisitUnknown(interface{}) error
}

func (c *CreateCollectionOptimizersConfig) Accept(visitor CreateCollectionOptimizersConfigVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "optimizersConfigDiff":
		return visitor.VisitOptimizersConfigDiff(c.OptimizersConfigDiff)
	case "unknown":
		return visitor.VisitUnknown(c.Unknown)
	}
}

// Quantization parameters. If none - quantization is disabled.
type CreateCollectionQuantizationConfig struct {
	typeName           string
	QuantizationConfig *QuantizationConfig
	Unknown            interface{}
}

func NewCreateCollectionQuantizationConfigFromQuantizationConfig(value *QuantizationConfig) *CreateCollectionQuantizationConfig {
	return &CreateCollectionQuantizationConfig{typeName: "quantizationConfig", QuantizationConfig: value}
}

func NewCreateCollectionQuantizationConfigFromUnknown(value interface{}) *CreateCollectionQuantizationConfig {
	return &CreateCollectionQuantizationConfig{typeName: "unknown", Unknown: value}
}

func (c *CreateCollectionQuantizationConfig) UnmarshalJSON(data []byte) error {
	valueQuantizationConfig := new(QuantizationConfig)
	if err := json.Unmarshal(data, &valueQuantizationConfig); err == nil {
		c.typeName = "quantizationConfig"
		c.QuantizationConfig = valueQuantizationConfig
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		c.typeName = "unknown"
		c.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateCollectionQuantizationConfig) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "quantizationConfig":
		return json.Marshal(c.QuantizationConfig)
	case "unknown":
		return json.Marshal(c.Unknown)
	}
}

type CreateCollectionQuantizationConfigVisitor interface {
	VisitQuantizationConfig(*QuantizationConfig) error
	VisitUnknown(interface{}) error
}

func (c *CreateCollectionQuantizationConfig) Accept(visitor CreateCollectionQuantizationConfigVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "quantizationConfig":
		return visitor.VisitQuantizationConfig(c.QuantizationConfig)
	case "unknown":
		return visitor.VisitUnknown(c.Unknown)
	}
}

type CreateCollectionResponse struct {
	// Time spent to process this request
	Time   *float64 `json:"time,omitempty"`
	Status *string  `json:"status,omitempty"`
	Result *bool    `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CreateCollectionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateCollectionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateCollectionResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateCollectionResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Sharding method Default is Auto - points are distributed across all available shards Custom - points are distributed across shards according to shard key
type CreateCollectionShardingMethod struct {
	typeName       string
	ShardingMethod ShardingMethod
	Unknown        interface{}
}

func NewCreateCollectionShardingMethodFromShardingMethod(value ShardingMethod) *CreateCollectionShardingMethod {
	return &CreateCollectionShardingMethod{typeName: "shardingMethod", ShardingMethod: value}
}

func NewCreateCollectionShardingMethodFromUnknown(value interface{}) *CreateCollectionShardingMethod {
	return &CreateCollectionShardingMethod{typeName: "unknown", Unknown: value}
}

func (c *CreateCollectionShardingMethod) UnmarshalJSON(data []byte) error {
	var valueShardingMethod ShardingMethod
	if err := json.Unmarshal(data, &valueShardingMethod); err == nil {
		c.typeName = "shardingMethod"
		c.ShardingMethod = valueShardingMethod
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		c.typeName = "unknown"
		c.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateCollectionShardingMethod) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "shardingMethod":
		return json.Marshal(c.ShardingMethod)
	case "unknown":
		return json.Marshal(c.Unknown)
	}
}

type CreateCollectionShardingMethodVisitor interface {
	VisitShardingMethod(ShardingMethod) error
	VisitUnknown(interface{}) error
}

func (c *CreateCollectionShardingMethod) Accept(visitor CreateCollectionShardingMethodVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "shardingMethod":
		return visitor.VisitShardingMethod(c.ShardingMethod)
	case "unknown":
		return visitor.VisitUnknown(c.Unknown)
	}
}

// Custom params for WAL. If none - values from service configuration file are used.
type CreateCollectionWalConfig struct {
	typeName      string
	WalConfigDiff *WalConfigDiff
	Unknown       interface{}
}

func NewCreateCollectionWalConfigFromWalConfigDiff(value *WalConfigDiff) *CreateCollectionWalConfig {
	return &CreateCollectionWalConfig{typeName: "walConfigDiff", WalConfigDiff: value}
}

func NewCreateCollectionWalConfigFromUnknown(value interface{}) *CreateCollectionWalConfig {
	return &CreateCollectionWalConfig{typeName: "unknown", Unknown: value}
}

func (c *CreateCollectionWalConfig) UnmarshalJSON(data []byte) error {
	valueWalConfigDiff := new(WalConfigDiff)
	if err := json.Unmarshal(data, &valueWalConfigDiff); err == nil {
		c.typeName = "walConfigDiff"
		c.WalConfigDiff = valueWalConfigDiff
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		c.typeName = "unknown"
		c.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateCollectionWalConfig) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "walConfigDiff":
		return json.Marshal(c.WalConfigDiff)
	case "unknown":
		return json.Marshal(c.Unknown)
	}
}

type CreateCollectionWalConfigVisitor interface {
	VisitWalConfigDiff(*WalConfigDiff) error
	VisitUnknown(interface{}) error
}

func (c *CreateCollectionWalConfig) Accept(visitor CreateCollectionWalConfigVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "walConfigDiff":
		return visitor.VisitWalConfigDiff(c.WalConfigDiff)
	case "unknown":
		return visitor.VisitUnknown(c.Unknown)
	}
}

type CreateFieldIndexFieldSchema struct {
	typeName           string
	PayloadFieldSchema *PayloadFieldSchema
	Unknown            interface{}
}

func NewCreateFieldIndexFieldSchemaFromPayloadFieldSchema(value *PayloadFieldSchema) *CreateFieldIndexFieldSchema {
	return &CreateFieldIndexFieldSchema{typeName: "payloadFieldSchema", PayloadFieldSchema: value}
}

func NewCreateFieldIndexFieldSchemaFromUnknown(value interface{}) *CreateFieldIndexFieldSchema {
	return &CreateFieldIndexFieldSchema{typeName: "unknown", Unknown: value}
}

func (c *CreateFieldIndexFieldSchema) UnmarshalJSON(data []byte) error {
	valuePayloadFieldSchema := new(PayloadFieldSchema)
	if err := json.Unmarshal(data, &valuePayloadFieldSchema); err == nil {
		c.typeName = "payloadFieldSchema"
		c.PayloadFieldSchema = valuePayloadFieldSchema
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		c.typeName = "unknown"
		c.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CreateFieldIndexFieldSchema) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "payloadFieldSchema":
		return json.Marshal(c.PayloadFieldSchema)
	case "unknown":
		return json.Marshal(c.Unknown)
	}
}

type CreateFieldIndexFieldSchemaVisitor interface {
	VisitPayloadFieldSchema(*PayloadFieldSchema) error
	VisitUnknown(interface{}) error
}

func (c *CreateFieldIndexFieldSchema) Accept(visitor CreateFieldIndexFieldSchemaVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "payloadFieldSchema":
		return visitor.VisitPayloadFieldSchema(c.PayloadFieldSchema)
	case "unknown":
		return visitor.VisitUnknown(c.Unknown)
	}
}

type CreateFieldIndexResponse struct {
	// Time spent to process this request
	Time   *float64      `json:"time,omitempty"`
	Status *string       `json:"status,omitempty"`
	Result *UpdateResult `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CreateFieldIndexResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateFieldIndexResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateFieldIndexResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateFieldIndexResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateShardKeyResponse struct {
	// Time spent to process this request
	Time   *float64 `json:"time,omitempty"`
	Status *string  `json:"status,omitempty"`
	Result *bool    `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CreateShardKeyResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateShardKeyResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateShardKeyResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateShardKeyResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type DeleteCollectionResponse struct {
	// Time spent to process this request
	Time   *float64 `json:"time,omitempty"`
	Status *string  `json:"status,omitempty"`
	Result *bool    `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteCollectionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteCollectionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteCollectionResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteCollectionResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFieldIndexResponse struct {
	// Time spent to process this request
	Time   *float64      `json:"time,omitempty"`
	Status *string       `json:"status,omitempty"`
	Result *UpdateResult `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFieldIndexResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFieldIndexResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFieldIndexResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFieldIndexResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteShardKeyResponse struct {
	// Time spent to process this request
	Time   *float64 `json:"time,omitempty"`
	Status *string  `json:"status,omitempty"`
	Result *bool    `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteShardKeyResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteShardKeyResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteShardKeyResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteShardKeyResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type GetCollectionAliasesResponse struct {
	// Time spent to process this request
	Time   *float64                    `json:"time,omitempty"`
	Status *string                     `json:"status,omitempty"`
	Result *CollectionsAliasesResponse `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetCollectionAliasesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetCollectionAliasesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetCollectionAliasesResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetCollectionAliasesResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetCollectionResponse struct {
	// Time spent to process this request
	Time   *float64        `json:"time,omitempty"`
	Status *string         `json:"status,omitempty"`
	Result *CollectionInfo `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetCollectionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetCollectionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetCollectionResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetCollectionResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetCollectionsAliasesResponse struct {
	// Time spent to process this request
	Time   *float64                    `json:"time,omitempty"`
	Status *string                     `json:"status,omitempty"`
	Result *CollectionsAliasesResponse `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetCollectionsAliasesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetCollectionsAliasesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetCollectionsAliasesResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetCollectionsAliasesResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetCollectionsResponse struct {
	// Time spent to process this request
	Time   *float64             `json:"time,omitempty"`
	Status *string              `json:"status,omitempty"`
	Result *CollectionsResponse `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetCollectionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetCollectionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetCollectionsResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetCollectionsResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type UpdateAliasesResponse struct {
	// Time spent to process this request
	Time   *float64 `json:"time,omitempty"`
	Status *string  `json:"status,omitempty"`
	Result *bool    `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UpdateAliasesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateAliasesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateAliasesResponse(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateAliasesResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateCollectionClusterResponse struct {
	// Time spent to process this request
	Time   *float64 `json:"time,omitempty"`
	Status *string  `json:"status,omitempty"`
	Result *bool    `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UpdateCollectionClusterResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateCollectionClusterResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateCollectionClusterResponse(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateCollectionClusterResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// HNSW parameters to update for the collection index. If none - it is left unchanged.
type UpdateCollectionHnswConfig struct {
	typeName       string
	HnswConfigDiff *HnswConfigDiff
	Unknown        interface{}
}

func NewUpdateCollectionHnswConfigFromHnswConfigDiff(value *HnswConfigDiff) *UpdateCollectionHnswConfig {
	return &UpdateCollectionHnswConfig{typeName: "hnswConfigDiff", HnswConfigDiff: value}
}

func NewUpdateCollectionHnswConfigFromUnknown(value interface{}) *UpdateCollectionHnswConfig {
	return &UpdateCollectionHnswConfig{typeName: "unknown", Unknown: value}
}

func (u *UpdateCollectionHnswConfig) UnmarshalJSON(data []byte) error {
	valueHnswConfigDiff := new(HnswConfigDiff)
	if err := json.Unmarshal(data, &valueHnswConfigDiff); err == nil {
		u.typeName = "hnswConfigDiff"
		u.HnswConfigDiff = valueHnswConfigDiff
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		u.typeName = "unknown"
		u.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateCollectionHnswConfig) MarshalJSON() ([]byte, error) {
	switch u.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "hnswConfigDiff":
		return json.Marshal(u.HnswConfigDiff)
	case "unknown":
		return json.Marshal(u.Unknown)
	}
}

type UpdateCollectionHnswConfigVisitor interface {
	VisitHnswConfigDiff(*HnswConfigDiff) error
	VisitUnknown(interface{}) error
}

func (u *UpdateCollectionHnswConfig) Accept(visitor UpdateCollectionHnswConfigVisitor) error {
	switch u.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "hnswConfigDiff":
		return visitor.VisitHnswConfigDiff(u.HnswConfigDiff)
	case "unknown":
		return visitor.VisitUnknown(u.Unknown)
	}
}

// Custom params for Optimizers. If none - it is left unchanged. This operation is blocking, it will only proceed once all current optimizations are complete
type UpdateCollectionOptimizersConfig struct {
	typeName             string
	OptimizersConfigDiff *OptimizersConfigDiff
	Unknown              interface{}
}

func NewUpdateCollectionOptimizersConfigFromOptimizersConfigDiff(value *OptimizersConfigDiff) *UpdateCollectionOptimizersConfig {
	return &UpdateCollectionOptimizersConfig{typeName: "optimizersConfigDiff", OptimizersConfigDiff: value}
}

func NewUpdateCollectionOptimizersConfigFromUnknown(value interface{}) *UpdateCollectionOptimizersConfig {
	return &UpdateCollectionOptimizersConfig{typeName: "unknown", Unknown: value}
}

func (u *UpdateCollectionOptimizersConfig) UnmarshalJSON(data []byte) error {
	valueOptimizersConfigDiff := new(OptimizersConfigDiff)
	if err := json.Unmarshal(data, &valueOptimizersConfigDiff); err == nil {
		u.typeName = "optimizersConfigDiff"
		u.OptimizersConfigDiff = valueOptimizersConfigDiff
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		u.typeName = "unknown"
		u.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateCollectionOptimizersConfig) MarshalJSON() ([]byte, error) {
	switch u.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "optimizersConfigDiff":
		return json.Marshal(u.OptimizersConfigDiff)
	case "unknown":
		return json.Marshal(u.Unknown)
	}
}

type UpdateCollectionOptimizersConfigVisitor interface {
	VisitOptimizersConfigDiff(*OptimizersConfigDiff) error
	VisitUnknown(interface{}) error
}

func (u *UpdateCollectionOptimizersConfig) Accept(visitor UpdateCollectionOptimizersConfigVisitor) error {
	switch u.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "optimizersConfigDiff":
		return visitor.VisitOptimizersConfigDiff(u.OptimizersConfigDiff)
	case "unknown":
		return visitor.VisitUnknown(u.Unknown)
	}
}

// Collection base params. If none - it is left unchanged.
type UpdateCollectionParams struct {
	typeName             string
	CollectionParamsDiff *CollectionParamsDiff
	Unknown              interface{}
}

func NewUpdateCollectionParamsFromCollectionParamsDiff(value *CollectionParamsDiff) *UpdateCollectionParams {
	return &UpdateCollectionParams{typeName: "collectionParamsDiff", CollectionParamsDiff: value}
}

func NewUpdateCollectionParamsFromUnknown(value interface{}) *UpdateCollectionParams {
	return &UpdateCollectionParams{typeName: "unknown", Unknown: value}
}

func (u *UpdateCollectionParams) UnmarshalJSON(data []byte) error {
	valueCollectionParamsDiff := new(CollectionParamsDiff)
	if err := json.Unmarshal(data, &valueCollectionParamsDiff); err == nil {
		u.typeName = "collectionParamsDiff"
		u.CollectionParamsDiff = valueCollectionParamsDiff
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		u.typeName = "unknown"
		u.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateCollectionParams) MarshalJSON() ([]byte, error) {
	switch u.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "collectionParamsDiff":
		return json.Marshal(u.CollectionParamsDiff)
	case "unknown":
		return json.Marshal(u.Unknown)
	}
}

type UpdateCollectionParamsVisitor interface {
	VisitCollectionParamsDiff(*CollectionParamsDiff) error
	VisitUnknown(interface{}) error
}

func (u *UpdateCollectionParams) Accept(visitor UpdateCollectionParamsVisitor) error {
	switch u.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "collectionParamsDiff":
		return visitor.VisitCollectionParamsDiff(u.CollectionParamsDiff)
	case "unknown":
		return visitor.VisitUnknown(u.Unknown)
	}
}

// Quantization parameters to update. If none - it is left unchanged.
type UpdateCollectionQuantizationConfig struct {
	typeName               string
	QuantizationConfigDiff *QuantizationConfigDiff
	Unknown                interface{}
}

func NewUpdateCollectionQuantizationConfigFromQuantizationConfigDiff(value *QuantizationConfigDiff) *UpdateCollectionQuantizationConfig {
	return &UpdateCollectionQuantizationConfig{typeName: "quantizationConfigDiff", QuantizationConfigDiff: value}
}

func NewUpdateCollectionQuantizationConfigFromUnknown(value interface{}) *UpdateCollectionQuantizationConfig {
	return &UpdateCollectionQuantizationConfig{typeName: "unknown", Unknown: value}
}

func (u *UpdateCollectionQuantizationConfig) UnmarshalJSON(data []byte) error {
	valueQuantizationConfigDiff := new(QuantizationConfigDiff)
	if err := json.Unmarshal(data, &valueQuantizationConfigDiff); err == nil {
		u.typeName = "quantizationConfigDiff"
		u.QuantizationConfigDiff = valueQuantizationConfigDiff
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		u.typeName = "unknown"
		u.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateCollectionQuantizationConfig) MarshalJSON() ([]byte, error) {
	switch u.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "quantizationConfigDiff":
		return json.Marshal(u.QuantizationConfigDiff)
	case "unknown":
		return json.Marshal(u.Unknown)
	}
}

type UpdateCollectionQuantizationConfigVisitor interface {
	VisitQuantizationConfigDiff(*QuantizationConfigDiff) error
	VisitUnknown(interface{}) error
}

func (u *UpdateCollectionQuantizationConfig) Accept(visitor UpdateCollectionQuantizationConfigVisitor) error {
	switch u.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "quantizationConfigDiff":
		return visitor.VisitQuantizationConfigDiff(u.QuantizationConfigDiff)
	case "unknown":
		return visitor.VisitUnknown(u.Unknown)
	}
}

type UpdateCollectionResponse struct {
	// Time spent to process this request
	Time   *float64 `json:"time,omitempty"`
	Status *string  `json:"status,omitempty"`
	Result *bool    `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UpdateCollectionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateCollectionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateCollectionResponse(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateCollectionResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Map of sparse vector data parameters to update for each sparse vector.
type UpdateCollectionSparseVectors struct {
	typeName            string
	SparseVectorsConfig SparseVectorsConfig
	Unknown             interface{}
}

func NewUpdateCollectionSparseVectorsFromSparseVectorsConfig(value SparseVectorsConfig) *UpdateCollectionSparseVectors {
	return &UpdateCollectionSparseVectors{typeName: "sparseVectorsConfig", SparseVectorsConfig: value}
}

func NewUpdateCollectionSparseVectorsFromUnknown(value interface{}) *UpdateCollectionSparseVectors {
	return &UpdateCollectionSparseVectors{typeName: "unknown", Unknown: value}
}

func (u *UpdateCollectionSparseVectors) UnmarshalJSON(data []byte) error {
	var valueSparseVectorsConfig SparseVectorsConfig
	if err := json.Unmarshal(data, &valueSparseVectorsConfig); err == nil {
		u.typeName = "sparseVectorsConfig"
		u.SparseVectorsConfig = valueSparseVectorsConfig
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		u.typeName = "unknown"
		u.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateCollectionSparseVectors) MarshalJSON() ([]byte, error) {
	switch u.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "sparseVectorsConfig":
		return json.Marshal(u.SparseVectorsConfig)
	case "unknown":
		return json.Marshal(u.Unknown)
	}
}

type UpdateCollectionSparseVectorsVisitor interface {
	VisitSparseVectorsConfig(SparseVectorsConfig) error
	VisitUnknown(interface{}) error
}

func (u *UpdateCollectionSparseVectors) Accept(visitor UpdateCollectionSparseVectorsVisitor) error {
	switch u.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "sparseVectorsConfig":
		return visitor.VisitSparseVectorsConfig(u.SparseVectorsConfig)
	case "unknown":
		return visitor.VisitUnknown(u.Unknown)
	}
}

// Map of vector data parameters to update for each named vector. To update parameters in a collection having a single unnamed vector, use an empty string as name.
type UpdateCollectionVectors struct {
	typeName          string
	VectorsConfigDiff VectorsConfigDiff
	Unknown           interface{}
}

func NewUpdateCollectionVectorsFromVectorsConfigDiff(value VectorsConfigDiff) *UpdateCollectionVectors {
	return &UpdateCollectionVectors{typeName: "vectorsConfigDiff", VectorsConfigDiff: value}
}

func NewUpdateCollectionVectorsFromUnknown(value interface{}) *UpdateCollectionVectors {
	return &UpdateCollectionVectors{typeName: "unknown", Unknown: value}
}

func (u *UpdateCollectionVectors) UnmarshalJSON(data []byte) error {
	var valueVectorsConfigDiff VectorsConfigDiff
	if err := json.Unmarshal(data, &valueVectorsConfigDiff); err == nil {
		u.typeName = "vectorsConfigDiff"
		u.VectorsConfigDiff = valueVectorsConfigDiff
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		u.typeName = "unknown"
		u.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateCollectionVectors) MarshalJSON() ([]byte, error) {
	switch u.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "vectorsConfigDiff":
		return json.Marshal(u.VectorsConfigDiff)
	case "unknown":
		return json.Marshal(u.Unknown)
	}
}

type UpdateCollectionVectorsVisitor interface {
	VisitVectorsConfigDiff(VectorsConfigDiff) error
	VisitUnknown(interface{}) error
}

func (u *UpdateCollectionVectors) Accept(visitor UpdateCollectionVectorsVisitor) error {
	switch u.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "vectorsConfigDiff":
		return visitor.VisitVectorsConfigDiff(u.VectorsConfigDiff)
	case "unknown":
		return visitor.VisitUnknown(u.Unknown)
	}
}

type ChangeAliasesOperation struct {
	// Wait for operation commit timeout in seconds.
	// If timeout is reached - request will return with service error.
	Timeout *int               `json:"-"`
	Actions []*AliasOperations `json:"actions,omitempty"`
}

type UpdateCollection struct {
	// Wait for operation commit timeout in seconds.
	// If timeout is reached - request will return with service error.
	Timeout *int `json:"-"`
	// Map of vector data parameters to update for each named vector. To update parameters in a collection having a single unnamed vector, use an empty string as name.
	Vectors *core.Optional[UpdateCollectionVectors] `json:"vectors,omitempty"`
	// Custom params for Optimizers.  If none - it is left unchanged. This operation is blocking, it will only proceed once all current optimizations are complete
	OptimizersConfig *core.Optional[UpdateCollectionOptimizersConfig] `json:"optimizers_config,omitempty"`
	// Collection base params. If none - it is left unchanged.
	Params *core.Optional[UpdateCollectionParams] `json:"params,omitempty"`
	// HNSW parameters to update for the collection index. If none - it is left unchanged.
	HnswConfig *core.Optional[UpdateCollectionHnswConfig] `json:"hnsw_config,omitempty"`
	// Quantization parameters to update. If none - it is left unchanged.
	QuantizationConfig *core.Optional[UpdateCollectionQuantizationConfig] `json:"quantization_config,omitempty"`
	// Map of sparse vector data parameters to update for each sparse vector.
	SparseVectors *core.Optional[UpdateCollectionSparseVectors] `json:"sparse_vectors,omitempty"`
}

type UpdateCollectionClusterRequest struct {
	// Wait for operation commit timeout in seconds.
	// If timeout is reached - request will return with service error.
	Timeout *int               `json:"-"`
	Body    *ClusterOperations `json:"-"`
}

func (u *UpdateCollectionClusterRequest) UnmarshalJSON(data []byte) error {
	body := new(ClusterOperations)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	u.Body = body
	return nil
}

func (u *UpdateCollectionClusterRequest) MarshalJSON() ([]byte, error) {
	return json.Marshal(u.Body)
}
