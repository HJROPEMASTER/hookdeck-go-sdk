// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
)

type Rule struct {
	typeName      string
	RetryRule     *RetryRule
	AlertRule     *AlertRule
	FilterRule    *FilterRule
	TransformRule *TransformRule
	DelayRule     *DelayRule
}

func NewRuleFromRetryRule(value *RetryRule) *Rule {
	return &Rule{typeName: "retryRule", RetryRule: value}
}

func NewRuleFromAlertRule(value *AlertRule) *Rule {
	return &Rule{typeName: "alertRule", AlertRule: value}
}

func NewRuleFromFilterRule(value *FilterRule) *Rule {
	return &Rule{typeName: "filterRule", FilterRule: value}
}

func NewRuleFromTransformRule(value *TransformRule) *Rule {
	return &Rule{typeName: "transformRule", TransformRule: value}
}

func NewRuleFromDelayRule(value *DelayRule) *Rule {
	return &Rule{typeName: "delayRule", DelayRule: value}
}

func (r *Rule) UnmarshalJSON(data []byte) error {
	valueRetryRule := new(RetryRule)
	if err := json.Unmarshal(data, &valueRetryRule); err == nil {
		r.typeName = "retryRule"
		r.RetryRule = valueRetryRule
		return nil
	}
	valueAlertRule := new(AlertRule)
	if err := json.Unmarshal(data, &valueAlertRule); err == nil {
		r.typeName = "alertRule"
		r.AlertRule = valueAlertRule
		return nil
	}
	valueFilterRule := new(FilterRule)
	if err := json.Unmarshal(data, &valueFilterRule); err == nil {
		r.typeName = "filterRule"
		r.FilterRule = valueFilterRule
		return nil
	}
	valueTransformRule := new(TransformRule)
	if err := json.Unmarshal(data, &valueTransformRule); err == nil {
		r.typeName = "transformRule"
		r.TransformRule = valueTransformRule
		return nil
	}
	valueDelayRule := new(DelayRule)
	if err := json.Unmarshal(data, &valueDelayRule); err == nil {
		r.typeName = "delayRule"
		r.DelayRule = valueDelayRule
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r Rule) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "retryRule":
		return json.Marshal(r.RetryRule)
	case "alertRule":
		return json.Marshal(r.AlertRule)
	case "filterRule":
		return json.Marshal(r.FilterRule)
	case "transformRule":
		return json.Marshal(r.TransformRule)
	case "delayRule":
		return json.Marshal(r.DelayRule)
	}
}

type RuleVisitor interface {
	VisitRetryRule(*RetryRule) error
	VisitAlertRule(*AlertRule) error
	VisitFilterRule(*FilterRule) error
	VisitTransformRule(*TransformRule) error
	VisitDelayRule(*DelayRule) error
}

func (r *Rule) Accept(v RuleVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "retryRule":
		return v.VisitRetryRule(r.RetryRule)
	case "alertRule":
		return v.VisitAlertRule(r.AlertRule)
	case "filterRule":
		return v.VisitFilterRule(r.FilterRule)
	case "transformRule":
		return v.VisitTransformRule(r.TransformRule)
	case "delayRule":
		return v.VisitDelayRule(r.DelayRule)
	}
}
