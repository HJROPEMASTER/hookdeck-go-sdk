// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
)

type TransformRule struct {
	typeName           string
	TransformReference *TransformReference
	TransformFull      *TransformFull
}

func NewTransformRuleFromTransformReference(value *TransformReference) *TransformRule {
	return &TransformRule{typeName: "transformReference", TransformReference: value}
}

func NewTransformRuleFromTransformFull(value *TransformFull) *TransformRule {
	return &TransformRule{typeName: "transformFull", TransformFull: value}
}

func (t *TransformRule) UnmarshalJSON(data []byte) error {
	valueTransformReference := new(TransformReference)
	if err := json.Unmarshal(data, &valueTransformReference); err == nil {
		t.typeName = "transformReference"
		t.TransformReference = valueTransformReference
		return nil
	}
	valueTransformFull := new(TransformFull)
	if err := json.Unmarshal(data, &valueTransformFull); err == nil {
		t.typeName = "transformFull"
		t.TransformFull = valueTransformFull
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransformRule) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transformReference":
		return json.Marshal(t.TransformReference)
	case "transformFull":
		return json.Marshal(t.TransformFull)
	}
}

type TransformRuleVisitor interface {
	VisitTransformReference(*TransformReference) error
	VisitTransformFull(*TransformFull) error
}

func (t *TransformRule) Accept(v TransformRuleVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transformReference":
		return v.VisitTransformReference(t.TransformReference)
	case "transformFull":
		return v.VisitTransformFull(t.TransformFull)
	}
}
