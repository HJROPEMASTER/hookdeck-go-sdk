// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
)

type RequestDataHeaders struct {
	typeName                string
	String                  string
	StringStringOptionalMap map[string]*string
}

func NewRequestDataHeadersFromString(value string) *RequestDataHeaders {
	return &RequestDataHeaders{typeName: "string", String: value}
}

func NewRequestDataHeadersFromStringStringOptionalMap(value map[string]*string) *RequestDataHeaders {
	return &RequestDataHeaders{typeName: "stringStringOptionalMap", StringStringOptionalMap: value}
}

func (r *RequestDataHeaders) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	var valueStringStringOptionalMap map[string]*string
	if err := json.Unmarshal(data, &valueStringStringOptionalMap); err == nil {
		r.typeName = "stringStringOptionalMap"
		r.StringStringOptionalMap = valueStringStringOptionalMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestDataHeaders) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return json.Marshal(r.String)
	case "stringStringOptionalMap":
		return json.Marshal(r.StringStringOptionalMap)
	}
}

type RequestDataHeadersVisitor interface {
	VisitString(string) error
	VisitStringStringOptionalMap(map[string]*string) error
}

func (r *RequestDataHeaders) Accept(v RequestDataHeadersVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return v.VisitString(r.String)
	case "stringStringOptionalMap":
		return v.VisitStringStringOptionalMap(r.StringStringOptionalMap)
	}
}
