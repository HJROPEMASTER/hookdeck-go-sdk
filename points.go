// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/hookdeck/hookdeck-go-sdk/core"
)

type UpdateOperations struct {
	// If true, wait for changes to actually happen
	Wait *bool `json:"-"`
	// define ordering guarantees for the operation
	Ordering   *WriteOrdering     `json:"-"`
	Operations []*UpdateOperation `json:"operations,omitempty"`
}

type ClearPayloadRequest struct {
	// If true, wait for changes to actually happen
	Wait *bool `json:"-"`
	// define ordering guarantees for the operation
	Ordering *WriteOrdering  `json:"-"`
	Body     *PointsSelector `json:"-"`
}

func (c *ClearPayloadRequest) UnmarshalJSON(data []byte) error {
	body := new(PointsSelector)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	c.Body = body
	return nil
}

func (c *ClearPayloadRequest) MarshalJSON() ([]byte, error) {
	return json.Marshal(c.Body)
}

type CountRequest struct {
	// Specify in which shards to look for the points, if not specified - look in all shards
	ShardKey *core.Optional[CountRequestShardKey] `json:"shard_key,omitempty"`
	// Look only for points which satisfies this conditions
	Filter *core.Optional[CountRequestFilter] `json:"filter,omitempty"`
	// If true, count exact number of points. If false, count approximate number of points faster. Approximate count might be unreliable during the indexing process. Default: true
	Exact *core.Optional[bool] `json:"exact,omitempty"`
}

type DeletePayloadRequest struct {
	// If true, wait for changes to actually happen
	Wait *bool `json:"-"`
	// define ordering guarantees for the operation
	Ordering *WriteOrdering `json:"-"`
	Body     *DeletePayload `json:"-"`
}

func (d *DeletePayloadRequest) UnmarshalJSON(data []byte) error {
	body := new(DeletePayload)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	d.Body = body
	return nil
}

func (d *DeletePayloadRequest) MarshalJSON() ([]byte, error) {
	return json.Marshal(d.Body)
}

type DeletePointsRequest struct {
	// If true, wait for changes to actually happen
	Wait *bool `json:"-"`
	// define ordering guarantees for the operation
	Ordering *WriteOrdering  `json:"-"`
	Body     *PointsSelector `json:"-"`
}

func (d *DeletePointsRequest) UnmarshalJSON(data []byte) error {
	body := new(PointsSelector)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	d.Body = body
	return nil
}

func (d *DeletePointsRequest) MarshalJSON() ([]byte, error) {
	return json.Marshal(d.Body)
}

type DeleteVectorsRequest struct {
	// If true, wait for changes to actually happen
	Wait *bool `json:"-"`
	// define ordering guarantees for the operation
	Ordering *WriteOrdering `json:"-"`
	Body     *DeleteVectors `json:"-"`
}

func (d *DeleteVectorsRequest) UnmarshalJSON(data []byte) error {
	body := new(DeleteVectors)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	d.Body = body
	return nil
}

func (d *DeleteVectorsRequest) MarshalJSON() ([]byte, error) {
	return json.Marshal(d.Body)
}

type DiscoverRequestBatch struct {
	// If set, overrides global timeout for this request. Unit is seconds.
	Timeout  *int               `json:"-"`
	Searches []*DiscoverRequest `json:"searches,omitempty"`
}

type DiscoverPointsRequest struct {
	// If set, overrides global timeout for this request. Unit is seconds.
	Timeout *int             `json:"-"`
	Body    *DiscoverRequest `json:"-"`
}

func (d *DiscoverPointsRequest) UnmarshalJSON(data []byte) error {
	body := new(DiscoverRequest)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	d.Body = body
	return nil
}

func (d *DiscoverPointsRequest) MarshalJSON() ([]byte, error) {
	return json.Marshal(d.Body)
}

type PointRequest struct {
	// Specify in which shards to look for the points, if not specified - look in all shards
	ShardKey *core.Optional[PointRequestShardKey] `json:"shard_key,omitempty"`
	// Look for points with ids
	Ids []*ExtendedPointId `json:"ids,omitempty"`
	// Select which payload to return with the response. Default: All
	WithPayload *core.Optional[PointRequestWithPayload] `json:"with_payload,omitempty"`
	WithVector  *core.Optional[WithVector]              `json:"with_vector,omitempty"`
}

type OverwritePayloadRequest struct {
	// If true, wait for changes to actually happen
	Wait *bool `json:"-"`
	// define ordering guarantees for the operation
	Ordering *WriteOrdering `json:"-"`
	Body     *SetPayload    `json:"-"`
}

func (o *OverwritePayloadRequest) UnmarshalJSON(data []byte) error {
	body := new(SetPayload)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	o.Body = body
	return nil
}

func (o *OverwritePayloadRequest) MarshalJSON() ([]byte, error) {
	return json.Marshal(o.Body)
}

type RecommendRequestBatch struct {
	// If set, overrides global timeout for this request. Unit is seconds.
	Timeout  *int                `json:"-"`
	Searches []*RecommendRequest `json:"searches,omitempty"`
}

type RecommendGroupsRequest struct {
	// If set, overrides global timeout for this request. Unit is seconds.
	Timeout *int `json:"-"`
	// Specify in which shards to look for the points, if not specified - look in all shards
	ShardKey *core.Optional[RecommendGroupsRequestShardKey] `json:"shard_key,omitempty"`
	// Look for vectors closest to those
	Positive *core.Optional[[]*RecommendExample] `json:"positive,omitempty"`
	// Try to avoid vectors like this
	Negative *core.Optional[[]*RecommendExample] `json:"negative,omitempty"`
	// How to use positive and negative examples to find the results
	Strategy *core.Optional[RecommendGroupsRequestStrategy] `json:"strategy,omitempty"`
	// Look only for points which satisfies this conditions
	Filter *core.Optional[RecommendGroupsRequestFilter] `json:"filter,omitempty"`
	// Additional search params
	Params *core.Optional[RecommendGroupsRequestParams] `json:"params,omitempty"`
	// Select which payload to return with the response. Default: None
	WithPayload *core.Optional[RecommendGroupsRequestWithPayload] `json:"with_payload,omitempty"`
	// Whether to return the point vector with the result?
	WithVector *core.Optional[RecommendGroupsRequestWithVector] `json:"with_vector,omitempty"`
	// Define a minimal score threshold for the result. If defined, less similar results will not be returned. Score of the returned result might be higher or smaller than the threshold depending on the Distance function used. E.g. for cosine similarity only higher scores will be returned.
	ScoreThreshold *core.Optional[float64] `json:"score_threshold,omitempty"`
	// Define which vector to use for recommendation, if not specified - try to use default vector
	Using *core.Optional[RecommendGroupsRequestUsing] `json:"using,omitempty"`
	// The location used to lookup vectors. If not specified - use current collection. Note: the other collection should have the same vector size as the current collection
	LookupFrom *core.Optional[RecommendGroupsRequestLookupFrom] `json:"lookup_from,omitempty"`
	// Payload field to group by, must be a string or number field. If the field contains more than 1 value, all values will be used for grouping. One point can be in multiple groups.
	GroupBy string `json:"group_by"`
	// Maximum amount of points to return per group
	GroupSize int `json:"group_size"`
	// Maximum amount of groups to return
	Limit int `json:"limit"`
	// Look for points in another collection using the group ids
	WithLookup *core.Optional[RecommendGroupsRequestWithLookup] `json:"with_lookup,omitempty"`
}

type RecommendPointsRequest struct {
	// If set, overrides global timeout for this request. Unit is seconds.
	Timeout *int              `json:"-"`
	Body    *RecommendRequest `json:"-"`
}

func (r *RecommendPointsRequest) UnmarshalJSON(data []byte) error {
	body := new(RecommendRequest)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	r.Body = body
	return nil
}

func (r *RecommendPointsRequest) MarshalJSON() ([]byte, error) {
	return json.Marshal(r.Body)
}

type ScrollRequest struct {
	// Specify in which shards to look for the points, if not specified - look in all shards
	ShardKey *core.Optional[ScrollRequestShardKey] `json:"shard_key,omitempty"`
	// Start ID to read points from.
	Offset *core.Optional[ScrollRequestOffset] `json:"offset,omitempty"`
	// Page size. Default: 10
	Limit *core.Optional[int] `json:"limit,omitempty"`
	// Look only for points which satisfies this conditions. If not provided - all points.
	Filter *core.Optional[ScrollRequestFilter] `json:"filter,omitempty"`
	// Select which payload to return with the response. Default: All
	WithPayload *core.Optional[ScrollRequestWithPayload] `json:"with_payload,omitempty"`
	WithVector  *core.Optional[WithVector]               `json:"with_vector,omitempty"`
}

type SearchRequestBatch struct {
	// If set, overrides global timeout for this request. Unit is seconds.
	Timeout  *int             `json:"-"`
	Searches []*SearchRequest `json:"searches,omitempty"`
}

type SearchGroupsRequest struct {
	// If set, overrides global timeout for this request. Unit is seconds.
	Timeout *int `json:"-"`
	// Specify in which shards to look for the points, if not specified - look in all shards
	ShardKey *core.Optional[SearchGroupsRequestShardKey] `json:"shard_key,omitempty"`
	Vector   *NamedVectorStruct                          `json:"vector,omitempty"`
	// Look only for points which satisfies this conditions
	Filter *core.Optional[SearchGroupsRequestFilter] `json:"filter,omitempty"`
	// Additional search params
	Params *core.Optional[SearchGroupsRequestParams] `json:"params,omitempty"`
	// Select which payload to return with the response. Default: None
	WithPayload *core.Optional[SearchGroupsRequestWithPayload] `json:"with_payload,omitempty"`
	// Whether to return the point vector with the result?
	WithVector *core.Optional[SearchGroupsRequestWithVector] `json:"with_vector,omitempty"`
	// Define a minimal score threshold for the result. If defined, less similar results will not be returned. Score of the returned result might be higher or smaller than the threshold depending on the Distance function used. E.g. for cosine similarity only higher scores will be returned.
	ScoreThreshold *core.Optional[float64] `json:"score_threshold,omitempty"`
	// Payload field to group by, must be a string or number field. If the field contains more than 1 value, all values will be used for grouping. One point can be in multiple groups.
	GroupBy string `json:"group_by"`
	// Maximum amount of points to return per group
	GroupSize int `json:"group_size"`
	// Maximum amount of groups to return
	Limit int `json:"limit"`
	// Look for points in another collection using the group ids
	WithLookup *core.Optional[SearchGroupsRequestWithLookup] `json:"with_lookup,omitempty"`
}

type SearchPointsRequest struct {
	// If set, overrides global timeout for this request. Unit is seconds.
	Timeout *int           `json:"-"`
	Body    *SearchRequest `json:"-"`
}

func (s *SearchPointsRequest) UnmarshalJSON(data []byte) error {
	body := new(SearchRequest)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	s.Body = body
	return nil
}

func (s *SearchPointsRequest) MarshalJSON() ([]byte, error) {
	return json.Marshal(s.Body)
}

type SetPayloadRequest struct {
	// If true, wait for changes to actually happen
	Wait *bool `json:"-"`
	// define ordering guarantees for the operation
	Ordering *WriteOrdering `json:"-"`
	Body     *SetPayload    `json:"-"`
}

func (s *SetPayloadRequest) UnmarshalJSON(data []byte) error {
	body := new(SetPayload)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	s.Body = body
	return nil
}

func (s *SetPayloadRequest) MarshalJSON() ([]byte, error) {
	return json.Marshal(s.Body)
}

type BatchUpdateResponse struct {
	// Time spent to process this request
	Time   *float64        `json:"time,omitempty"`
	Status *string         `json:"status,omitempty"`
	Result []*UpdateResult `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BatchUpdateResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchUpdateResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchUpdateResponse(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchUpdateResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type ClearPayloadResponse struct {
	// Time spent to process this request
	Time   *float64      `json:"time,omitempty"`
	Status *string       `json:"status,omitempty"`
	Result *UpdateResult `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClearPayloadResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClearPayloadResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClearPayloadResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClearPayloadResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CountPointsResponse struct {
	// Time spent to process this request
	Time   *float64     `json:"time,omitempty"`
	Status *string      `json:"status,omitempty"`
	Result *CountResult `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CountPointsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CountPointsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CountPointsResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CountPointsResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Look only for points which satisfies this conditions
type CountRequestFilter struct {
	typeName string
	Filter   *Filter
	Unknown  interface{}
}

func NewCountRequestFilterFromFilter(value *Filter) *CountRequestFilter {
	return &CountRequestFilter{typeName: "filter", Filter: value}
}

func NewCountRequestFilterFromUnknown(value interface{}) *CountRequestFilter {
	return &CountRequestFilter{typeName: "unknown", Unknown: value}
}

func (c *CountRequestFilter) UnmarshalJSON(data []byte) error {
	valueFilter := new(Filter)
	if err := json.Unmarshal(data, &valueFilter); err == nil {
		c.typeName = "filter"
		c.Filter = valueFilter
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		c.typeName = "unknown"
		c.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CountRequestFilter) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "filter":
		return json.Marshal(c.Filter)
	case "unknown":
		return json.Marshal(c.Unknown)
	}
}

type CountRequestFilterVisitor interface {
	VisitFilter(*Filter) error
	VisitUnknown(interface{}) error
}

func (c *CountRequestFilter) Accept(visitor CountRequestFilterVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "filter":
		return visitor.VisitFilter(c.Filter)
	case "unknown":
		return visitor.VisitUnknown(c.Unknown)
	}
}

// Specify in which shards to look for the points, if not specified - look in all shards
type CountRequestShardKey struct {
	typeName         string
	ShardKeySelector *ShardKeySelector
	Unknown          interface{}
}

func NewCountRequestShardKeyFromShardKeySelector(value *ShardKeySelector) *CountRequestShardKey {
	return &CountRequestShardKey{typeName: "shardKeySelector", ShardKeySelector: value}
}

func NewCountRequestShardKeyFromUnknown(value interface{}) *CountRequestShardKey {
	return &CountRequestShardKey{typeName: "unknown", Unknown: value}
}

func (c *CountRequestShardKey) UnmarshalJSON(data []byte) error {
	valueShardKeySelector := new(ShardKeySelector)
	if err := json.Unmarshal(data, &valueShardKeySelector); err == nil {
		c.typeName = "shardKeySelector"
		c.ShardKeySelector = valueShardKeySelector
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		c.typeName = "unknown"
		c.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CountRequestShardKey) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "shardKeySelector":
		return json.Marshal(c.ShardKeySelector)
	case "unknown":
		return json.Marshal(c.Unknown)
	}
}

type CountRequestShardKeyVisitor interface {
	VisitShardKeySelector(*ShardKeySelector) error
	VisitUnknown(interface{}) error
}

func (c *CountRequestShardKey) Accept(visitor CountRequestShardKeyVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "shardKeySelector":
		return visitor.VisitShardKeySelector(c.ShardKeySelector)
	case "unknown":
		return visitor.VisitUnknown(c.Unknown)
	}
}

type DeletePayloadResponse struct {
	// Time spent to process this request
	Time   *float64      `json:"time,omitempty"`
	Status *string       `json:"status,omitempty"`
	Result *UpdateResult `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeletePayloadResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeletePayloadResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeletePayloadResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeletePayloadResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeletePointsResponse struct {
	// Time spent to process this request
	Time   *float64      `json:"time,omitempty"`
	Status *string       `json:"status,omitempty"`
	Result *UpdateResult `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeletePointsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeletePointsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeletePointsResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeletePointsResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVectorsResponse struct {
	// Time spent to process this request
	Time   *float64      `json:"time,omitempty"`
	Status *string       `json:"status,omitempty"`
	Result *UpdateResult `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVectorsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVectorsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVectorsResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVectorsResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DiscoverBatchPointsResponse struct {
	// Time spent to process this request
	Time   *float64         `json:"time,omitempty"`
	Status *string          `json:"status,omitempty"`
	Result [][]*ScoredPoint `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DiscoverBatchPointsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DiscoverBatchPointsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DiscoverBatchPointsResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DiscoverBatchPointsResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DiscoverPointsResponse struct {
	// Time spent to process this request
	Time   *float64       `json:"time,omitempty"`
	Status *string        `json:"status,omitempty"`
	Result []*ScoredPoint `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DiscoverPointsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DiscoverPointsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DiscoverPointsResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DiscoverPointsResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type GetPointResponse struct {
	// Time spent to process this request
	Time   *float64 `json:"time,omitempty"`
	Status *string  `json:"status,omitempty"`
	Result *Record  `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetPointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetPointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetPointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetPointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetPointsResponse struct {
	// Time spent to process this request
	Time   *float64  `json:"time,omitempty"`
	Status *string   `json:"status,omitempty"`
	Result []*Record `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetPointsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetPointsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetPointsResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetPointsResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type OverwritePayloadResponse struct {
	// Time spent to process this request
	Time   *float64      `json:"time,omitempty"`
	Status *string       `json:"status,omitempty"`
	Result *UpdateResult `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (o *OverwritePayloadResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler OverwritePayloadResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OverwritePayloadResponse(value)
	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OverwritePayloadResponse) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Specify in which shards to look for the points, if not specified - look in all shards
type PointRequestShardKey struct {
	typeName         string
	ShardKeySelector *ShardKeySelector
	Unknown          interface{}
}

func NewPointRequestShardKeyFromShardKeySelector(value *ShardKeySelector) *PointRequestShardKey {
	return &PointRequestShardKey{typeName: "shardKeySelector", ShardKeySelector: value}
}

func NewPointRequestShardKeyFromUnknown(value interface{}) *PointRequestShardKey {
	return &PointRequestShardKey{typeName: "unknown", Unknown: value}
}

func (p *PointRequestShardKey) UnmarshalJSON(data []byte) error {
	valueShardKeySelector := new(ShardKeySelector)
	if err := json.Unmarshal(data, &valueShardKeySelector); err == nil {
		p.typeName = "shardKeySelector"
		p.ShardKeySelector = valueShardKeySelector
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		p.typeName = "unknown"
		p.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PointRequestShardKey) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "shardKeySelector":
		return json.Marshal(p.ShardKeySelector)
	case "unknown":
		return json.Marshal(p.Unknown)
	}
}

type PointRequestShardKeyVisitor interface {
	VisitShardKeySelector(*ShardKeySelector) error
	VisitUnknown(interface{}) error
}

func (p *PointRequestShardKey) Accept(visitor PointRequestShardKeyVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "shardKeySelector":
		return visitor.VisitShardKeySelector(p.ShardKeySelector)
	case "unknown":
		return visitor.VisitUnknown(p.Unknown)
	}
}

// Select which payload to return with the response. Default: All
type PointRequestWithPayload struct {
	typeName             string
	WithPayloadInterface *WithPayloadInterface
	Unknown              interface{}
}

func NewPointRequestWithPayloadFromWithPayloadInterface(value *WithPayloadInterface) *PointRequestWithPayload {
	return &PointRequestWithPayload{typeName: "withPayloadInterface", WithPayloadInterface: value}
}

func NewPointRequestWithPayloadFromUnknown(value interface{}) *PointRequestWithPayload {
	return &PointRequestWithPayload{typeName: "unknown", Unknown: value}
}

func (p *PointRequestWithPayload) UnmarshalJSON(data []byte) error {
	valueWithPayloadInterface := new(WithPayloadInterface)
	if err := json.Unmarshal(data, &valueWithPayloadInterface); err == nil {
		p.typeName = "withPayloadInterface"
		p.WithPayloadInterface = valueWithPayloadInterface
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		p.typeName = "unknown"
		p.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PointRequestWithPayload) MarshalJSON() ([]byte, error) {
	switch p.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "withPayloadInterface":
		return json.Marshal(p.WithPayloadInterface)
	case "unknown":
		return json.Marshal(p.Unknown)
	}
}

type PointRequestWithPayloadVisitor interface {
	VisitWithPayloadInterface(*WithPayloadInterface) error
	VisitUnknown(interface{}) error
}

func (p *PointRequestWithPayload) Accept(visitor PointRequestWithPayloadVisitor) error {
	switch p.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", p.typeName, p)
	case "withPayloadInterface":
		return visitor.VisitWithPayloadInterface(p.WithPayloadInterface)
	case "unknown":
		return visitor.VisitUnknown(p.Unknown)
	}
}

type RecommendBatchPointsResponse struct {
	// Time spent to process this request
	Time   *float64         `json:"time,omitempty"`
	Status *string          `json:"status,omitempty"`
	Result [][]*ScoredPoint `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RecommendBatchPointsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RecommendBatchPointsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RecommendBatchPointsResponse(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RecommendBatchPointsResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Look only for points which satisfies this conditions
type RecommendGroupsRequestFilter struct {
	typeName string
	Filter   *Filter
	Unknown  interface{}
}

func NewRecommendGroupsRequestFilterFromFilter(value *Filter) *RecommendGroupsRequestFilter {
	return &RecommendGroupsRequestFilter{typeName: "filter", Filter: value}
}

func NewRecommendGroupsRequestFilterFromUnknown(value interface{}) *RecommendGroupsRequestFilter {
	return &RecommendGroupsRequestFilter{typeName: "unknown", Unknown: value}
}

func (r *RecommendGroupsRequestFilter) UnmarshalJSON(data []byte) error {
	valueFilter := new(Filter)
	if err := json.Unmarshal(data, &valueFilter); err == nil {
		r.typeName = "filter"
		r.Filter = valueFilter
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		r.typeName = "unknown"
		r.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RecommendGroupsRequestFilter) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "filter":
		return json.Marshal(r.Filter)
	case "unknown":
		return json.Marshal(r.Unknown)
	}
}

type RecommendGroupsRequestFilterVisitor interface {
	VisitFilter(*Filter) error
	VisitUnknown(interface{}) error
}

func (r *RecommendGroupsRequestFilter) Accept(visitor RecommendGroupsRequestFilterVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "filter":
		return visitor.VisitFilter(r.Filter)
	case "unknown":
		return visitor.VisitUnknown(r.Unknown)
	}
}

// The location used to lookup vectors. If not specified - use current collection. Note: the other collection should have the same vector size as the current collection
type RecommendGroupsRequestLookupFrom struct {
	typeName       string
	LookupLocation *LookupLocation
	Unknown        interface{}
}

func NewRecommendGroupsRequestLookupFromFromLookupLocation(value *LookupLocation) *RecommendGroupsRequestLookupFrom {
	return &RecommendGroupsRequestLookupFrom{typeName: "lookupLocation", LookupLocation: value}
}

func NewRecommendGroupsRequestLookupFromFromUnknown(value interface{}) *RecommendGroupsRequestLookupFrom {
	return &RecommendGroupsRequestLookupFrom{typeName: "unknown", Unknown: value}
}

func (r *RecommendGroupsRequestLookupFrom) UnmarshalJSON(data []byte) error {
	valueLookupLocation := new(LookupLocation)
	if err := json.Unmarshal(data, &valueLookupLocation); err == nil {
		r.typeName = "lookupLocation"
		r.LookupLocation = valueLookupLocation
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		r.typeName = "unknown"
		r.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RecommendGroupsRequestLookupFrom) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "lookupLocation":
		return json.Marshal(r.LookupLocation)
	case "unknown":
		return json.Marshal(r.Unknown)
	}
}

type RecommendGroupsRequestLookupFromVisitor interface {
	VisitLookupLocation(*LookupLocation) error
	VisitUnknown(interface{}) error
}

func (r *RecommendGroupsRequestLookupFrom) Accept(visitor RecommendGroupsRequestLookupFromVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "lookupLocation":
		return visitor.VisitLookupLocation(r.LookupLocation)
	case "unknown":
		return visitor.VisitUnknown(r.Unknown)
	}
}

// Additional search params
type RecommendGroupsRequestParams struct {
	typeName     string
	SearchParams *SearchParams
	Unknown      interface{}
}

func NewRecommendGroupsRequestParamsFromSearchParams(value *SearchParams) *RecommendGroupsRequestParams {
	return &RecommendGroupsRequestParams{typeName: "searchParams", SearchParams: value}
}

func NewRecommendGroupsRequestParamsFromUnknown(value interface{}) *RecommendGroupsRequestParams {
	return &RecommendGroupsRequestParams{typeName: "unknown", Unknown: value}
}

func (r *RecommendGroupsRequestParams) UnmarshalJSON(data []byte) error {
	valueSearchParams := new(SearchParams)
	if err := json.Unmarshal(data, &valueSearchParams); err == nil {
		r.typeName = "searchParams"
		r.SearchParams = valueSearchParams
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		r.typeName = "unknown"
		r.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RecommendGroupsRequestParams) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "searchParams":
		return json.Marshal(r.SearchParams)
	case "unknown":
		return json.Marshal(r.Unknown)
	}
}

type RecommendGroupsRequestParamsVisitor interface {
	VisitSearchParams(*SearchParams) error
	VisitUnknown(interface{}) error
}

func (r *RecommendGroupsRequestParams) Accept(visitor RecommendGroupsRequestParamsVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "searchParams":
		return visitor.VisitSearchParams(r.SearchParams)
	case "unknown":
		return visitor.VisitUnknown(r.Unknown)
	}
}

// Specify in which shards to look for the points, if not specified - look in all shards
type RecommendGroupsRequestShardKey struct {
	typeName         string
	ShardKeySelector *ShardKeySelector
	Unknown          interface{}
}

func NewRecommendGroupsRequestShardKeyFromShardKeySelector(value *ShardKeySelector) *RecommendGroupsRequestShardKey {
	return &RecommendGroupsRequestShardKey{typeName: "shardKeySelector", ShardKeySelector: value}
}

func NewRecommendGroupsRequestShardKeyFromUnknown(value interface{}) *RecommendGroupsRequestShardKey {
	return &RecommendGroupsRequestShardKey{typeName: "unknown", Unknown: value}
}

func (r *RecommendGroupsRequestShardKey) UnmarshalJSON(data []byte) error {
	valueShardKeySelector := new(ShardKeySelector)
	if err := json.Unmarshal(data, &valueShardKeySelector); err == nil {
		r.typeName = "shardKeySelector"
		r.ShardKeySelector = valueShardKeySelector
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		r.typeName = "unknown"
		r.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RecommendGroupsRequestShardKey) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "shardKeySelector":
		return json.Marshal(r.ShardKeySelector)
	case "unknown":
		return json.Marshal(r.Unknown)
	}
}

type RecommendGroupsRequestShardKeyVisitor interface {
	VisitShardKeySelector(*ShardKeySelector) error
	VisitUnknown(interface{}) error
}

func (r *RecommendGroupsRequestShardKey) Accept(visitor RecommendGroupsRequestShardKeyVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "shardKeySelector":
		return visitor.VisitShardKeySelector(r.ShardKeySelector)
	case "unknown":
		return visitor.VisitUnknown(r.Unknown)
	}
}

// How to use positive and negative examples to find the results
type RecommendGroupsRequestStrategy struct {
	typeName          string
	RecommendStrategy RecommendStrategy
	Unknown           interface{}
}

func NewRecommendGroupsRequestStrategyFromRecommendStrategy(value RecommendStrategy) *RecommendGroupsRequestStrategy {
	return &RecommendGroupsRequestStrategy{typeName: "recommendStrategy", RecommendStrategy: value}
}

func NewRecommendGroupsRequestStrategyFromUnknown(value interface{}) *RecommendGroupsRequestStrategy {
	return &RecommendGroupsRequestStrategy{typeName: "unknown", Unknown: value}
}

func (r *RecommendGroupsRequestStrategy) UnmarshalJSON(data []byte) error {
	var valueRecommendStrategy RecommendStrategy
	if err := json.Unmarshal(data, &valueRecommendStrategy); err == nil {
		r.typeName = "recommendStrategy"
		r.RecommendStrategy = valueRecommendStrategy
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		r.typeName = "unknown"
		r.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RecommendGroupsRequestStrategy) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "recommendStrategy":
		return json.Marshal(r.RecommendStrategy)
	case "unknown":
		return json.Marshal(r.Unknown)
	}
}

type RecommendGroupsRequestStrategyVisitor interface {
	VisitRecommendStrategy(RecommendStrategy) error
	VisitUnknown(interface{}) error
}

func (r *RecommendGroupsRequestStrategy) Accept(visitor RecommendGroupsRequestStrategyVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "recommendStrategy":
		return visitor.VisitRecommendStrategy(r.RecommendStrategy)
	case "unknown":
		return visitor.VisitUnknown(r.Unknown)
	}
}

// Define which vector to use for recommendation, if not specified - try to use default vector
type RecommendGroupsRequestUsing struct {
	typeName    string
	UsingVector UsingVector
	Unknown     interface{}
}

func NewRecommendGroupsRequestUsingFromUsingVector(value UsingVector) *RecommendGroupsRequestUsing {
	return &RecommendGroupsRequestUsing{typeName: "usingVector", UsingVector: value}
}

func NewRecommendGroupsRequestUsingFromUnknown(value interface{}) *RecommendGroupsRequestUsing {
	return &RecommendGroupsRequestUsing{typeName: "unknown", Unknown: value}
}

func (r *RecommendGroupsRequestUsing) UnmarshalJSON(data []byte) error {
	var valueUsingVector UsingVector
	if err := json.Unmarshal(data, &valueUsingVector); err == nil {
		r.typeName = "usingVector"
		r.UsingVector = valueUsingVector
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		r.typeName = "unknown"
		r.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RecommendGroupsRequestUsing) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "usingVector":
		return json.Marshal(r.UsingVector)
	case "unknown":
		return json.Marshal(r.Unknown)
	}
}

type RecommendGroupsRequestUsingVisitor interface {
	VisitUsingVector(UsingVector) error
	VisitUnknown(interface{}) error
}

func (r *RecommendGroupsRequestUsing) Accept(visitor RecommendGroupsRequestUsingVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "usingVector":
		return visitor.VisitUsingVector(r.UsingVector)
	case "unknown":
		return visitor.VisitUnknown(r.Unknown)
	}
}

// Look for points in another collection using the group ids
type RecommendGroupsRequestWithLookup struct {
	typeName            string
	WithLookupInterface *WithLookupInterface
	Unknown             interface{}
}

func NewRecommendGroupsRequestWithLookupFromWithLookupInterface(value *WithLookupInterface) *RecommendGroupsRequestWithLookup {
	return &RecommendGroupsRequestWithLookup{typeName: "withLookupInterface", WithLookupInterface: value}
}

func NewRecommendGroupsRequestWithLookupFromUnknown(value interface{}) *RecommendGroupsRequestWithLookup {
	return &RecommendGroupsRequestWithLookup{typeName: "unknown", Unknown: value}
}

func (r *RecommendGroupsRequestWithLookup) UnmarshalJSON(data []byte) error {
	valueWithLookupInterface := new(WithLookupInterface)
	if err := json.Unmarshal(data, &valueWithLookupInterface); err == nil {
		r.typeName = "withLookupInterface"
		r.WithLookupInterface = valueWithLookupInterface
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		r.typeName = "unknown"
		r.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RecommendGroupsRequestWithLookup) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "withLookupInterface":
		return json.Marshal(r.WithLookupInterface)
	case "unknown":
		return json.Marshal(r.Unknown)
	}
}

type RecommendGroupsRequestWithLookupVisitor interface {
	VisitWithLookupInterface(*WithLookupInterface) error
	VisitUnknown(interface{}) error
}

func (r *RecommendGroupsRequestWithLookup) Accept(visitor RecommendGroupsRequestWithLookupVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "withLookupInterface":
		return visitor.VisitWithLookupInterface(r.WithLookupInterface)
	case "unknown":
		return visitor.VisitUnknown(r.Unknown)
	}
}

// Select which payload to return with the response. Default: None
type RecommendGroupsRequestWithPayload struct {
	typeName             string
	WithPayloadInterface *WithPayloadInterface
	Unknown              interface{}
}

func NewRecommendGroupsRequestWithPayloadFromWithPayloadInterface(value *WithPayloadInterface) *RecommendGroupsRequestWithPayload {
	return &RecommendGroupsRequestWithPayload{typeName: "withPayloadInterface", WithPayloadInterface: value}
}

func NewRecommendGroupsRequestWithPayloadFromUnknown(value interface{}) *RecommendGroupsRequestWithPayload {
	return &RecommendGroupsRequestWithPayload{typeName: "unknown", Unknown: value}
}

func (r *RecommendGroupsRequestWithPayload) UnmarshalJSON(data []byte) error {
	valueWithPayloadInterface := new(WithPayloadInterface)
	if err := json.Unmarshal(data, &valueWithPayloadInterface); err == nil {
		r.typeName = "withPayloadInterface"
		r.WithPayloadInterface = valueWithPayloadInterface
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		r.typeName = "unknown"
		r.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RecommendGroupsRequestWithPayload) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "withPayloadInterface":
		return json.Marshal(r.WithPayloadInterface)
	case "unknown":
		return json.Marshal(r.Unknown)
	}
}

type RecommendGroupsRequestWithPayloadVisitor interface {
	VisitWithPayloadInterface(*WithPayloadInterface) error
	VisitUnknown(interface{}) error
}

func (r *RecommendGroupsRequestWithPayload) Accept(visitor RecommendGroupsRequestWithPayloadVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "withPayloadInterface":
		return visitor.VisitWithPayloadInterface(r.WithPayloadInterface)
	case "unknown":
		return visitor.VisitUnknown(r.Unknown)
	}
}

// Whether to return the point vector with the result?
type RecommendGroupsRequestWithVector struct {
	typeName   string
	WithVector *WithVector
	Unknown    interface{}
}

func NewRecommendGroupsRequestWithVectorFromWithVector(value *WithVector) *RecommendGroupsRequestWithVector {
	return &RecommendGroupsRequestWithVector{typeName: "withVector", WithVector: value}
}

func NewRecommendGroupsRequestWithVectorFromUnknown(value interface{}) *RecommendGroupsRequestWithVector {
	return &RecommendGroupsRequestWithVector{typeName: "unknown", Unknown: value}
}

func (r *RecommendGroupsRequestWithVector) UnmarshalJSON(data []byte) error {
	valueWithVector := new(WithVector)
	if err := json.Unmarshal(data, &valueWithVector); err == nil {
		r.typeName = "withVector"
		r.WithVector = valueWithVector
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		r.typeName = "unknown"
		r.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RecommendGroupsRequestWithVector) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "withVector":
		return json.Marshal(r.WithVector)
	case "unknown":
		return json.Marshal(r.Unknown)
	}
}

type RecommendGroupsRequestWithVectorVisitor interface {
	VisitWithVector(*WithVector) error
	VisitUnknown(interface{}) error
}

func (r *RecommendGroupsRequestWithVector) Accept(visitor RecommendGroupsRequestWithVectorVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "withVector":
		return visitor.VisitWithVector(r.WithVector)
	case "unknown":
		return visitor.VisitUnknown(r.Unknown)
	}
}

type RecommendPointGroupsResponse struct {
	// Time spent to process this request
	Time   *float64      `json:"time,omitempty"`
	Status *string       `json:"status,omitempty"`
	Result *GroupsResult `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RecommendPointGroupsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RecommendPointGroupsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RecommendPointGroupsResponse(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RecommendPointGroupsResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RecommendPointsResponse struct {
	// Time spent to process this request
	Time   *float64       `json:"time,omitempty"`
	Status *string        `json:"status,omitempty"`
	Result []*ScoredPoint `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RecommendPointsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RecommendPointsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RecommendPointsResponse(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RecommendPointsResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ScrollPointsResponse struct {
	// Time spent to process this request
	Time   *float64      `json:"time,omitempty"`
	Status *string       `json:"status,omitempty"`
	Result *ScrollResult `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (s *ScrollPointsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ScrollPointsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScrollPointsResponse(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScrollPointsResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Look only for points which satisfies this conditions. If not provided - all points.
type ScrollRequestFilter struct {
	typeName string
	Filter   *Filter
	Unknown  interface{}
}

func NewScrollRequestFilterFromFilter(value *Filter) *ScrollRequestFilter {
	return &ScrollRequestFilter{typeName: "filter", Filter: value}
}

func NewScrollRequestFilterFromUnknown(value interface{}) *ScrollRequestFilter {
	return &ScrollRequestFilter{typeName: "unknown", Unknown: value}
}

func (s *ScrollRequestFilter) UnmarshalJSON(data []byte) error {
	valueFilter := new(Filter)
	if err := json.Unmarshal(data, &valueFilter); err == nil {
		s.typeName = "filter"
		s.Filter = valueFilter
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		s.typeName = "unknown"
		s.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ScrollRequestFilter) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "filter":
		return json.Marshal(s.Filter)
	case "unknown":
		return json.Marshal(s.Unknown)
	}
}

type ScrollRequestFilterVisitor interface {
	VisitFilter(*Filter) error
	VisitUnknown(interface{}) error
}

func (s *ScrollRequestFilter) Accept(visitor ScrollRequestFilterVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "filter":
		return visitor.VisitFilter(s.Filter)
	case "unknown":
		return visitor.VisitUnknown(s.Unknown)
	}
}

// Start ID to read points from.
type ScrollRequestOffset struct {
	typeName        string
	ExtendedPointId *ExtendedPointId
	Unknown         interface{}
}

func NewScrollRequestOffsetFromExtendedPointId(value *ExtendedPointId) *ScrollRequestOffset {
	return &ScrollRequestOffset{typeName: "extendedPointId", ExtendedPointId: value}
}

func NewScrollRequestOffsetFromUnknown(value interface{}) *ScrollRequestOffset {
	return &ScrollRequestOffset{typeName: "unknown", Unknown: value}
}

func (s *ScrollRequestOffset) UnmarshalJSON(data []byte) error {
	valueExtendedPointId := new(ExtendedPointId)
	if err := json.Unmarshal(data, &valueExtendedPointId); err == nil {
		s.typeName = "extendedPointId"
		s.ExtendedPointId = valueExtendedPointId
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		s.typeName = "unknown"
		s.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ScrollRequestOffset) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "extendedPointId":
		return json.Marshal(s.ExtendedPointId)
	case "unknown":
		return json.Marshal(s.Unknown)
	}
}

type ScrollRequestOffsetVisitor interface {
	VisitExtendedPointId(*ExtendedPointId) error
	VisitUnknown(interface{}) error
}

func (s *ScrollRequestOffset) Accept(visitor ScrollRequestOffsetVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "extendedPointId":
		return visitor.VisitExtendedPointId(s.ExtendedPointId)
	case "unknown":
		return visitor.VisitUnknown(s.Unknown)
	}
}

// Specify in which shards to look for the points, if not specified - look in all shards
type ScrollRequestShardKey struct {
	typeName         string
	ShardKeySelector *ShardKeySelector
	Unknown          interface{}
}

func NewScrollRequestShardKeyFromShardKeySelector(value *ShardKeySelector) *ScrollRequestShardKey {
	return &ScrollRequestShardKey{typeName: "shardKeySelector", ShardKeySelector: value}
}

func NewScrollRequestShardKeyFromUnknown(value interface{}) *ScrollRequestShardKey {
	return &ScrollRequestShardKey{typeName: "unknown", Unknown: value}
}

func (s *ScrollRequestShardKey) UnmarshalJSON(data []byte) error {
	valueShardKeySelector := new(ShardKeySelector)
	if err := json.Unmarshal(data, &valueShardKeySelector); err == nil {
		s.typeName = "shardKeySelector"
		s.ShardKeySelector = valueShardKeySelector
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		s.typeName = "unknown"
		s.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ScrollRequestShardKey) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "shardKeySelector":
		return json.Marshal(s.ShardKeySelector)
	case "unknown":
		return json.Marshal(s.Unknown)
	}
}

type ScrollRequestShardKeyVisitor interface {
	VisitShardKeySelector(*ShardKeySelector) error
	VisitUnknown(interface{}) error
}

func (s *ScrollRequestShardKey) Accept(visitor ScrollRequestShardKeyVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "shardKeySelector":
		return visitor.VisitShardKeySelector(s.ShardKeySelector)
	case "unknown":
		return visitor.VisitUnknown(s.Unknown)
	}
}

// Select which payload to return with the response. Default: All
type ScrollRequestWithPayload struct {
	typeName             string
	WithPayloadInterface *WithPayloadInterface
	Unknown              interface{}
}

func NewScrollRequestWithPayloadFromWithPayloadInterface(value *WithPayloadInterface) *ScrollRequestWithPayload {
	return &ScrollRequestWithPayload{typeName: "withPayloadInterface", WithPayloadInterface: value}
}

func NewScrollRequestWithPayloadFromUnknown(value interface{}) *ScrollRequestWithPayload {
	return &ScrollRequestWithPayload{typeName: "unknown", Unknown: value}
}

func (s *ScrollRequestWithPayload) UnmarshalJSON(data []byte) error {
	valueWithPayloadInterface := new(WithPayloadInterface)
	if err := json.Unmarshal(data, &valueWithPayloadInterface); err == nil {
		s.typeName = "withPayloadInterface"
		s.WithPayloadInterface = valueWithPayloadInterface
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		s.typeName = "unknown"
		s.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ScrollRequestWithPayload) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "withPayloadInterface":
		return json.Marshal(s.WithPayloadInterface)
	case "unknown":
		return json.Marshal(s.Unknown)
	}
}

type ScrollRequestWithPayloadVisitor interface {
	VisitWithPayloadInterface(*WithPayloadInterface) error
	VisitUnknown(interface{}) error
}

func (s *ScrollRequestWithPayload) Accept(visitor ScrollRequestWithPayloadVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "withPayloadInterface":
		return visitor.VisitWithPayloadInterface(s.WithPayloadInterface)
	case "unknown":
		return visitor.VisitUnknown(s.Unknown)
	}
}

type SearchBatchPointsResponse struct {
	// Time spent to process this request
	Time   *float64         `json:"time,omitempty"`
	Status *string          `json:"status,omitempty"`
	Result [][]*ScoredPoint `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SearchBatchPointsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchBatchPointsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchBatchPointsResponse(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchBatchPointsResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Look only for points which satisfies this conditions
type SearchGroupsRequestFilter struct {
	typeName string
	Filter   *Filter
	Unknown  interface{}
}

func NewSearchGroupsRequestFilterFromFilter(value *Filter) *SearchGroupsRequestFilter {
	return &SearchGroupsRequestFilter{typeName: "filter", Filter: value}
}

func NewSearchGroupsRequestFilterFromUnknown(value interface{}) *SearchGroupsRequestFilter {
	return &SearchGroupsRequestFilter{typeName: "unknown", Unknown: value}
}

func (s *SearchGroupsRequestFilter) UnmarshalJSON(data []byte) error {
	valueFilter := new(Filter)
	if err := json.Unmarshal(data, &valueFilter); err == nil {
		s.typeName = "filter"
		s.Filter = valueFilter
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		s.typeName = "unknown"
		s.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SearchGroupsRequestFilter) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "filter":
		return json.Marshal(s.Filter)
	case "unknown":
		return json.Marshal(s.Unknown)
	}
}

type SearchGroupsRequestFilterVisitor interface {
	VisitFilter(*Filter) error
	VisitUnknown(interface{}) error
}

func (s *SearchGroupsRequestFilter) Accept(visitor SearchGroupsRequestFilterVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "filter":
		return visitor.VisitFilter(s.Filter)
	case "unknown":
		return visitor.VisitUnknown(s.Unknown)
	}
}

// Additional search params
type SearchGroupsRequestParams struct {
	typeName     string
	SearchParams *SearchParams
	Unknown      interface{}
}

func NewSearchGroupsRequestParamsFromSearchParams(value *SearchParams) *SearchGroupsRequestParams {
	return &SearchGroupsRequestParams{typeName: "searchParams", SearchParams: value}
}

func NewSearchGroupsRequestParamsFromUnknown(value interface{}) *SearchGroupsRequestParams {
	return &SearchGroupsRequestParams{typeName: "unknown", Unknown: value}
}

func (s *SearchGroupsRequestParams) UnmarshalJSON(data []byte) error {
	valueSearchParams := new(SearchParams)
	if err := json.Unmarshal(data, &valueSearchParams); err == nil {
		s.typeName = "searchParams"
		s.SearchParams = valueSearchParams
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		s.typeName = "unknown"
		s.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SearchGroupsRequestParams) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "searchParams":
		return json.Marshal(s.SearchParams)
	case "unknown":
		return json.Marshal(s.Unknown)
	}
}

type SearchGroupsRequestParamsVisitor interface {
	VisitSearchParams(*SearchParams) error
	VisitUnknown(interface{}) error
}

func (s *SearchGroupsRequestParams) Accept(visitor SearchGroupsRequestParamsVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "searchParams":
		return visitor.VisitSearchParams(s.SearchParams)
	case "unknown":
		return visitor.VisitUnknown(s.Unknown)
	}
}

// Specify in which shards to look for the points, if not specified - look in all shards
type SearchGroupsRequestShardKey struct {
	typeName         string
	ShardKeySelector *ShardKeySelector
	Unknown          interface{}
}

func NewSearchGroupsRequestShardKeyFromShardKeySelector(value *ShardKeySelector) *SearchGroupsRequestShardKey {
	return &SearchGroupsRequestShardKey{typeName: "shardKeySelector", ShardKeySelector: value}
}

func NewSearchGroupsRequestShardKeyFromUnknown(value interface{}) *SearchGroupsRequestShardKey {
	return &SearchGroupsRequestShardKey{typeName: "unknown", Unknown: value}
}

func (s *SearchGroupsRequestShardKey) UnmarshalJSON(data []byte) error {
	valueShardKeySelector := new(ShardKeySelector)
	if err := json.Unmarshal(data, &valueShardKeySelector); err == nil {
		s.typeName = "shardKeySelector"
		s.ShardKeySelector = valueShardKeySelector
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		s.typeName = "unknown"
		s.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SearchGroupsRequestShardKey) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "shardKeySelector":
		return json.Marshal(s.ShardKeySelector)
	case "unknown":
		return json.Marshal(s.Unknown)
	}
}

type SearchGroupsRequestShardKeyVisitor interface {
	VisitShardKeySelector(*ShardKeySelector) error
	VisitUnknown(interface{}) error
}

func (s *SearchGroupsRequestShardKey) Accept(visitor SearchGroupsRequestShardKeyVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "shardKeySelector":
		return visitor.VisitShardKeySelector(s.ShardKeySelector)
	case "unknown":
		return visitor.VisitUnknown(s.Unknown)
	}
}

// Look for points in another collection using the group ids
type SearchGroupsRequestWithLookup struct {
	typeName            string
	WithLookupInterface *WithLookupInterface
	Unknown             interface{}
}

func NewSearchGroupsRequestWithLookupFromWithLookupInterface(value *WithLookupInterface) *SearchGroupsRequestWithLookup {
	return &SearchGroupsRequestWithLookup{typeName: "withLookupInterface", WithLookupInterface: value}
}

func NewSearchGroupsRequestWithLookupFromUnknown(value interface{}) *SearchGroupsRequestWithLookup {
	return &SearchGroupsRequestWithLookup{typeName: "unknown", Unknown: value}
}

func (s *SearchGroupsRequestWithLookup) UnmarshalJSON(data []byte) error {
	valueWithLookupInterface := new(WithLookupInterface)
	if err := json.Unmarshal(data, &valueWithLookupInterface); err == nil {
		s.typeName = "withLookupInterface"
		s.WithLookupInterface = valueWithLookupInterface
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		s.typeName = "unknown"
		s.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SearchGroupsRequestWithLookup) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "withLookupInterface":
		return json.Marshal(s.WithLookupInterface)
	case "unknown":
		return json.Marshal(s.Unknown)
	}
}

type SearchGroupsRequestWithLookupVisitor interface {
	VisitWithLookupInterface(*WithLookupInterface) error
	VisitUnknown(interface{}) error
}

func (s *SearchGroupsRequestWithLookup) Accept(visitor SearchGroupsRequestWithLookupVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "withLookupInterface":
		return visitor.VisitWithLookupInterface(s.WithLookupInterface)
	case "unknown":
		return visitor.VisitUnknown(s.Unknown)
	}
}

// Select which payload to return with the response. Default: None
type SearchGroupsRequestWithPayload struct {
	typeName             string
	WithPayloadInterface *WithPayloadInterface
	Unknown              interface{}
}

func NewSearchGroupsRequestWithPayloadFromWithPayloadInterface(value *WithPayloadInterface) *SearchGroupsRequestWithPayload {
	return &SearchGroupsRequestWithPayload{typeName: "withPayloadInterface", WithPayloadInterface: value}
}

func NewSearchGroupsRequestWithPayloadFromUnknown(value interface{}) *SearchGroupsRequestWithPayload {
	return &SearchGroupsRequestWithPayload{typeName: "unknown", Unknown: value}
}

func (s *SearchGroupsRequestWithPayload) UnmarshalJSON(data []byte) error {
	valueWithPayloadInterface := new(WithPayloadInterface)
	if err := json.Unmarshal(data, &valueWithPayloadInterface); err == nil {
		s.typeName = "withPayloadInterface"
		s.WithPayloadInterface = valueWithPayloadInterface
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		s.typeName = "unknown"
		s.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SearchGroupsRequestWithPayload) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "withPayloadInterface":
		return json.Marshal(s.WithPayloadInterface)
	case "unknown":
		return json.Marshal(s.Unknown)
	}
}

type SearchGroupsRequestWithPayloadVisitor interface {
	VisitWithPayloadInterface(*WithPayloadInterface) error
	VisitUnknown(interface{}) error
}

func (s *SearchGroupsRequestWithPayload) Accept(visitor SearchGroupsRequestWithPayloadVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "withPayloadInterface":
		return visitor.VisitWithPayloadInterface(s.WithPayloadInterface)
	case "unknown":
		return visitor.VisitUnknown(s.Unknown)
	}
}

// Whether to return the point vector with the result?
type SearchGroupsRequestWithVector struct {
	typeName   string
	WithVector *WithVector
	Unknown    interface{}
}

func NewSearchGroupsRequestWithVectorFromWithVector(value *WithVector) *SearchGroupsRequestWithVector {
	return &SearchGroupsRequestWithVector{typeName: "withVector", WithVector: value}
}

func NewSearchGroupsRequestWithVectorFromUnknown(value interface{}) *SearchGroupsRequestWithVector {
	return &SearchGroupsRequestWithVector{typeName: "unknown", Unknown: value}
}

func (s *SearchGroupsRequestWithVector) UnmarshalJSON(data []byte) error {
	valueWithVector := new(WithVector)
	if err := json.Unmarshal(data, &valueWithVector); err == nil {
		s.typeName = "withVector"
		s.WithVector = valueWithVector
		return nil
	}
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		s.typeName = "unknown"
		s.Unknown = valueUnknown
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SearchGroupsRequestWithVector) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "withVector":
		return json.Marshal(s.WithVector)
	case "unknown":
		return json.Marshal(s.Unknown)
	}
}

type SearchGroupsRequestWithVectorVisitor interface {
	VisitWithVector(*WithVector) error
	VisitUnknown(interface{}) error
}

func (s *SearchGroupsRequestWithVector) Accept(visitor SearchGroupsRequestWithVectorVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "withVector":
		return visitor.VisitWithVector(s.WithVector)
	case "unknown":
		return visitor.VisitUnknown(s.Unknown)
	}
}

type SearchPointGroupsResponse struct {
	// Time spent to process this request
	Time   *float64      `json:"time,omitempty"`
	Status *string       `json:"status,omitempty"`
	Result *GroupsResult `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SearchPointGroupsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchPointGroupsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchPointGroupsResponse(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchPointGroupsResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SearchPointsResponse struct {
	// Time spent to process this request
	Time   *float64       `json:"time,omitempty"`
	Status *string        `json:"status,omitempty"`
	Result []*ScoredPoint `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SearchPointsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchPointsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchPointsResponse(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchPointsResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SetPayloadResponse struct {
	// Time spent to process this request
	Time   *float64      `json:"time,omitempty"`
	Status *string       `json:"status,omitempty"`
	Result *UpdateResult `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SetPayloadResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SetPayloadResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SetPayloadResponse(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SetPayloadResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type UpdateVectorsResponse struct {
	// Time spent to process this request
	Time   *float64      `json:"time,omitempty"`
	Status *string       `json:"status,omitempty"`
	Result *UpdateResult `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UpdateVectorsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateVectorsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateVectorsResponse(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateVectorsResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpsertPointsResponse struct {
	// Time spent to process this request
	Time   *float64      `json:"time,omitempty"`
	Status *string       `json:"status,omitempty"`
	Result *UpdateResult `json:"result,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UpsertPointsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpsertPointsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpsertPointsResponse(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpsertPointsResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateVectorsRequest struct {
	// If true, wait for changes to actually happen
	Wait *bool `json:"-"`
	// define ordering guarantees for the operation
	Ordering *WriteOrdering `json:"-"`
	Body     *UpdateVectors `json:"-"`
}

func (u *UpdateVectorsRequest) UnmarshalJSON(data []byte) error {
	body := new(UpdateVectors)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	u.Body = body
	return nil
}

func (u *UpdateVectorsRequest) MarshalJSON() ([]byte, error) {
	return json.Marshal(u.Body)
}

type UpsertPointsRequest struct {
	// If true, wait for changes to actually happen
	Wait *bool `json:"-"`
	// define ordering guarantees for the operation
	Ordering *WriteOrdering         `json:"-"`
	Body     *PointInsertOperations `json:"-"`
}

func (u *UpsertPointsRequest) UnmarshalJSON(data []byte) error {
	body := new(PointInsertOperations)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	u.Body = body
	return nil
}

func (u *UpsertPointsRequest) MarshalJSON() ([]byte, error) {
	return json.Marshal(u.Body)
}
